--[[
-- Hello! This is an example project that bundles the Roblox-TS source into a
-- single file and uploads it to a GitHub release.
--
-- This script was generated by ci/bundle.lua, and should not be modified by hand.
-- To regenerate the code, run 'pnpm bundle' in the root directory.
--
-- Author: 0866
-- Source: https://github.com/richie0866/rbxts-bundle-example
--]]

-- Runtime library
local instances = {}
local modules = {}
local currentlyLoading = {}

local function runModule(object, context)
	currentlyLoading[context] = object

	local currentObject = object
	local depth = 0

	while currentObject do
		depth = depth + 1
		currentObject = currentlyLoading[currentObject]

		if currentObject == object then
			local str = currentObject.Name -- Get the string traceback

			for _ = 1, depth do
				currentObject = currentlyLoading[currentObject]
				str = str .. "  ⇒ " .. currentObject.Name
			end

			error("Failed to load '" .. object.Name .. "'; Detected a circular dependency chain: " .. str, 2)
		end
	end

	local module = modules[object]
	local data = module.callback()

	if currentlyLoading[context] == object then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

local function requireModule(object, context)
	local module = modules[object]

	if module.loaded then
		return module.result
	else
		module.result = runModule(object, context)
		module.loaded = true
		return module.result
	end
end

local function __rbx(name, className, path, parentPath)
	local rbx = Instance.new(className)
	rbx.Name = name
	rbx.Parent = instances[parentPath]
	instances[path] = rbx
	return rbx
end

local function __lua(name, className, path, parentPath, callback)
	local rbx = __rbx(name, className, path, parentPath)

	modules[rbx] = {
		callback = callback,
		result = nil,
		loaded = false,
		globals = {
			script = rbx,
			require = function(object)
				if modules[object] then
					return requireModule(object, rbx)
				else
					return require(object)
				end
			end,
		},
	}
end

local function __env(path)
	return modules[instances[path]].globals
end

local function __start()
	for rbx, module in pairs(modules) do
		if rbx.ClassName == "LocalScript" and not rbx.Disabled then
			task.spawn(module.callback)
		end
	end
end

-- Generated by ci/bundle.lua
__rbx("bundle-ex", "Folder", "bundle-ex", nil)
__rbx("life-sentence", "Folder", "bundle-ex.life-sentence", "bundle-ex")
__lua("src", "ModuleScript", "bundle-ex.life-sentence.src", "bundle-ex.life-sentence", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.life-sentence.src\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.include.RuntimeLib)\nlocal Flamework = TS.import(script, script.Parent.Parent, \"include\", \"node_modules\", \"@flamework\", \"core\", \"out\").Flamework\nTS.import(script, script, \"ui\")\npcall(Flamework.ignite)\nreturn nil\n", "bundle-ex.life-sentence.src"))(__env)
end)
__lua("ui", "ModuleScript", "bundle-ex.life-sentence.src.ui", "bundle-ex.life-sentence.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.life-sentence.src.ui\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.Parent.include.RuntimeLib)\nlocal Library = TS.import(script, script.Parent.Parent.Parent, \"shared\", \"src\", \"structures\", \"ui-library\", \"ui-library\")\nlocal window = Library:CreateWindow({\n\9Title = \"nebula - life sentence\",\n\9AutoShow = true,\n})\nLibrary:Initalize(window)\nreturn nil\n", "bundle-ex.life-sentence.src.ui"))(__env)
end)
__rbx("loader", "Folder", "bundle-ex.loader", "bundle-ex")
__rbx("src", "Folder", "bundle-ex.loader.src", "bundle-ex.loader")
__lua("main", "LocalScript", "bundle-ex.loader.src.main", "bundle-ex.loader.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.loader.src.main\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.Parent.include.RuntimeLib)\nlocal Flamework = TS.import(script, script.Parent.Parent.Parent, \"include\", \"node_modules\", \"@flamework\", \"core\", \"out\").Flamework\nTS.import(script, script.Parent, \"services\", \"loader.service\")\nFlamework.ignite()\nlocal loaderService = Flamework.resolveDependency(\"loader/src/services/loader.service@LoaderService\")\nlocal gamePackage = loaderService:determineWithPlaceId(game.PlaceId)\nloaderService:importGamePackage(gamePackage)\n", "bundle-ex.loader.src.main"))(__env)
end)
__rbx("services", "Folder", "bundle-ex.loader.src.services", "bundle-ex.loader.src")
__lua("loader.service", "ModuleScript", "bundle-ex.loader.src.services.loader.service", "bundle-ex.loader.src.services", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.loader.src.services.loader.service\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)\nlocal Reflect = TS.import(script, script.Parent.Parent.Parent.Parent, \"include\", \"node_modules\", \"@flamework\", \"core\", \"out\").Reflect\nlocal Service = TS.import(script, script.Parent.Parent.Parent.Parent, \"include\", \"node_modules\", \"@flamework\", \"core\", \"out\").Service\nlocal PLACE_ID_MAPPINGS = {\n\9[10427037408] = \"life-sentence\",\n\9[-2] = \"shared\",\n}\nlocal LoaderService\ndo\n\9LoaderService = setmetatable({}, {\n\9\9__tostring = function()\n\9\9\9return \"LoaderService\"\n\9\9end,\n\9})\n\9LoaderService.__index = LoaderService\n\9function LoaderService.new(...)\n\9\9local self = setmetatable({}, LoaderService)\n\9\9return self:constructor(...) or self\n\9end\n\9function LoaderService:constructor()\n\9end\n\9function LoaderService:importGamePackage(packageName)\n\9\9repeat\n\9\9\9if packageName == \"life-sentence\" then\n\9\9\9\9return TS.Promise.new(function(resolve)\n\9\9\9\9\9resolve(TS.import(script, script.Parent.Parent.Parent.Parent, \"life-sentence\", \"src\"))\n\9\9\9\9end)\n\9\9\9end\n\9\9\9if packageName == \"shared\" then\n\9\9\9\9return TS.Promise.new(function(resolve)\n\9\9\9\9\9resolve(TS.import(script, script.Parent.Parent.Parent.Parent, \"shared\", \"src\"))\n\9\9\9\9end)\n\9\9\9end\n\9\9until true\n\9end\n\9function LoaderService:determineWithPlaceId(placeId)\n\9\9-- have to use pkg since package is a reserved word\n\9\9-- like bro it doesnt even have any functionallity\n\9\9local pkg = PLACE_ID_MAPPINGS[placeId]\n\9\9if not pkg then\n\9\9\9error(\"Couldn't find package for placeId \" .. tostring(placeId))\n\9\9end\n\9\9return pkg\n\9end\nend\n-- (Flamework) LoaderService metadata\nReflect.defineMetadata(LoaderService, \"identifier\", \"loader/src/services/loader.service@LoaderService\")\nReflect.decorate(LoaderService, \"$:flamework@Service\", Service, {})\nreturn {\n\9LoaderService = LoaderService,\n}\n", "bundle-ex.loader.src.services.loader.service"))(__env)
end)
__rbx("types", "Folder", "bundle-ex.loader.src.types", "bundle-ex.loader.src")
__rbx("shared", "Folder", "bundle-ex.shared", "bundle-ex")
__lua("src", "ModuleScript", "bundle-ex.shared.src", "bundle-ex.shared", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.shared.src\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.include.RuntimeLib)\nlocal exports = {}\nlocal Library = TS.import(script, script, \"structures\", \"ui-library\", \"ui-library\")\nlocal UILibrary = Library\nfor _k, _v in TS.import(script, script, \"structures\", \"Teleporter\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"util\", \"character\") or {} do\n\9exports[_k] = _v\nend\nexports.UILibrary = UILibrary\nreturn exports\n", "bundle-ex.shared.src"))(__env)
end)
__rbx("structures", "Folder", "bundle-ex.shared.src.structures", "bundle-ex.shared.src")
__lua("Teleporter", "ModuleScript", "bundle-ex.shared.src.structures.Teleporter", "bundle-ex.shared.src.structures", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.shared.src.structures.Teleporter\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)\nlocal localChar = TS.import(script, script.Parent.Parent, \"util\", \"character\").localChar\nlocal Teleporter\ndo\n\9Teleporter = setmetatable({}, {\n\9\9__tostring = function()\n\9\9\9return \"Teleporter\"\n\9\9end,\n\9})\n\9Teleporter.__index = Teleporter\n\9function Teleporter.new(...)\n\9\9local self = setmetatable({}, Teleporter)\n\9\9return self:constructor(...) or self\n\9end\n\9function Teleporter:constructor(teleports, teleportFn)\n\9\9self.teleports = teleports\n\9\9self.teleportFn = teleportFn or (function(cframe)\n\9\9\9local _result = localChar\n\9\9\9if _result ~= nil then\n\9\9\9\9_result:PivotTo(cframe)\n\9\9\9end\n\9\9end)\n\9end\n\9function Teleporter:teleportTo(teleportKey)\n\9\9self.teleportFn(self.teleports[teleportKey])\n\9end\n\9function Teleporter:listTeleports()\n\9\9local teleportList = {}\n\9\9for teleportName, _ in pairs(self.teleports) do\n\9\9\9table.insert(teleportList, teleportName)\n\9\9end\n\9\9return teleportList\n\9end\nend\nreturn {\n\9Teleporter = Teleporter,\n}\n", "bundle-ex.shared.src.structures.Teleporter"))(__env)
end)
__rbx("ui-library", "Folder", "bundle-ex.shared.src.structures.ui-library", "bundle-ex.shared.src.structures")
__lua("ui-library", "ModuleScript", "bundle-ex.shared.src.structures.ui-library.ui-library", "bundle-ex.shared.src.structures.ui-library", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.shared.src.structures.ui-library.ui-library\")local script,require=_.script,_.require --!nocheck\n\nlocal InputService = game:GetService(\"UserInputService\")\nlocal TextService = game:GetService(\"TextService\")\nlocal CoreGui = game:GetService(\"CoreGui\")\nlocal Teams = game:GetService(\"Teams\")\nlocal Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal RenderStepped = RunService.RenderStepped\nlocal LocalPlayer = Players.LocalPlayer\nlocal Mouse = LocalPlayer:GetMouse()\n\nlocal ProtectGui = protectgui or (syn and syn.protect_gui) or function() end\n\nlocal ScreenGui = Instance.new(\"ScreenGui\")\nProtectGui(ScreenGui)\n\nScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global\nScreenGui.Parent = CoreGui\n\nlocal Toggles = {}\nlocal Options = {}\n\ngetgenv().Toggles = Toggles\ngetgenv().Options = Options\n\n-- stolen from shadow :)\nlocal httpService = game:GetService(\"HttpService\")\n\nlocal fonts = {\n\9Cozette = \"https://github.com/slavfox/Cozette/releases/download/v.1.19.1/CozetteVector.otf\",\n\9PlexMono = \"https://github.com/IBM/plex/raw/master/IBM-Plex-Mono/fonts/complete/otf/IBMPlexMono-Regular.otf\",\n\9Quicksand = \"https://github.com/Rain-Design/Fonts/raw/main/Quicksand-Regular.otf\",\n\9ProggyClean = \"https://github.com/bluescan/proggyfonts/raw/master/ProggyVector/ProggyVector Regular.ttf\",\n\9ApathyMono = \"https://github.com/technorav3nn/fonts/raw/main/apathy-monospace.otf\",\n}\n\nif not isfolder(\"Fonts\") then\n\9makefolder(\"Fonts\")\nend\n\nfor font, url in pairs(fonts) do\n\9if isfile(\"Fonts\" .. font .. \".otf\") then\n\9\9continue\n\9end\n\n\9local fontRequest = request({\n\9\9Url = url,\n\9\9Method = \"GET\",\n\9})\n\n\9writefile(\"Fonts/\" .. font .. \".otf\", fontRequest.Body)\nend\n\nlocal function getFont(font)\n\9assert(fonts[font], \"There's no font called: \" .. font, 0)\n\n\9local fontFace = \"Fonts/\" .. font .. \"Face\" .. \".json\"\n\9local fontPath = \"Fonts/\" .. font .. \".otf\"\n\n\9if not isfile(fontFace) then\n\9\9writefile(\n\9\9\9fontFace,\n\9\9\9httpService:JSONEncode({\n\9\9\9\9name = font,\n\9\9\9\9faces = { { name = \"Regular\", weight = 300, style = \"normal\", assetId = getcustomasset(fontPath) } },\n\9\9\9})\n\9\9)\n\9end\n\n\9return getcustomasset(fontFace)\nend\n\nlocal Library = {\n\9Registry = {},\n\9RegistryMap = {},\n\n\9HudRegistry = {},\n\n\9FontColor = Color3.fromRGB(255, 255, 255),\n\9MainColor = Color3.fromRGB(28, 28, 28),\n\9BackgroundColor = Color3.fromRGB(20, 20, 20),\n\9AccentColor = Color3.fromRGB(0, 85, 255),\n\9OutlineColor = Color3.fromRGB(50, 50, 50),\n\9RiskColor = Color3.fromRGB(255, 50, 50),\n\n\9Black = Color3.new(0, 0, 0),\n\9Font = Font.fromEnum(Enum.Font.Code),--[[ Font.new(getFont(\"ApathyMono\")),]] --[[ Enum.Font.Code ]]\n\9-- sono monospace id: 12187362578\n\n\9OpenedFrames = {},\n\n\9Signals = {},\n\9ScreenGui = ScreenGui,\n}\n\nlocal RainbowStep = 0\nlocal Hue = 0\n\ntable.insert(\n\9Library.Signals,\n\9RenderStepped:Connect(function(Delta)\n\9\9RainbowStep = RainbowStep + Delta\n\n\9\9if RainbowStep >= (1 / 60) then\n\9\9\9RainbowStep = 0\n\n\9\9\9Hue = Hue + (1 / 400)\n\n\9\9\9if Hue > 1 then\n\9\9\9\9Hue = 0\n\9\9\9end\n\n\9\9\9Library.CurrentRainbowHue = Hue\n\9\9\9Library.CurrentRainbowColor = Color3.fromHSV(Hue, 0.8, 1)\n\9\9end\n\9end)\n)\n\nlocal function GetPlayersString()\n\9local PlayerList = Players:GetPlayers()\n\9for i = 1, #PlayerList do\n\9\9PlayerList[i] = PlayerList[i].Name\n\9end\n\9return PlayerList\nend\n\nlocal function GetTeamsString()\n\9local TeamList = Teams:GetTeams()\n\9for i = 1, #TeamList do\n\9\9TeamList[i] = TeamList[i].Name\n\9end\n\9return TeamList\nend\n\n-- init func\n\nfunction Library:Initalize(window)\n\9local repo = \"https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/\"\n\n\9local ThemeManager = loadstring(game:HttpGet(repo .. \"addons/ThemeManager.lua\"))()\n\9local SaveManager = loadstring(game:HttpGet(repo .. \"addons/SaveManager.lua\"))()\n\n\9local settingsTab = window:AddTab(\"Settings\")\n\n\9-- UI Settings\n\9local menuGroup = settingsTab:AddLeftGroupbox(\"Menu\")\n\n\9-- I set NoUI so it does not show up in the keybinds menu\n\9menuGroup:AddButton(\"Unload\", function()\n\9\9Library:Unload()\n\9end)\n\9menuGroup:AddLabel(\"Menu bind\"):AddKeyPicker(\"MenuKeybind\", { Default = \"End\", NoUI = true, Text = \"Menu keybind\" })\n\n\9Library.ToggleKeybind = getgenv().Options.MenuKeybind\n\n\9ThemeManager:SetLibrary(Library)\n\9SaveManager:SetLibrary(Library)\n\n\9SaveManager:IgnoreThemeSettings()\n\9SaveManager:SetIgnoreIndexes({ \"MenuKeybind\" })\n\n\9ThemeManager:SetFolder(\"MyScriptHub\")\n\9SaveManager:SetFolder(\"MyScriptHub/specific-game\")\n\n\9SaveManager:BuildConfigSection(settingsTab)\n\n\9ThemeManager:ApplyToTab(settingsTab)\n\n\9getgenv().Library = Library\n\n\9return {\n\9\9Library = Library,\n\9\9SaveManager = SaveManager,\n\9\9ThemeManager = ThemeManager,\n\9\9window = window,\n\9}\nend\n\nfunction Library:SafeCallback(f, ...)\n\9if not Library.NotifyOnError then\n\9\9return f(...)\n\9end\n\n\9local success, event = pcall(f, ...)\n\n\9if not success then\n\9\9local _, i = event:find(\":%d+: \")\n\n\9\9if not i then\n\9\9\9return Library:Notify(event)\n\9\9end\n\n\9\9return Library:Notify(event:sub(i + 1), 3)\n\9end\nend\n\nfunction Library:AttemptSave()\n\9if Library.SaveManager then\n\9\9Library.SaveManager:Save()\n\9end\nend\n\nfunction Library:Create(Class, Properties)\n\9local _Instance = Class\n\n\9if type(Class) == \"string\" then\n\9\9_Instance = Instance.new(Class)\n\9end\n\n\9for Property, Value in next, Properties do\n\9\9_Instance[Property] = Value\n\9end\n\n\9return _Instance\nend\n\nfunction Library:CreateLabel(Properties, IsHud)\n\9local _Instance = Library:Create(\"TextLabel\", {\n\9\9BackgroundTransparency = 1,\n\9\9FontFace = Library.Font,\n\9\9TextColor3 = Library.FontColor,\n\9\9TextSize = 16,\n\9\9TextStrokeTransparency = 0,\n\9})\n\n\9Library:AddToRegistry(_Instance, {\n\9\9TextColor3 = \"FontColor\",\n\9}, IsHud)\n\n\9return Library:Create(_Instance, Properties)\nend\n\nfunction Library:MakeDraggable(Instance, Cutoff)\n\9Instance.Active = true\n\n\9Instance.InputBegan:Connect(function(Input)\n\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9local ObjPos = Vector2.new(Mouse.X - Instance.AbsolutePosition.X, Mouse.Y - Instance.AbsolutePosition.Y)\n\n\9\9\9if ObjPos.Y > (Cutoff or 40) then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do\n\9\9\9\9Instance.Position = UDim2.new(\n\9\9\9\9\0090,\n\9\9\9\9\9Mouse.X - ObjPos.X + (Instance.Size.X.Offset * Instance.AnchorPoint.X),\n\9\9\9\9\0090,\n\9\9\9\9\9Mouse.Y - ObjPos.Y + (Instance.Size.Y.Offset * Instance.AnchorPoint.Y)\n\9\9\9\9)\n\n\9\9\9\9RenderStepped:Wait()\n\9\9\9end\n\9\9end\n\9end)\nend\n\nfunction Library:AddToolTip(InfoStr, HoverInstance)\n\9local X, Y = Library:GetTextBounds(InfoStr, Library.Font, 14)\n\9local Tooltip = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.MainColor,\n\9\9BorderColor3 = Library.OutlineColor,\n\n\9\9Size = UDim2.fromOffset(X + 5, Y + 4),\n\9\9ZIndex = 100,\n\9\9Parent = Library.ScreenGui,\n\n\9\9Visible = false,\n\9})\n\n\9local Label = Library:CreateLabel({\n\9\9Position = UDim2.fromOffset(3, 1),\n\9\9Size = UDim2.fromOffset(X, Y),\n\9\9TextSize = 14,\n\9\9Text = InfoStr,\n\9\9TextColor3 = Library.FontColor,\n\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9ZIndex = Tooltip.ZIndex + 1,\n\n\9\9Parent = Tooltip,\n\9})\n\n\9Library:AddToRegistry(Tooltip, {\n\9\9BackgroundColor3 = \"MainColor\",\n\9\9BorderColor3 = \"OutlineColor\",\n\9})\n\n\9Library:AddToRegistry(Label, {\n\9\9TextColor3 = \"FontColor\",\n\9})\n\n\9local IsHovering = false\n\9HoverInstance.MouseEnter:Connect(function()\n\9\9IsHovering = true\n\n\9\9Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)\n\9\9Tooltip.Visible = true\n\n\9\9while IsHovering do\n\9\9\9RunService.Heartbeat:Wait()\n\9\9\9Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)\n\9\9end\n\9end)\n\n\9HoverInstance.MouseLeave:Connect(function()\n\9\9IsHovering = false\n\9\9Tooltip.Visible = false\n\9end)\nend\n\nfunction Library:OnHighlight(HighlightInstance, Instance, Properties, PropertiesDefault)\n\9HighlightInstance.MouseEnter:Connect(function()\n\9\9local Reg = Library.RegistryMap[Instance]\n\n\9\9for Property, ColorIdx in next, Properties do\n\9\9\9Instance[Property] = Library[ColorIdx] or ColorIdx\n\n\9\9\9if Reg and Reg.Properties[Property] then\n\9\9\9\9Reg.Properties[Property] = ColorIdx\n\9\9\9end\n\9\9end\n\9end)\n\n\9HighlightInstance.MouseLeave:Connect(function()\n\9\9local Reg = Library.RegistryMap[Instance]\n\n\9\9for Property, ColorIdx in next, PropertiesDefault do\n\9\9\9Instance[Property] = Library[ColorIdx] or ColorIdx\n\n\9\9\9if Reg and Reg.Properties[Property] then\n\9\9\9\9Reg.Properties[Property] = ColorIdx\n\9\9\9end\n\9\9end\n\9end)\nend\n\nfunction Library:MouseIsOverOpenedFrame()\n\9for Frame, _ in next, Library.OpenedFrames do\n\9\9local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize\n\n\9\9if\n\9\9\9Mouse.X >= AbsPos.X\n\9\9\9and Mouse.X <= AbsPos.X + AbsSize.X\n\9\9\9and Mouse.Y >= AbsPos.Y\n\9\9\9and Mouse.Y <= AbsPos.Y + AbsSize.Y\n\9\9then\n\9\9\9return true\n\9\9end\n\9end\nend\n\nfunction Library:IsMouseOverFrame(Frame)\n\9local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize\n\n\9if\n\9\9Mouse.X >= AbsPos.X\n\9\9and Mouse.X <= AbsPos.X + AbsSize.X\n\9\9and Mouse.Y >= AbsPos.Y\n\9\9and Mouse.Y <= AbsPos.Y + AbsSize.Y\n\9then\n\9\9return true\n\9end\nend\n\nfunction Library:MapValue(Value, MinA, MaxA, MinB, MaxB)\n\9return (1 - ((Value - MinA) / (MaxA - MinA))) * MinB + ((Value - MinA) / (MaxA - MinA)) * MaxB\nend\n\n---@type Font Font\nfunction Library:GetTextBounds(Text, Font, Size, Resolution)\n\9local params = Instance.new(\"GetTextBoundsParams\")\n\9params.Text = Text\n\9params.Font = Font\n\9params.Size = Size\n\n\9local Bounds = TextService:GetTextBoundsAsync(params)\n\9return Bounds.X, Bounds.Y\nend\n\nfunction Library:GetDarkerColor(Color)\n\9local H, S, V = Color3.toHSV(Color)\n\9return Color3.fromHSV(H, S, V / 1.5)\nend\nLibrary.AccentColorDark = Library:GetDarkerColor(Library.AccentColor)\n\nfunction Library:AddToRegistry(Instance, Properties, IsHud)\n\9local Idx = #Library.Registry + 1\n\9local Data = {\n\9\9Instance = Instance,\n\9\9Properties = Properties,\n\9\9Idx = Idx,\n\9}\n\n\9table.insert(Library.Registry, Data)\n\9Library.RegistryMap[Instance] = Data\n\n\9if IsHud then\n\9\9table.insert(Library.HudRegistry, Data)\n\9end\nend\n\nfunction Library:RemoveFromRegistry(Instance)\n\9local Data = Library.RegistryMap[Instance]\n\n\9if Data then\n\9\9for Idx = #Library.Registry, 1, -1 do\n\9\9\9if Library.Registry[Idx] == Data then\n\9\9\9\9table.remove(Library.Registry, Idx)\n\9\9\9end\n\9\9end\n\n\9\9for Idx = #Library.HudRegistry, 1, -1 do\n\9\9\9if Library.HudRegistry[Idx] == Data then\n\9\9\9\9table.remove(Library.HudRegistry, Idx)\n\9\9\9end\n\9\9end\n\n\9\9Library.RegistryMap[Instance] = nil\n\9end\nend\n\nfunction Library:UpdateColorsUsingRegistry()\n\9-- TODO: Could have an 'active' list of objects\n\9-- where the active list only contains Visible objects.\n\n\9-- IMPL: Could setup .Changed events on the AddToRegistry function\n\9-- that listens for the 'Visible' propert being changed.\n\9-- Visible: true => Add to active list, and call UpdateColors function\n\9-- Visible: false => Remove from active list.\n\n\9-- The above would be especially efficient for a rainbow menu color or live color-changing.\n\n\9for Idx, Object in next, Library.Registry do\n\9\9for Property, ColorIdx in next, Object.Properties do\n\9\9\9if type(ColorIdx) == \"string\" then\n\9\9\9\9Object.Instance[Property] = Library[ColorIdx]\n\9\9\9elseif type(ColorIdx) == \"function\" then\n\9\9\9\9Object.Instance[Property] = ColorIdx()\n\9\9\9end\n\9\9end\n\9end\nend\n\nfunction Library:GiveSignal(Signal)\n\9-- Only used for signals not attached to library instances, as those should be cleaned up on object destruction by Roblox\n\9table.insert(Library.Signals, Signal)\nend\n\nfunction Library:Unload()\n\9-- Unload all of the signals\n\9for Idx = #Library.Signals, 1, -1 do\n\9\9local Connection = table.remove(Library.Signals, Idx)\n\9\9Connection:Disconnect()\n\9end\n\n\9-- Call our unload callback, maybe to undo some hooks etc\n\9if Library.OnUnload then\n\9\9Library.OnUnload()\n\9end\n\n\9ScreenGui:Destroy()\nend\n\nfunction Library:OnUnload(Callback)\n\9Library.OnUnload = Callback\nend\n\nLibrary:GiveSignal(ScreenGui.DescendantRemoving:Connect(function(Instance)\n\9if Library.RegistryMap[Instance] then\n\9\9Library:RemoveFromRegistry(Instance)\n\9end\nend))\n\nlocal BaseAddons = {}\n\ndo\n\9local Funcs = {}\n\n\9function Funcs:AddColorPicker(Idx, Info)\n\9\9local ToggleLabel = self.TextLabel\n\9\9-- local Container = self.Container;\n\n\9\9local ColorPicker = {\n\9\9\9Value = Info.Default,\n\9\9\9Type = \"ColorPicker\",\n\9\9\9Title = type(Info.Title) == \"string\" and Info.Title or \"Color picker\",\n\9\9\9Callback = Info.Callback or function(Color) end,\n\9\9}\n\n\9\9function ColorPicker:SetHSVFromRGB(Color)\n\9\9\9local H, S, V = Color3.toHSV(Color)\n\n\9\9\9ColorPicker.Hue = H\n\9\9\9ColorPicker.Sat = S\n\9\9\9ColorPicker.Vib = V\n\9\9end\n\n\9\9ColorPicker:SetHSVFromRGB(ColorPicker.Value)\n\n\9\9local DisplayFrame = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = ColorPicker.Value,\n\9\9\9BorderColor3 = Library:GetDarkerColor(ColorPicker.Value),\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(0, 28, 0, 14),\n\9\9\9ZIndex = 6,\n\9\9\9Parent = ToggleLabel,\n\9\9})\n\n\9\9-- 1/16/23\n\9\9-- Rewrote this to be placed inside the Library ScreenGui\n\9\9-- There was some issue which caused RelativeOffset to be way off\n\9\9-- Thus the color picker would never show\n\n\9\9local PickerFrameOuter = Library:Create(\"Frame\", {\n\9\9\9Name = \"Color\",\n\9\9\9BackgroundColor3 = Color3.new(1, 1, 1),\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Position = UDim2.fromOffset(DisplayFrame.AbsolutePosition.X, DisplayFrame.AbsolutePosition.Y + 18),\n\9\9\9Size = UDim2.fromOffset(230, 253),\n\9\9\9Visible = false,\n\9\9\9ZIndex = 15,\n\9\9\9Parent = ScreenGui,\n\9\9})\n\n\9\9DisplayFrame:GetPropertyChangedSignal(\"AbsolutePosition\"):Connect(function()\n\9\9\9PickerFrameOuter.Position =\n\9\9\9\9UDim2.fromOffset(DisplayFrame.AbsolutePosition.X, DisplayFrame.AbsolutePosition.Y + 18)\n\9\9end)\n\n\9\9local PickerFrameInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 16,\n\9\9\9Parent = PickerFrameOuter,\n\9\9})\n\n\9\9local Highlight = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.AccentColor,\n\9\9\9BorderSizePixel = 0,\n\9\9\9Size = UDim2.new(1, 0, 0, 2),\n\9\9\9ZIndex = 17,\n\9\9\9Parent = PickerFrameInner,\n\9\9})\n\n\9\9local SatVibMapOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Position = UDim2.new(0, 4, 0, 25),\n\9\9\9Size = UDim2.new(0, 200, 0, 200),\n\9\9\9ZIndex = 17,\n\9\9\9Parent = PickerFrameInner,\n\9\9})\n\n\9\9local SatVibMapInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 18,\n\9\9\9Parent = SatVibMapOuter,\n\9\9})\n\n\9\9local SatVibMap = Library:Create(\"ImageLabel\", {\n\9\9\9BorderSizePixel = 0,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 18,\n\9\9\9Image = \"rbxassetid://4155801252\",\n\9\9\9Parent = SatVibMapInner,\n\9\9})\n\n\9\9local HueSelectorOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Position = UDim2.new(0, 208, 0, 25),\n\9\9\9Size = UDim2.new(0, 15, 0, 200),\n\9\9\9ZIndex = 17,\n\9\9\9Parent = PickerFrameInner,\n\9\9})\n\n\9\9local HueSelectorInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Color3.new(1, 1, 1),\n\9\9\9BorderSizePixel = 0,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 18,\n\9\9\9Parent = HueSelectorOuter,\n\9\9})\n\n\9\9local HueTextSize = Library:GetTextBounds(\"Hex color\", Library.Font, 16) + 3\n\9\9local RgbTextSize = Library:GetTextBounds(\"255, 255, 255\", Library.Font, 16) + 3\n\n\9\9local HueBoxOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Position = UDim2.fromOffset(4, 228),\n\9\9\9Size = UDim2.new(0.5, -6, 0, 20),\n\9\9\9ZIndex = 18,\n\9\9\9Parent = PickerFrameInner,\n\9\9})\n\n\9\9local HueBoxInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 18,\n\9\9\9Parent = HueBoxOuter,\n\9\9})\n\n\9\9Library:Create(\"UIGradient\", {\n\9\9\9Color = ColorSequence.new({\n\9\9\9\9ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),\n\9\9\9\9ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212)),\n\9\9\9}),\n\9\9\9Rotation = 90,\n\9\9\9Parent = HueBoxInner,\n\9\9})\n\n\9\9local HueBox = Library:Create(\"TextBox\", {\n\9\9\9BackgroundTransparency = 1,\n\9\9\9Position = UDim2.new(0, 5, 0, 0),\n\9\9\9Size = UDim2.new(1, -5, 1, 0),\n\9\9\9FontFace = Library.Font,\n\9\9\9PlaceholderColor3 = Color3.fromRGB(190, 190, 190),\n\9\9\9PlaceholderText = \"Hex color\",\n\9\9\9Text = \"#FFFFFF\",\n\9\9\9TextColor3 = Library.FontColor,\n\9\9\9TextSize = 14,\n\9\9\9TextStrokeTransparency = 0,\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9ZIndex = 20,\n\9\9\9Parent = HueBoxInner,\n\9\9})\n\n\9\9local RgbBoxBase = Library:Create(HueBoxOuter:Clone(), {\n\9\9\9Position = UDim2.new(0.5, 2, 0, 228),\n\9\9\9Size = UDim2.new(0.5, -6, 0, 20),\n\9\9\9Parent = PickerFrameInner,\n\9\9})\n\n\9\9local RgbBox = Library:Create(RgbBoxBase.Frame:FindFirstChild(\"TextBox\"), {\n\9\9\9Text = \"255, 255, 255\",\n\9\9\9PlaceholderText = \"RGB color\",\n\9\9\9TextColor3 = Library.FontColor,\n\9\9})\n\n\9\9local DisplayLabel = Library:CreateLabel({\n\9\9\9Size = UDim2.new(1, 0, 0, 14),\n\9\9\9Position = UDim2.fromOffset(5, 5),\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9TextSize = 14,\n\9\9\9Text = ColorPicker.Title, --Info.Default;\n\9\9\9TextWrapped = false,\n\9\9\9ZIndex = 16,\n\9\9\9Parent = PickerFrameInner,\n\9\9})\n\n\9\9local ContextMenu = {}\n\9\9do\n\9\9\9ContextMenu.Options = {}\n\9\9\9ContextMenu.Container = Library:Create(\"Frame\", {\n\9\9\9\9BorderColor3 = Color3.new(),\n\9\9\9\9ZIndex = 14,\n\n\9\9\9\9Visible = false,\n\9\9\9\9Parent = ScreenGui,\n\9\9\9})\n\n\9\9\9ContextMenu.Inner = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9\9Size = UDim2.fromScale(1, 1),\n\9\9\9\9ZIndex = 15,\n\9\9\9\9Parent = ContextMenu.Container,\n\9\9\9})\n\n\9\9\9Library:Create(\"UIListLayout\", {\n\9\9\9\9Name = \"Layout\",\n\9\9\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9\9Parent = ContextMenu.Inner,\n\9\9\9})\n\n\9\9\9Library:Create(\"UIPadding\", {\n\9\9\9\9Name = \"Padding\",\n\9\9\9\9PaddingLeft = UDim.new(0, 4),\n\9\9\9\9Parent = ContextMenu.Inner,\n\9\9\9})\n\n\9\9\9local function updateMenuPosition()\n\9\9\9\9ContextMenu.Container.Position = UDim2.fromOffset(\n\9\9\9\9\9(DisplayFrame.AbsolutePosition.X + DisplayFrame.AbsoluteSize.X) + 4,\n\9\9\9\9\9DisplayFrame.AbsolutePosition.Y + 1\n\9\9\9\9)\n\9\9\9end\n\n\9\9\9local function updateMenuSize()\n\9\9\9\9local menuWidth = 60\n\9\9\9\9for i, label in next, ContextMenu.Inner:GetChildren() do\n\9\9\9\9\9if label:IsA(\"TextLabel\") then\n\9\9\9\9\9\9menuWidth = math.max(menuWidth, label.TextBounds.X)\n\9\9\9\9\9end\n\9\9\9\9end\n\n\9\9\9\9ContextMenu.Container.Size =\n\9\9\9\9\9UDim2.fromOffset(menuWidth + 8, ContextMenu.Inner.Layout.AbsoluteContentSize.Y + 4)\n\9\9\9end\n\n\9\9\9DisplayFrame:GetPropertyChangedSignal(\"AbsolutePosition\"):Connect(updateMenuPosition)\n\9\9\9ContextMenu.Inner.Layout:GetPropertyChangedSignal(\"AbsoluteContentSize\"):Connect(updateMenuSize)\n\n\9\9\9task.spawn(updateMenuPosition)\n\9\9\9task.spawn(updateMenuSize)\n\n\9\9\9Library:AddToRegistry(ContextMenu.Inner, {\n\9\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9\9})\n\n\9\9\9function ContextMenu:Show()\n\9\9\9\9self.Container.Visible = true\n\9\9\9end\n\n\9\9\9function ContextMenu:Hide()\n\9\9\9\9self.Container.Visible = false\n\9\9\9end\n\n\9\9\9function ContextMenu:AddOption(Str, Callback)\n\9\9\9\9if type(Callback) ~= \"function\" then\n\9\9\9\9\9Callback = function() end\n\9\9\9\9end\n\n\9\9\9\9local Button = Library:CreateLabel({\n\9\9\9\9\9Size = UDim2.new(1, 0, 0, 15),\n\9\9\9\9\9TextSize = 13,\n\9\9\9\9\9Text = Str,\n\9\9\9\9\9ZIndex = 16,\n\9\9\9\9\9Parent = self.Inner,\n\9\9\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9\9})\n\n\9\9\9\9Button.InputBegan:Connect(function(Input)\n\9\9\9\9\9if Input.UserInputType ~= Enum.UserInputType.MouseButton1 then\n\9\9\9\9\9\9return\n\9\9\9\9\9end\n\9\9\9\9\9Callback()\n\9\9\9\9end)\n\9\9\9end\n\n\9\9\9ContextMenu:AddOption(\"Copy color\", function()\n\9\9\9\9Library.ColorClipboard = ColorPicker.Value\n\9\9\9end)\n\n\9\9\9ContextMenu:AddOption(\"Paste color\", function()\n\9\9\9\9if not Library.ColorClipboard then\n\9\9\9\9\9return Library:Notify(\"You have not copied a color!\", 2)\n\9\9\9\9end\n\9\9\9\9ColorPicker:SetValueRGB(Library.ColorClipboard)\n\9\9\9end)\n\n\9\9\9ContextMenu:AddOption(\"Copy HEX\", function()\n\9\9\9\9pcall(setclipboard, ColorPicker.Value:ToHex())\n\9\9\9\9Library:Notify(\"Copied hex code to clipboard!\", 2)\n\9\9\9end)\n\n\9\9\9ContextMenu:AddOption(\"Copy RGB\", function()\n\9\9\9\9pcall(\n\9\9\9\9\9setclipboard,\n\9\9\9\9\9table.concat({\n\9\9\9\9\9\9math.floor(ColorPicker.Value.R * 255),\n\9\9\9\9\9\9math.floor(ColorPicker.Value.G * 255),\n\9\9\9\9\9\9math.floor(ColorPicker.Value.B * 255),\n\9\9\9\9\9}, \", \")\n\9\9\9\9)\n\9\9\9\9Library:Notify(\"Copied RGB values to clipboard!\", 2)\n\9\9\9end)\n\9\9end\n\n\9\9Library:AddToRegistry(PickerFrameInner, { BackgroundColor3 = \"BackgroundColor\", BorderColor3 = \"OutlineColor\" })\n\9\9Library:AddToRegistry(Highlight, { BackgroundColor3 = \"AccentColor\" })\n\9\9Library:AddToRegistry(SatVibMapInner, { BackgroundColor3 = \"BackgroundColor\", BorderColor3 = \"OutlineColor\" })\n\n\9\9Library:AddToRegistry(HueBoxInner, { BackgroundColor3 = \"MainColor\", BorderColor3 = \"OutlineColor\" })\n\9\9Library:AddToRegistry(RgbBoxBase.Frame, { BackgroundColor3 = \"MainColor\", BorderColor3 = \"OutlineColor\" })\n\9\9Library:AddToRegistry(RgbBox, { TextColor3 = \"FontColor\" })\n\9\9Library:AddToRegistry(HueBox, { TextColor3 = \"FontColor\" })\n\n\9\9local SequenceTable = {}\n\n\9\9for Hue = 0, 1, 0.1 do\n\9\9\9table.insert(SequenceTable, ColorSequenceKeypoint.new(Hue, Color3.fromHSV(Hue, 1, 1)))\n\9\9end\n\n\9\9local HueSelectorGradient = Library:Create(\"UIGradient\", {\n\9\9\9Color = ColorSequence.new(SequenceTable),\n\9\9\9Rotation = 90,\n\9\9\9Parent = HueSelectorInner,\n\9\9})\n\n\9\9HueBox.FocusLost:Connect(function(enter)\n\9\9\9if enter then\n\9\9\9\9local success, result = pcall(Color3.fromHex, HueBox.Text)\n\9\9\9\9if success and typeof(result) == \"Color3\" then\n\9\9\9\9\9ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(result)\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9ColorPicker:Display()\n\9\9end)\n\n\9\9RgbBox.FocusLost:Connect(function(enter)\n\9\9\9if enter then\n\9\9\9\9local r, g, b = RgbBox.Text:match(\"(%d+),%s*(%d+),%s*(%d+)\")\n\9\9\9\9if r and g and b then\n\9\9\9\9\9ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(Color3.fromRGB(r, g, b))\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9ColorPicker:Display()\n\9\9end)\n\n\9\9function ColorPicker:Display()\n\9\9\9ColorPicker.Value = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib)\n\9\9\9SatVibMap.BackgroundColor3 = Color3.fromHSV(ColorPicker.Hue, 1, 1)\n\n\9\9\9Library:Create(DisplayFrame, {\n\9\9\9\9BackgroundColor3 = ColorPicker.Value,\n\9\9\9\9BorderColor3 = Library:GetDarkerColor(ColorPicker.Value),\n\9\9\9})\n\n\9\9\9HueBox.Text = \"#\" .. ColorPicker.Value:ToHex()\n\9\9\9RgbBox.Text = table.concat({\n\9\9\9\9math.floor(ColorPicker.Value.R * 255),\n\9\9\9\9math.floor(ColorPicker.Value.G * 255),\n\9\9\9\9math.floor(ColorPicker.Value.B * 255),\n\9\9\9}, \", \")\n\n\9\9\9Library:SafeCallback(ColorPicker.Callback, ColorPicker.Value)\n\9\9\9if ColorPicker.Changed then\n\9\9\9\9ColorPicker.Changed(ColorPicker.Value)\n\9\9\9end\n\9\9end\n\n\9\9function ColorPicker:OnChanged(Func)\n\9\9\9ColorPicker.Changed = Func\n\9\9\9Func(ColorPicker.Value)\n\9\9end\n\n\9\9function ColorPicker:Show()\n\9\9\9for Frame, Val in next, Library.OpenedFrames do\n\9\9\9\9if Frame.Name == \"Color\" then\n\9\9\9\9\9Frame.Visible = false\n\9\9\9\9\9Library.OpenedFrames[Frame] = nil\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9PickerFrameOuter.Visible = true\n\9\9\9Library.OpenedFrames[PickerFrameOuter] = true\n\9\9end\n\n\9\9function ColorPicker:Hide()\n\9\9\9PickerFrameOuter.Visible = false\n\9\9\9Library.OpenedFrames[PickerFrameOuter] = nil\n\9\9end\n\n\9\9function ColorPicker:SetValue(HSV)\n\9\9\9local Color = Color3.fromHSV(HSV[1], HSV[2], HSV[3])\n\n\9\9\9ColorPicker:SetHSVFromRGB(Color)\n\9\9\9ColorPicker:Display()\n\9\9end\n\n\9\9function ColorPicker:SetValueRGB(Color)\n\9\9\9ColorPicker:SetHSVFromRGB(Color)\n\9\9\9ColorPicker:Display()\n\9\9end\n\n\9\9SatVibMap.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do\n\9\9\9\9\9local MinX = SatVibMap.AbsolutePosition.X\n\9\9\9\9\9local MaxX = MinX + SatVibMap.AbsoluteSize.X\n\9\9\9\9\9local MouseX = math.clamp(Mouse.X, MinX, MaxX)\n\n\9\9\9\9\9local MinY = SatVibMap.AbsolutePosition.Y\n\9\9\9\9\9local MaxY = MinY + SatVibMap.AbsoluteSize.Y\n\9\9\9\9\9local MouseY = math.clamp(Mouse.Y, MinY, MaxY)\n\n\9\9\9\9\9ColorPicker.Sat = (MouseX - MinX) / (MaxX - MinX)\n\9\9\9\9\9ColorPicker.Vib = 1 - ((MouseY - MinY) / (MaxY - MinY))\n\9\9\9\9\9ColorPicker:Display()\n\n\9\9\9\9\9RenderStepped:Wait()\n\9\9\9\9end\n\n\9\9\9\9Library:AttemptSave()\n\9\9\9end\n\9\9end)\n\n\9\9HueSelectorInner.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do\n\9\9\9\9\9local MinY = HueSelectorInner.AbsolutePosition.Y\n\9\9\9\9\9local MaxY = MinY + HueSelectorInner.AbsoluteSize.Y\n\9\9\9\9\9local MouseY = math.clamp(Mouse.Y, MinY, MaxY)\n\n\9\9\9\9\9ColorPicker.Hue = ((MouseY - MinY) / (MaxY - MinY))\n\9\9\9\9\9ColorPicker:Display()\n\n\9\9\9\9\9RenderStepped:Wait()\n\9\9\9\9end\n\n\9\9\9\9Library:AttemptSave()\n\9\9\9end\n\9\9end)\n\n\9\9DisplayFrame.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then\n\9\9\9\9if PickerFrameOuter.Visible then\n\9\9\9\9\9ColorPicker:Hide()\n\9\9\9\9else\n\9\9\9\9\9ContextMenu:Hide()\n\9\9\9\9\9ColorPicker:Show()\n\9\9\9\9end\n\9\9\9elseif Input.UserInputType == Enum.UserInputType.MouseButton2 and not Library:MouseIsOverOpenedFrame() then\n\9\9\9\9ContextMenu:Show()\n\9\9\9\9ColorPicker:Hide()\n\9\9\9end\n\9\9end)\n\n\9\9Library:GiveSignal(InputService.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9local AbsPos, AbsSize = PickerFrameOuter.AbsolutePosition, PickerFrameOuter.AbsoluteSize\n\n\9\9\9\9if\n\9\9\9\9\9Mouse.X < AbsPos.X\n\9\9\9\9\9or Mouse.X > AbsPos.X + AbsSize.X\n\9\9\9\9\9or Mouse.Y < (AbsPos.Y - 20 - 1)\n\9\9\9\9\9or Mouse.Y > AbsPos.Y + AbsSize.Y\n\9\9\9\9then\n\9\9\9\9\9ColorPicker:Hide()\n\9\9\9\9end\n\n\9\9\9\9if not Library:IsMouseOverFrame(ContextMenu.Container) then\n\9\9\9\9\9ContextMenu:Hide()\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton2 and ContextMenu.Container.Visible then\n\9\9\9\9if\n\9\9\9\9\9not Library:IsMouseOverFrame(ContextMenu.Container) and not Library:IsMouseOverFrame(DisplayFrame)\n\9\9\9\9then\n\9\9\9\9\9ContextMenu:Hide()\n\9\9\9\9end\n\9\9\9end\n\9\9end))\n\n\9\9ColorPicker:Display()\n\9\9ColorPicker.DisplayFrame = DisplayFrame\n\n\9\9Options[Idx] = ColorPicker\n\n\9\9return self\n\9end\n\n\9function Funcs:AddKeyPicker(Idx, Info)\n\9\9local ParentObj = self\n\9\9local ToggleLabel = self.TextLabel\n\9\9local Container = self.Container\n\n\9\9local KeyPicker = {\n\9\9\9Value = Info.Default,\n\9\9\9Toggled = false,\n\9\9\9Mode = Info.Mode or \"Toggle\", -- Always, Toggle, Hold\n\9\9\9Type = \"KeyPicker\",\n\9\9\9Callback = Info.Callback or function(Value) end,\n\9\9\9ChangedCallback = Info.ChangedCallback or function(New) end,\n\n\9\9\9SyncToggleState = Info.SyncToggleState or false,\n\9\9}\n\n\9\9if KeyPicker.SyncToggleState then\n\9\9\9Info.Modes = { \"Toggle\" }\n\9\9\9Info.Mode = \"Toggle\"\n\9\9end\n\n\9\9local RelativeOffset = 0\n\n\9\9for _, Element in next, Container:GetChildren() do\n\9\9\9if not Element:IsA(\"UIListLayout\") then\n\9\9\9\9RelativeOffset = RelativeOffset + Element.Size.Y.Offset\n\9\9\9end\n\9\9end\n\n\9\9local PickOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Size = UDim2.new(0, 28, 0, 15),\n\9\9\9ZIndex = 6,\n\9\9\9Parent = ToggleLabel,\n\9\9})\n\n\9\9local PickInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 7,\n\9\9\9Parent = PickOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(PickInner, {\n\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9local DisplayLabel = Library:CreateLabel({\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9TextSize = 13,\n\9\9\9Text = Info.Default,\n\9\9\9TextWrapped = true,\n\9\9\9ZIndex = 8,\n\9\9\9Parent = PickInner,\n\9\9})\n\n\9\9local ModeSelectOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Position = UDim2.new(1, 0, 0, RelativeOffset + 1),\n\9\9\9Size = UDim2.new(0, 60, 0, 45 + 2),\n\9\9\9Visible = false,\n\9\9\9ZIndex = 14,\n\9\9\9Parent = Container.Parent,\n\9\9})\n\n\9\9local ModeSelectInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 15,\n\9\9\9Parent = ModeSelectOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(ModeSelectInner, {\n\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9Library:Create(\"UIListLayout\", {\n\9\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9Parent = ModeSelectInner,\n\9\9})\n\n\9\9local ContainerLabel = Library:CreateLabel({\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9Size = UDim2.new(1, 0, 0, 18),\n\9\9\9TextSize = 13,\n\9\9\9Visible = false,\n\9\9\9ZIndex = 110,\n\9\9\9Parent = Library.KeybindContainer,\n\9\9}, true)\n\n\9\9local Modes = Info.Modes or { \"Always\", \"Toggle\", \"Hold\" }\n\9\9local ModeButtons = {}\n\n\9\9for Idx, Mode in next, Modes do\n\9\9\9local ModeButton = {}\n\n\9\9\9local Label = Library:CreateLabel({\n\9\9\9\9Size = UDim2.new(1, 0, 0, 15),\n\9\9\9\9TextSize = 13,\n\9\9\9\9Text = Mode,\n\9\9\9\9ZIndex = 16,\n\9\9\9\9Parent = ModeSelectInner,\n\9\9\9})\n\n\9\9\9function ModeButton:Select()\n\9\9\9\9for _, Button in next, ModeButtons do\n\9\9\9\9\9Button:Deselect()\n\9\9\9\9end\n\n\9\9\9\9KeyPicker.Mode = Mode\n\n\9\9\9\9Label.TextColor3 = Library.AccentColor\n\9\9\9\9Library.RegistryMap[Label].Properties.TextColor3 = \"AccentColor\"\n\n\9\9\9\9ModeSelectOuter.Visible = false\n\9\9\9end\n\n\9\9\9function ModeButton:Deselect()\n\9\9\9\9KeyPicker.Mode = nil\n\n\9\9\9\9Label.TextColor3 = Library.FontColor\n\9\9\9\9Library.RegistryMap[Label].Properties.TextColor3 = \"FontColor\"\n\9\9\9end\n\n\9\9\9Label.InputBegan:Connect(function(Input)\n\9\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9\9ModeButton:Select()\n\9\9\9\9\9Library:AttemptSave()\n\9\9\9\9end\n\9\9\9end)\n\n\9\9\9if Mode == KeyPicker.Mode then\n\9\9\9\9ModeButton:Select()\n\9\9\9end\n\n\9\9\9ModeButtons[Mode] = ModeButton\n\9\9end\n\n\9\9function KeyPicker:Update()\n\9\9\9if Info.NoUI then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9local State = KeyPicker:GetState()\n\n\9\9\9ContainerLabel.Text = string.format(\"[%s] %s (%s)\", KeyPicker.Value, Info.Text, KeyPicker.Mode)\n\n\9\9\9ContainerLabel.Visible = true\n\9\9\9ContainerLabel.TextColor3 = State and Library.AccentColor or Library.FontColor\n\n\9\9\9Library.RegistryMap[ContainerLabel].Properties.TextColor3 = State and \"AccentColor\" or \"FontColor\"\n\n\9\9\9local YSize = 0\n\9\9\9local XSize = 0\n\n\9\9\9for _, Label in next, Library.KeybindContainer:GetChildren() do\n\9\9\9\9if Label:IsA(\"TextLabel\") and Label.Visible then\n\9\9\9\9\9YSize = YSize + 18\n\9\9\9\9\9if Label.TextBounds.X > XSize then\n\9\9\9\9\9\9XSize = Label.TextBounds.X\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9Library.KeybindFrame.Size = UDim2.new(0, math.max(XSize + 10, 210), 0, YSize + 23)\n\9\9end\n\n\9\9function KeyPicker:GetState()\n\9\9\9if KeyPicker.Mode == \"Always\" then\n\9\9\9\9return true\n\9\9\9elseif KeyPicker.Mode == \"Hold\" then\n\9\9\9\9if KeyPicker.Value == \"None\" then\n\9\9\9\9\9return false\n\9\9\9\9end\n\n\9\9\9\9local Key = KeyPicker.Value\n\n\9\9\9\9if Key == \"MB1\" or Key == \"MB2\" then\n\9\9\9\9\9return Key == \"MB1\" and InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)\n\9\9\9\9\9\9or Key == \"MB2\" and InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)\n\9\9\9\9else\n\9\9\9\9\9return InputService:IsKeyDown(Enum.KeyCode[KeyPicker.Value])\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9return KeyPicker.Toggled\n\9\9\9end\n\9\9end\n\n\9\9function KeyPicker:SetValue(Data)\n\9\9\9local Key, Mode = Data[1], Data[2]\n\9\9\9DisplayLabel.Text = Key\n\9\9\9KeyPicker.Value = Key\n\9\9\9ModeButtons[Mode]:Select()\n\9\9\9KeyPicker:Update()\n\9\9end\n\n\9\9function KeyPicker:OnClick(Callback)\n\9\9\9KeyPicker.Clicked = Callback\n\9\9end\n\n\9\9if ParentObj.Addons then\n\9\9\9table.insert(ParentObj.Addons, KeyPicker)\n\9\9end\n\n\9\9function KeyPicker:DoClick()\n\9\9\9if ParentObj.Type == \"Toggle\" and KeyPicker.SyncToggleState then\n\9\9\9\9ParentObj:SetValue(not ParentObj.Value)\n\9\9\9end\n\n\9\9\9Library:SafeCallback(KeyPicker.Callback, KeyPicker.Toggled)\n\9\9\9if KeyPicker.Clicked then\n\9\9\9\9KeyPicker.Clicked()\n\9\9\9end\n\9\9end\n\n\9\9local Picking = false\n\n\9\9PickOuter.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then\n\9\9\9\9Picking = true\n\n\9\9\9\9DisplayLabel.Text = \"\"\n\n\9\9\9\9local Break\n\9\9\9\9local Text = \"\"\n\n\9\9\9\9task.spawn(function()\n\9\9\9\9\9while not Break do\n\9\9\9\9\9\9if Text == \"...\" then\n\9\9\9\9\9\9\9Text = \"\"\n\9\9\9\9\9\9end\n\n\9\9\9\9\9\9Text = Text .. \".\"\n\9\9\9\9\9\9DisplayLabel.Text = Text\n\n\9\9\9\9\9\9wait(0.4)\n\9\9\9\9\9end\n\9\9\9\9end)\n\n\9\9\9\9wait(0.2)\n\n\9\9\9\9local Event\n\9\9\9\9Event = InputService.InputBegan:Connect(function(Input)\n\9\9\9\9\9local Key\n\n\9\9\9\9\9if Input.UserInputType == Enum.UserInputType.Keyboard then\n\9\9\9\9\9\9Key = Input.KeyCode.Name\n\9\9\9\9\9elseif Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9\9\9Key = \"MB1\"\n\9\9\9\9\9elseif Input.UserInputType == Enum.UserInputType.MouseButton2 then\n\9\9\9\9\9\9Key = \"MB2\"\n\9\9\9\9\9end\n\n\9\9\9\9\9Break = true\n\9\9\9\9\9Picking = false\n\n\9\9\9\9\9Library:SafeCallback(KeyPicker.ChangedCallback, Input.KeyCode or Input.UserInputType)\n\9\9\9\9\9DisplayLabel.Text = Key\n\9\9\9\9\9KeyPicker.Value = Key\n\n\9\9\9\9\9Library:AttemptSave()\n\n\9\9\9\9\9Event:Disconnect()\n\9\9\9\9end)\n\9\9\9elseif Input.UserInputType == Enum.UserInputType.MouseButton2 and not Library:MouseIsOverOpenedFrame() then\n\9\9\9\9ModeSelectOuter.Visible = true\n\9\9\9end\n\9\9end)\n\n\9\9Library:GiveSignal(InputService.InputBegan:Connect(function(Input)\n\9\9\9if not Picking then\n\9\9\9\9if KeyPicker.Mode == \"Toggle\" then\n\9\9\9\9\9local Key = KeyPicker.Value\n\n\9\9\9\9\9if Key == \"MB1\" or Key == \"MB2\" then\n\9\9\9\9\9\9if\n\9\9\9\9\9\9\9Key == \"MB1\" and Input.UserInputType == Enum.UserInputType.MouseButton1\n\9\9\9\9\9\9\9or Key == \"MB2\" and Input.UserInputType == Enum.UserInputType.MouseButton2\n\9\9\9\9\9\9then\n\9\9\9\9\9\9\9KeyPicker.Toggled = not KeyPicker.Toggled\n\9\9\9\9\9\9\9KeyPicker:DoClick()\n\9\9\9\9\9\9end\n\9\9\9\9\9elseif Input.UserInputType == Enum.UserInputType.Keyboard then\n\9\9\9\9\9\9if Input.KeyCode.Name == Key then\n\9\9\9\9\9\9\9KeyPicker.Toggled = not KeyPicker.Toggled\n\9\9\9\9\9\9\9KeyPicker:DoClick()\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\9\9\9\9end\n\n\9\9\9\9KeyPicker:Update()\n\9\9\9end\n\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9local AbsPos, AbsSize = ModeSelectOuter.AbsolutePosition, ModeSelectOuter.AbsoluteSize\n\n\9\9\9\9if\n\9\9\9\9\9Mouse.X < AbsPos.X\n\9\9\9\9\9or Mouse.X > AbsPos.X + AbsSize.X\n\9\9\9\9\9or Mouse.Y < (AbsPos.Y - 20 - 1)\n\9\9\9\9\9or Mouse.Y > AbsPos.Y + AbsSize.Y\n\9\9\9\9then\n\9\9\9\9\9ModeSelectOuter.Visible = false\n\9\9\9\9end\n\9\9\9end\n\9\9end))\n\n\9\9Library:GiveSignal(InputService.InputEnded:Connect(function(Input)\n\9\9\9if not Picking then\n\9\9\9\9KeyPicker:Update()\n\9\9\9end\n\9\9end))\n\n\9\9KeyPicker:Update()\n\n\9\9Options[Idx] = KeyPicker\n\n\9\9return self\n\9end\n\n\9BaseAddons.__index = Funcs\n\9BaseAddons.__namecall = function(Table, Key, ...)\n\9\9return Funcs[Key](...)\n\9end\nend\n\nlocal BaseGroupbox = {}\n\ndo\n\9local Funcs = {}\n\n\9function Funcs:AddBlank(Size)\n\9\9local Groupbox = self\n\9\9local Container = Groupbox.Container\n\n\9\9Library:Create(\"Frame\", {\n\9\9\9BackgroundTransparency = 1,\n\9\9\9Size = UDim2.new(1, 0, 0, Size),\n\9\9\9ZIndex = 1,\n\9\9\9Parent = Container,\n\9\9})\n\9end\n\n\9function Funcs:AddLabel(Text, DoesWrap)\n\9\9local Label = {}\n\n\9\9local Groupbox = self\n\9\9local Container = Groupbox.Container\n\n\9\9local TextLabel = Library:CreateLabel({\n\9\9\9Size = UDim2.new(1, -4, 0, 15),\n\9\9\9TextSize = 14,\n\9\9\9Text = Text,\n\9\9\9TextWrapped = DoesWrap or false,\n\9\9\9RichText = true,\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9ZIndex = 5,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9if DoesWrap then\n\9\9\9local Y = select(\n\9\9\9\0092,\n\9\9\9\9Library:GetTextBounds(Text, Library.Font, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge))\n\9\9\9)\n\9\9\9TextLabel.Size = UDim2.new(1, -4, 0, Y)\n\9\9else\n\9\9\9Library:Create(\"UIListLayout\", {\n\9\9\9\9Padding = UDim.new(0, 4),\n\9\9\9\9FillDirection = Enum.FillDirection.Horizontal,\n\9\9\9\9HorizontalAlignment = Enum.HorizontalAlignment.Right,\n\9\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9\9Parent = TextLabel,\n\9\9\9})\n\9\9end\n\n\9\9Label.TextLabel = TextLabel\n\9\9Label.Container = Container\n\n\9\9function Label:SetText(Text)\n\9\9\9TextLabel.Text = Text\n\n\9\9\9if DoesWrap then\n\9\9\9\9local Y = select(\n\9\9\9\9\0092,\n\9\9\9\9\9Library:GetTextBounds(Text, Library.Font, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge))\n\9\9\9\9)\n\9\9\9\9TextLabel.Size = UDim2.new(1, -4, 0, Y)\n\9\9\9end\n\n\9\9\9Groupbox:Resize()\n\9\9end\n\n\9\9if not DoesWrap then\n\9\9\9setmetatable(Label, BaseAddons)\n\9\9end\n\n\9\9Groupbox:AddBlank(5)\n\9\9Groupbox:Resize()\n\n\9\9return Label\n\9end\n\n\9function Funcs:AddButton(...)\n\9\9-- TODO: Eventually redo this\n\9\9local Button = {}\n\9\9local function ProcessButtonParams(Class, Obj, ...)\n\9\9\9local Props = select(1, ...)\n\9\9\9if type(Props) == \"table\" then\n\9\9\9\9Obj.Text = Props.Text\n\9\9\9\9Obj.Func = Props.Func\n\9\9\9\9Obj.DoubleClick = Props.DoubleClick\n\9\9\9\9Obj.Tooltip = Props.Tooltip\n\9\9\9else\n\9\9\9\9Obj.Text = select(1, ...)\n\9\9\9\9Obj.Func = select(2, ...)\n\9\9\9end\n\n\9\9\9if type(Obj.Func) ~= \"function\" then\n\9\9\9\9return error(Class .. \" must have a callback!\")\n\9\9\9end\n\9\9end\n\n\9\9ProcessButtonParams(\"Button\", Button, ...)\n\n\9\9local Groupbox = self\n\9\9local Container = Groupbox.Container\n\n\9\9local function CreateBaseButton(Button)\n\9\9\9local Outer = Library:Create(\"Frame\", {\n\9\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9\9Size = UDim2.new(1, -4, 0, 20),\n\9\9\9\9ZIndex = 5,\n\9\9\9})\n\n\9\9\9local Inner = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9\9ZIndex = 6,\n\9\9\9\9Parent = Outer,\n\9\9\9})\n\n\9\9\9local Label = Library:CreateLabel({\n\9\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9\9TextSize = 14,\n\9\9\9\9Text = Button.Text,\n\9\9\9\9ZIndex = 6,\n\9\9\9\9Parent = Inner,\n\9\9\9})\n\n\9\9\9Library:Create(\"UIGradient\", {\n\9\9\9\9Color = ColorSequence.new({\n\9\9\9\9\9ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),\n\9\9\9\9\9ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212)),\n\9\9\9\9}),\n\9\9\9\9Rotation = 90,\n\9\9\9\9Parent = Inner,\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(Outer, {\n\9\9\9\9BorderColor3 = \"Black\",\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(Inner, {\n\9\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9\9})\n\n\9\9\9Library:OnHighlight(Outer, Outer, { BorderColor3 = \"AccentColor\" }, { BorderColor3 = \"Black\" })\n\n\9\9\9return Outer, Inner, Label\n\9\9end\n\n\9\9local function InitEvents(Button)\n\9\9\9local function WaitForEvent(event, timeout, validator)\n\9\9\9\9local bindable = Instance.new(\"BindableEvent\")\n\9\9\9\9local connection = event:Once(function(...)\n\9\9\9\9\9if type(validator) == \"function\" and validator(...) then\n\9\9\9\9\9\9bindable:Fire(true)\n\9\9\9\9\9else\n\9\9\9\9\9\9bindable:Fire(false)\n\9\9\9\9\9end\n\9\9\9\9end)\n\9\9\9\9task.delay(timeout, function()\n\9\9\9\9\9connection:disconnect()\n\9\9\9\9\9bindable:Fire(false)\n\9\9\9\9end)\n\9\9\9\9return bindable.Event:Wait()\n\9\9\9end\n\n\9\9\9local function ValidateClick(Input)\n\9\9\9\9if Library:MouseIsOverOpenedFrame() then\n\9\9\9\9\9return false\n\9\9\9\9end\n\n\9\9\9\9if Input.UserInputType ~= Enum.UserInputType.MouseButton1 then\n\9\9\9\9\9return false\n\9\9\9\9end\n\n\9\9\9\9return true\n\9\9\9end\n\n\9\9\9Button.Outer.InputBegan:Connect(function(Input)\n\9\9\9\9if not ValidateClick(Input) then\n\9\9\9\9\9return\n\9\9\9\9end\n\9\9\9\9if Button.Locked then\n\9\9\9\9\9return\n\9\9\9\9end\n\n\9\9\9\9if Button.DoubleClick then\n\9\9\9\9\9Library:RemoveFromRegistry(Button.Label)\n\9\9\9\9\9Library:AddToRegistry(Button.Label, { TextColor3 = \"AccentColor\" })\n\n\9\9\9\9\9Button.Label.TextColor3 = Library.AccentColor\n\9\9\9\9\9Button.Label.Text = \"Are you sure?\"\n\9\9\9\9\9Button.Locked = true\n\n\9\9\9\9\9local clicked = WaitForEvent(Button.Outer.InputBegan, 0.5, ValidateClick)\n\n\9\9\9\9\9Library:RemoveFromRegistry(Button.Label)\n\9\9\9\9\9Library:AddToRegistry(Button.Label, { TextColor3 = \"FontColor\" })\n\n\9\9\9\9\9Button.Label.TextColor3 = Library.FontColor\n\9\9\9\9\9Button.Label.Text = Button.Text\n\9\9\9\9\9task.defer(rawset, Button, \"Locked\", false)\n\n\9\9\9\9\9if clicked then\n\9\9\9\9\9\9Library:SafeCallback(Button.Func)\n\9\9\9\9\9end\n\n\9\9\9\9\9return\n\9\9\9\9end\n\n\9\9\9\9Library:SafeCallback(Button.Func)\n\9\9\9end)\n\9\9end\n\n\9\9Button.Outer, Button.Inner, Button.Label = CreateBaseButton(Button)\n\9\9Button.Outer.Parent = Container\n\n\9\9InitEvents(Button)\n\n\9\9function Button:AddTooltip(tooltip)\n\9\9\9if type(tooltip) == \"string\" then\n\9\9\9\9Library:AddToolTip(tooltip, self.Outer)\n\9\9\9end\n\9\9\9return self\n\9\9end\n\n\9\9function Button:AddButton(...)\n\9\9\9local SubButton = {}\n\n\9\9\9ProcessButtonParams(\"SubButton\", SubButton, ...)\n\n\9\9\9self.Outer.Size = UDim2.new(0.5, -2, 0, 20)\n\n\9\9\9SubButton.Outer, SubButton.Inner, SubButton.Label = CreateBaseButton(SubButton)\n\n\9\9\9SubButton.Outer.Position = UDim2.new(1, 3, 0, 0)\n\9\9\9SubButton.Outer.Size = UDim2.fromOffset(self.Outer.AbsoluteSize.X - 2, self.Outer.AbsoluteSize.Y)\n\9\9\9SubButton.Outer.Parent = self.Outer\n\n\9\9\9function SubButton:AddTooltip(tooltip)\n\9\9\9\9if type(tooltip) == \"string\" then\n\9\9\9\9\9Library:AddToolTip(tooltip, self.Outer)\n\9\9\9\9end\n\9\9\9\9return SubButton\n\9\9\9end\n\n\9\9\9if type(SubButton.Tooltip) == \"string\" then\n\9\9\9\9SubButton:AddTooltip(SubButton.Tooltip)\n\9\9\9end\n\n\9\9\9InitEvents(SubButton)\n\9\9\9return SubButton\n\9\9end\n\n\9\9if type(Button.Tooltip) == \"string\" then\n\9\9\9Button:AddTooltip(Button.Tooltip)\n\9\9end\n\n\9\9Groupbox:AddBlank(5)\n\9\9Groupbox:Resize()\n\n\9\9return Button\n\9end\n\n\9function Funcs:AddDivider()\n\9\9local Groupbox = self\n\9\9local Container = self.Container\n\n\9\9local Divider = {\n\9\9\9Type = \"Divider\",\n\9\9}\n\n\9\9Groupbox:AddBlank(2)\n\9\9local DividerOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Size = UDim2.new(1, -4, 0, 5),\n\9\9\9ZIndex = 5,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9local DividerInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 6,\n\9\9\9Parent = DividerOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(DividerOuter, {\n\9\9\9BorderColor3 = \"Black\",\n\9\9})\n\n\9\9Library:AddToRegistry(DividerInner, {\n\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9Groupbox:AddBlank(9)\n\9\9Groupbox:Resize()\n\9end\n\n\9function Funcs:AddInput(Idx, Info)\n\9\9local Textbox = {\n\9\9\9Value = Info.Default or \"\",\n\9\9\9Numeric = Info.Numeric or false,\n\9\9\9Finished = Info.Finished or false,\n\9\9\9Type = \"Input\",\n\9\9\9Callback = Info.Callback or function(Value) end,\n\9\9}\n\n\9\9local Groupbox = self\n\9\9local Container = Groupbox.Container\n\n\9\9local InputLabel = Library:CreateLabel({\n\9\9\9Size = UDim2.new(1, 0, 0, 15),\n\9\9\9TextSize = 14,\n\9\9\9Text = Info.Text,\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9ZIndex = 5,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9Groupbox:AddBlank(1)\n\n\9\9local TextBoxOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Size = UDim2.new(1, -4, 0, 20),\n\9\9\9ZIndex = 5,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9local TextBoxInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 6,\n\9\9\9Parent = TextBoxOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(TextBoxInner, {\n\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9Library:OnHighlight(TextBoxOuter, TextBoxOuter, { BorderColor3 = \"AccentColor\" }, { BorderColor3 = \"Black\" })\n\n\9\9if type(Info.Tooltip) == \"string\" then\n\9\9\9Library:AddToolTip(Info.Tooltip, TextBoxOuter)\n\9\9end\n\n\9\9Library:Create(\"UIGradient\", {\n\9\9\9Color = ColorSequence.new({\n\9\9\9\9ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),\n\9\9\9\9ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212)),\n\9\9\9}),\n\9\9\9Rotation = 90,\n\9\9\9Parent = TextBoxInner,\n\9\9})\n\n\9\9local Container = Library:Create(\"Frame\", {\n\9\9\9BackgroundTransparency = 1,\n\9\9\9ClipsDescendants = true,\n\n\9\9\9Position = UDim2.new(0, 5, 0, 0),\n\9\9\9Size = UDim2.new(1, -5, 1, 0),\n\n\9\9\9ZIndex = 7,\n\9\9\9Parent = TextBoxInner,\n\9\9})\n\n\9\9local Box = Library:Create(\"TextBox\", {\n\9\9\9BackgroundTransparency = 1,\n\n\9\9\9Position = UDim2.fromOffset(0, 0),\n\9\9\9Size = UDim2.fromScale(5, 1),\n\n\9\9\9FontFace = Library.Font,\n\9\9\9PlaceholderColor3 = Color3.fromRGB(190, 190, 190),\n\9\9\9PlaceholderText = Info.Placeholder or \"\",\n\n\9\9\9Text = Info.Default or \"\",\n\9\9\9TextColor3 = Library.FontColor,\n\9\9\9TextSize = 14,\n\9\9\9TextStrokeTransparency = 0,\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\n\9\9\9ZIndex = 7,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9function Textbox:SetValue(Text)\n\9\9\9if Info.MaxLength and #Text > Info.MaxLength then\n\9\9\9\9Text = Text:sub(1, Info.MaxLength)\n\9\9\9end\n\n\9\9\9if Textbox.Numeric then\n\9\9\9\9if (not tonumber(Text)) and Text:len() > 0 then\n\9\9\9\9\9Text = Textbox.Value\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9Textbox.Value = Text\n\9\9\9Box.Text = Text\n\n\9\9\9Library:SafeCallback(Textbox.Callback, Textbox.Value)\n\9\9\9if Textbox.Changed then\n\9\9\9\9Textbox.Changed(Textbox.Value)\n\9\9\9end\n\9\9end\n\n\9\9if Textbox.Finished then\n\9\9\9Box.FocusLost:Connect(function(enter)\n\9\9\9\9if not enter then\n\9\9\9\9\9return\n\9\9\9\9end\n\n\9\9\9\9Textbox:SetValue(Box.Text)\n\9\9\9\9Library:AttemptSave()\n\9\9\9end)\n\9\9else\n\9\9\9Box:GetPropertyChangedSignal(\"Text\"):Connect(function()\n\9\9\9\9Textbox:SetValue(Box.Text)\n\9\9\9\9Library:AttemptSave()\n\9\9\9end)\n\9\9end\n\n\9\9-- https://devforum.roblox.com/t/how-to-make-textboxes-follow-current-cursor-position/1368429/6\n\9\9-- thank you nicemike40 :)\n\n\9\9local function Update()\n\9\9\9local PADDING = 2\n\9\9\9local reveal = Container.AbsoluteSize.X\n\n\9\9\9if not Box:IsFocused() or Box.TextBounds.X <= reveal - 2 * PADDING then\n\9\9\9\9-- we aren't focused, or we fit so be normal\n\9\9\9\9Box.Position = UDim2.new(0, PADDING, 0, 0)\n\9\9\9else\n\9\9\9\9-- we are focused and don't fit, so adjust position\n\9\9\9\9local cursor = Box.CursorPosition\n\9\9\9\9if cursor ~= -1 then\n\9\9\9\9\9-- calculate pixel width of text from start to cursor\n\9\9\9\9\9local subtext = string.sub(Box.Text, 1, cursor - 1)\n\9\9\9\9\9local width =\n\9\9\9\9\9\9TextService:GetTextSize(subtext, Box.TextSize, Box.Font, Vector2.new(math.huge, math.huge)).X\n\n\9\9\9\9\9-- check if we're inside the box with the cursor\n\9\9\9\9\9local currentCursorPos = Box.Position.X.Offset + width\n\n\9\9\9\9\9-- adjust if necessary\n\9\9\9\9\9if currentCursorPos < PADDING then\n\9\9\9\9\9\9Box.Position = UDim2.fromOffset(PADDING - width, 0)\n\9\9\9\9\9elseif currentCursorPos > reveal - PADDING - 1 then\n\9\9\9\9\9\9Box.Position = UDim2.fromOffset(reveal - width - PADDING - 1, 0)\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9task.spawn(Update)\n\n\9\9Box:GetPropertyChangedSignal(\"Text\"):Connect(Update)\n\9\9Box:GetPropertyChangedSignal(\"CursorPosition\"):Connect(Update)\n\9\9Box.FocusLost:Connect(Update)\n\9\9Box.Focused:Connect(Update)\n\n\9\9Library:AddToRegistry(Box, {\n\9\9\9TextColor3 = \"FontColor\",\n\9\9})\n\n\9\9function Textbox:OnChanged(Func)\n\9\9\9Textbox.Changed = Func\n\9\9\9Func(Textbox.Value)\n\9\9end\n\n\9\9Groupbox:AddBlank(5)\n\9\9Groupbox:Resize()\n\n\9\9Options[Idx] = Textbox\n\n\9\9return Textbox\n\9end\n\n\9function Funcs:AddToggle(Idx, Info)\n\9\9local Toggle = {\n\9\9\9Value = Info.Default or false,\n\9\9\9Type = \"Toggle\",\n\n\9\9\9Callback = Info.Callback or function(Value) end,\n\9\9\9Addons = {},\n\9\9\9Risky = Info.Risky,\n\9\9}\n\n\9\9local Groupbox = self\n\9\9local Container = Groupbox.Container\n\n\9\9local ToggleOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Size = UDim2.new(0, 13, 0, 13),\n\9\9\9ZIndex = 5,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9Library:AddToRegistry(ToggleOuter, {\n\9\9\9BorderColor3 = \"Black\",\n\9\9})\n\n\9\9local ToggleInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 6,\n\9\9\9Parent = ToggleOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(ToggleInner, {\n\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9local ToggleLabel = Library:CreateLabel({\n\9\9\9Size = UDim2.new(0, 216, 1, 0),\n\9\9\9Position = UDim2.new(1, 6, 0, 0),\n\9\9\9TextSize = 14,\n\9\9\9Text = Info.Text,\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9ZIndex = 6,\n\9\9\9Parent = ToggleInner,\n\9\9})\n\n\9\9Library:Create(\"UIListLayout\", {\n\9\9\9Padding = UDim.new(0, 4),\n\9\9\9FillDirection = Enum.FillDirection.Horizontal,\n\9\9\9HorizontalAlignment = Enum.HorizontalAlignment.Right,\n\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9Parent = ToggleLabel,\n\9\9})\n\n\9\9local ToggleRegion = Library:Create(\"Frame\", {\n\9\9\9BackgroundTransparency = 1,\n\9\9\9Size = UDim2.new(0, 170, 1, 0),\n\9\9\9ZIndex = 8,\n\9\9\9Parent = ToggleOuter,\n\9\9})\n\n\9\9Library:OnHighlight(ToggleRegion, ToggleOuter, { BorderColor3 = \"AccentColor\" }, { BorderColor3 = \"Black\" })\n\n\9\9function Toggle:UpdateColors()\n\9\9\9Toggle:Display()\n\9\9end\n\n\9\9if type(Info.Tooltip) == \"string\" then\n\9\9\9Library:AddToolTip(Info.Tooltip, ToggleRegion)\n\9\9end\n\n\9\9function Toggle:Display()\n\9\9\9ToggleInner.BackgroundColor3 = Toggle.Value and Library.AccentColor or Library.MainColor\n\9\9\9ToggleInner.BorderColor3 = Toggle.Value and Library.AccentColorDark or Library.OutlineColor\n\n\9\9\9Library.RegistryMap[ToggleInner].Properties.BackgroundColor3 = Toggle.Value and \"AccentColor\" or \"MainColor\"\n\9\9\9Library.RegistryMap[ToggleInner].Properties.BorderColor3 = Toggle.Value and \"AccentColorDark\"\n\9\9\9\9or \"OutlineColor\"\n\9\9end\n\n\9\9function Toggle:OnChanged(Func)\n\9\9\9Toggle.Changed = Func\n\9\9\9Func(Toggle.Value)\n\9\9end\n\n\9\9function Toggle:SetValue(Bool)\n\9\9\9Bool = not not Bool\n\n\9\9\9Toggle.Value = Bool\n\9\9\9Toggle:Display()\n\n\9\9\9for _, Addon in next, Toggle.Addons do\n\9\9\9\9if Addon.Type == \"KeyPicker\" and Addon.SyncToggleState then\n\9\9\9\9\9Addon.Toggled = Bool\n\9\9\9\9\9Addon:Update()\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9Library:SafeCallback(Toggle.Callback, Toggle.Value)\n\9\9\9if Toggle.Changed then\n\9\9\9\9Toggle.Changed(Toggle.Value)\n\9\9\9end\n\9\9end\n\n\9\9ToggleRegion.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then\n\9\9\9\9Toggle:SetValue(not Toggle.Value) -- Why was it not like this from the start?\n\9\9\9\9Library:AttemptSave()\n\9\9\9end\n\9\9end)\n\n\9\9if Toggle.Risky then\n\9\9\9Library:RemoveFromRegistry(ToggleLabel)\n\9\9\9ToggleLabel.TextColor3 = Library.RiskColor\n\9\9\9Library:AddToRegistry(ToggleLabel, { TextColor3 = \"RiskColor\" })\n\9\9end\n\n\9\9Toggle:Display()\n\9\9Groupbox:AddBlank(Info.BlankSize or 5 + 2)\n\9\9Groupbox:Resize()\n\n\9\9Toggle.TextLabel = ToggleLabel\n\9\9Toggle.Container = Container\n\9\9setmetatable(Toggle, BaseAddons)\n\n\9\9Toggles[Idx] = Toggle\n\n\9\9return Toggle\n\9end\n\n\9function Funcs:AddSlider(Idx, Info)\n\9\9assert(Info.Default and Info.Text and Info.Min and Info.Max and Info.Rounding, \"Bad Slider Data\")\n\n\9\9local Slider = {\n\9\9\9Value = Info.Default,\n\9\9\9Min = Info.Min,\n\9\9\9Max = Info.Max,\n\9\9\9Rounding = Info.Rounding,\n\9\9\9MaxSize = 232,\n\9\9\9Type = \"Slider\",\n\9\9\9Callback = Info.Callback or function(Value) end,\n\9\9}\n\n\9\9local Groupbox = self\n\9\9local Container = Groupbox.Container\n\n\9\9if not Info.Compact then\n\9\9\9Library:CreateLabel({\n\9\9\9\9Size = UDim2.new(1, 0, 0, 10),\n\9\9\9\9TextSize = 14,\n\9\9\9\9Text = Info.Text,\n\9\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9\9TextYAlignment = Enum.TextYAlignment.Bottom,\n\9\9\9\9ZIndex = 5,\n\9\9\9\9Parent = Container,\n\9\9\9})\n\n\9\9\9Groupbox:AddBlank(3)\n\9\9end\n\n\9\9local SliderOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Size = UDim2.new(1, -4, 0, 13),\n\9\9\9ZIndex = 5,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9Library:AddToRegistry(SliderOuter, {\n\9\9\9BorderColor3 = \"Black\",\n\9\9})\n\n\9\9local SliderInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 6,\n\9\9\9Parent = SliderOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(SliderInner, {\n\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9local Fill = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.AccentColor,\n\9\9\9BorderColor3 = Library.AccentColorDark,\n\9\9\9Size = UDim2.new(0, 0, 1, 0),\n\9\9\9ZIndex = 7,\n\9\9\9Parent = SliderInner,\n\9\9})\n\n\9\9Library:AddToRegistry(Fill, {\n\9\9\9BackgroundColor3 = \"AccentColor\",\n\9\9\9BorderColor3 = \"AccentColorDark\",\n\9\9})\n\n\9\9local HideBorderRight = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.AccentColor,\n\9\9\9BorderSizePixel = 0,\n\9\9\9Position = UDim2.new(1, 0, 0, 0),\n\9\9\9Size = UDim2.new(0, 1, 1, 0),\n\9\9\9ZIndex = 8,\n\9\9\9Parent = Fill,\n\9\9})\n\n\9\9Library:AddToRegistry(HideBorderRight, {\n\9\9\9BackgroundColor3 = \"AccentColor\",\n\9\9})\n\n\9\9local DisplayLabel = Library:CreateLabel({\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9TextSize = 14,\n\9\9\9Text = \"Infinite\",\n\9\9\9ZIndex = 9,\n\9\9\9Parent = SliderInner,\n\9\9})\n\n\9\9Library:OnHighlight(SliderOuter, SliderOuter, { BorderColor3 = \"AccentColor\" }, { BorderColor3 = \"Black\" })\n\n\9\9if type(Info.Tooltip) == \"string\" then\n\9\9\9Library:AddToolTip(Info.Tooltip, SliderOuter)\n\9\9end\n\n\9\9function Slider:UpdateColors()\n\9\9\9Fill.BackgroundColor3 = Library.AccentColor\n\9\9\9Fill.BorderColor3 = Library.AccentColorDark\n\9\9end\n\n\9\9function Slider:Display()\n\9\9\9local Suffix = Info.Suffix or \"\"\n\n\9\9\9if Info.Compact then\n\9\9\9\9DisplayLabel.Text = Info.Text .. \": \" .. Slider.Value .. Suffix\n\9\9\9elseif Info.HideMax then\n\9\9\9\9DisplayLabel.Text = string.format(\"%s\", Slider.Value .. Suffix)\n\9\9\9else\n\9\9\9\9DisplayLabel.Text = string.format(\"%s/%s\", Slider.Value .. Suffix, Slider.Max .. Suffix)\n\9\9\9end\n\n\9\9\9local X = math.ceil(Library:MapValue(Slider.Value, Slider.Min, Slider.Max, 0, Slider.MaxSize))\n\9\9\9Fill.Size = UDim2.new(0, X, 1, 0)\n\n\9\9\9HideBorderRight.Visible = not (X == Slider.MaxSize or X == 0)\n\9\9end\n\n\9\9function Slider:OnChanged(Func)\n\9\9\9Slider.Changed = Func\n\9\9\9Func(Slider.Value)\n\9\9end\n\n\9\9local function Round(Value)\n\9\9\9if Slider.Rounding == 0 then\n\9\9\9\9return math.floor(Value)\n\9\9\9end\n\n\9\9\9return tonumber(string.format(\"%.\" .. Slider.Rounding .. \"f\", Value))\n\9\9end\n\n\9\9function Slider:GetValueFromXOffset(X)\n\9\9\9return Round(Library:MapValue(X, 0, Slider.MaxSize, Slider.Min, Slider.Max))\n\9\9end\n\n\9\9function Slider:SetValue(Str)\n\9\9\9local Num = tonumber(Str)\n\n\9\9\9if not Num then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9Num = math.clamp(Num, Slider.Min, Slider.Max)\n\n\9\9\9Slider.Value = Num\n\9\9\9Slider:Display()\n\n\9\9\9Library:SafeCallback(Slider.Callback, Slider.Value)\n\9\9\9if Slider.Changed then\n\9\9\9\9Slider.Changed(Slider.Value)\n\9\9\9end\n\9\9end\n\n\9\9SliderInner.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then\n\9\9\9\9local mPos = Mouse.X\n\9\9\9\9local gPos = Fill.Size.X.Offset\n\9\9\9\9local Diff = mPos - (Fill.AbsolutePosition.X + gPos)\n\n\9\9\9\9while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do\n\9\9\9\9\9local nMPos = Mouse.X\n\9\9\9\9\9local nX = math.clamp(gPos + (nMPos - mPos) + Diff, 0, Slider.MaxSize)\n\n\9\9\9\9\9local nValue = Slider:GetValueFromXOffset(nX)\n\9\9\9\9\9local OldValue = Slider.Value\n\9\9\9\9\9Slider.Value = nValue\n\n\9\9\9\9\9Slider:Display()\n\n\9\9\9\9\9if nValue ~= OldValue then\n\9\9\9\9\9\9Library:SafeCallback(Slider.Callback, Slider.Value)\n\9\9\9\9\9\9if Slider.Changed then\n\9\9\9\9\9\9\9Slider.Changed(Slider.Value)\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\n\9\9\9\9\9RenderStepped:Wait()\n\9\9\9\9end\n\n\9\9\9\9Library:AttemptSave()\n\9\9\9end\n\9\9end)\n\n\9\9Slider:Display()\n\9\9Groupbox:AddBlank(Info.BlankSize or 6)\n\9\9Groupbox:Resize()\n\n\9\9Options[Idx] = Slider\n\n\9\9return Slider\n\9end\n\n\9function Funcs:AddDropdown(Idx, Info)\n\9\9if Info.SpecialType == \"Player\" then\n\9\9\9Info.Values = GetPlayersString()\n\9\9elseif Info.SpecialType == \"Team\" then\n\9\9\9Info.Values = GetTeamsString()\n\9\9end\n\n\9\9assert(Info.Text and Info.Values, \"Bad Dropdown Data\")\n\n\9\9local Dropdown = {\n\9\9\9Values = Info.Values,\n\9\9\9Value = Info.Multi and {},\n\9\9\9Multi = Info.Multi,\n\9\9\9Type = \"Dropdown\",\n\9\9\9SpecialType = Info.SpecialType, -- can be either 'Player' or 'Team'\n\9\9\9Callback = Info.Callback or function(Value) end,\n\9\9}\n\n\9\9local Groupbox = self\n\9\9local Container = Groupbox.Container\n\n\9\9local RelativeOffset = 0\n\n\9\9if not Info.Compact then\n\9\9\9local DropdownLabel = Library:CreateLabel({\n\9\9\9\9Size = UDim2.new(1, 0, 0, 10),\n\9\9\9\9TextSize = 14,\n\9\9\9\9Text = Info.Text,\n\9\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9\9TextYAlignment = Enum.TextYAlignment.Bottom,\n\9\9\9\9ZIndex = 5,\n\9\9\9\9Parent = Container,\n\9\9\9})\n\n\9\9\9Groupbox:AddBlank(3)\n\9\9end\n\n\9\9for _, Element in next, Container:GetChildren() do\n\9\9\9if not Element:IsA(\"UIListLayout\") then\n\9\9\9\9RelativeOffset = RelativeOffset + Element.Size.Y.Offset\n\9\9\9end\n\9\9end\n\n\9\9local DropdownOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Size = UDim2.new(1, -4, 0, 20),\n\9\9\9ZIndex = 5,\n\9\9\9Parent = Container,\n\9\9})\n\n\9\9Library:AddToRegistry(DropdownOuter, {\n\9\9\9BorderColor3 = \"Black\",\n\9\9})\n\n\9\9local DropdownInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 6,\n\9\9\9Parent = DropdownOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(DropdownInner, {\n\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9Library:Create(\"UIGradient\", {\n\9\9\9Color = ColorSequence.new({\n\9\9\9\9ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),\n\9\9\9\9ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212)),\n\9\9\9}),\n\9\9\9Rotation = 90,\n\9\9\9Parent = DropdownInner,\n\9\9})\n\n\9\9local DropdownArrow = Library:Create(\"ImageLabel\", {\n\9\9\9AnchorPoint = Vector2.new(0, 0.5),\n\9\9\9BackgroundTransparency = 1,\n\9\9\9Position = UDim2.new(1, -16, 0.5, 0),\n\9\9\9Size = UDim2.new(0, 12, 0, 12),\n\9\9\9Image = \"http://www.roblox.com/asset/?id=6282522798\",\n\9\9\9ZIndex = 8,\n\9\9\9Parent = DropdownInner,\n\9\9})\n\n\9\9local ItemList = Library:CreateLabel({\n\9\9\9Position = UDim2.new(0, 5, 0, 0),\n\9\9\9Size = UDim2.new(1, -5, 1, 0),\n\9\9\9TextSize = 14,\n\9\9\9Text = \"--\",\n\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9TextWrapped = true,\n\9\9\9ZIndex = 7,\n\9\9\9Parent = DropdownInner,\n\9\9})\n\n\9\9Library:OnHighlight(DropdownOuter, DropdownOuter, { BorderColor3 = \"AccentColor\" }, { BorderColor3 = \"Black\" })\n\n\9\9if type(Info.Tooltip) == \"string\" then\n\9\9\9Library:AddToolTip(Info.Tooltip, DropdownOuter)\n\9\9end\n\n\9\9local MAX_DROPDOWN_ITEMS = 8\n\n\9\9local ListOuter = Library:Create(\"Frame\", {\n\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9Position = UDim2.new(0, 4, 0, 20 + RelativeOffset + 1 + 20),\n\9\9\9Size = UDim2.new(1, -8, 0, MAX_DROPDOWN_ITEMS * 20 + 2),\n\9\9\9ZIndex = 20,\n\9\9\9Visible = false,\n\9\9\9Parent = Container.Parent,\n\9\9})\n\n\9\9local ListInner = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9BorderSizePixel = 0,\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 21,\n\9\9\9Parent = ListOuter,\n\9\9})\n\n\9\9Library:AddToRegistry(ListInner, {\n\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9local Scrolling = Library:Create(\"ScrollingFrame\", {\n\9\9\9BackgroundTransparency = 1,\n\9\9\9CanvasSize = UDim2.new(0, 0, 0, 0),\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9ZIndex = 21,\n\9\9\9Parent = ListInner,\n\n\9\9\9TopImage = \"rbxasset://textures/ui/Scroll/scroll-middle.png\",\n\9\9\9BottomImage = \"rbxasset://textures/ui/Scroll/scroll-middle.png\",\n\n\9\9\9ScrollBarThickness = 3,\n\9\9\9ScrollBarImageColor3 = Library.AccentColor,\n\9\9})\n\n\9\9Library:AddToRegistry(Scrolling, {\n\9\9\9ScrollBarImageColor3 = \"AccentColor\",\n\9\9})\n\n\9\9Library:Create(\"UIListLayout\", {\n\9\9\9Padding = UDim.new(0, 0),\n\9\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9Parent = Scrolling,\n\9\9})\n\n\9\9function Dropdown:Display()\n\9\9\9local Values = Dropdown.Values\n\9\9\9local Str = \"\"\n\n\9\9\9if Info.Multi then\n\9\9\9\9for Idx, Value in next, Values do\n\9\9\9\9\9if Dropdown.Value[Value] then\n\9\9\9\9\9\9Str = Str .. Value .. \", \"\n\9\9\9\9\9end\n\9\9\9\9end\n\n\9\9\9\9Str = Str:sub(1, #Str - 2)\n\9\9\9else\n\9\9\9\9Str = Dropdown.Value or \"\"\n\9\9\9end\n\n\9\9\9ItemList.Text = (Str == \"\" and \"--\" or Str)\n\9\9end\n\n\9\9function Dropdown:GetActiveValues()\n\9\9\9if Info.Multi then\n\9\9\9\9local T = {}\n\n\9\9\9\9for Value, Bool in next, Dropdown.Value do\n\9\9\9\9\9table.insert(T, Value)\n\9\9\9\9end\n\n\9\9\9\9return T\n\9\9\9else\n\9\9\9\9return Dropdown.Value and 1 or 0\n\9\9\9end\n\9\9end\n\n\9\9function Dropdown:SetValues()\n\9\9\9local Values = Dropdown.Values\n\9\9\9local Buttons = {}\n\n\9\9\9for _, Element in next, Scrolling:GetChildren() do\n\9\9\9\9if not Element:IsA(\"UIListLayout\") then\n\9\9\9\9\9-- Library:RemoveFromRegistry(Element);\n\9\9\9\9\9Element:Destroy()\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9local Count = 0\n\n\9\9\9for Idx, Value in next, Values do\n\9\9\9\9local Table = {}\n\n\9\9\9\9Count = Count + 1\n\n\9\9\9\9local Button = Library:Create(\"Frame\", {\n\9\9\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9\9\9BorderMode = Enum.BorderMode.Middle,\n\9\9\9\9\9Size = UDim2.new(1, -1, 0, 20),\n\9\9\9\9\9ZIndex = 23,\n\9\9\9\9\9Active = true,\n\9\9\9\9\9Parent = Scrolling,\n\9\9\9\9})\n\n\9\9\9\9Library:AddToRegistry(Button, {\n\9\9\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9\9\9})\n\n\9\9\9\9local ButtonLabel = Library:CreateLabel({\n\9\9\9\9\9Size = UDim2.new(1, -6, 1, 0),\n\9\9\9\9\9Position = UDim2.new(0, 6, 0, 0),\n\9\9\9\9\9TextSize = 14,\n\9\9\9\9\9Text = Value,\n\9\9\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9\9\9ZIndex = 25,\n\9\9\9\9\9Parent = Button,\n\9\9\9\9})\n\n\9\9\9\9Library:OnHighlight(\n\9\9\9\9\9Button,\n\9\9\9\9\9Button,\n\9\9\9\9\9{ BorderColor3 = \"AccentColor\", ZIndex = 24 },\n\9\9\9\9\9{ BorderColor3 = \"OutlineColor\", ZIndex = 23 }\n\9\9\9\9)\n\n\9\9\9\9local Selected\n\n\9\9\9\9if Info.Multi then\n\9\9\9\9\9Selected = Dropdown.Value[Value]\n\9\9\9\9else\n\9\9\9\9\9Selected = Dropdown.Value == Value\n\9\9\9\9end\n\n\9\9\9\9function Table:UpdateButton()\n\9\9\9\9\9if Info.Multi then\n\9\9\9\9\9\9Selected = Dropdown.Value[Value]\n\9\9\9\9\9else\n\9\9\9\9\9\9Selected = Dropdown.Value == Value\n\9\9\9\9\9end\n\n\9\9\9\9\9ButtonLabel.TextColor3 = Selected and Library.AccentColor or Library.FontColor\n\9\9\9\9\9Library.RegistryMap[ButtonLabel].Properties.TextColor3 = Selected and \"AccentColor\" or \"FontColor\"\n\9\9\9\9end\n\n\9\9\9\9ButtonLabel.InputBegan:Connect(function(Input)\n\9\9\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9\9\9local Try = not Selected\n\n\9\9\9\9\9\9if Dropdown:GetActiveValues() == 1 and not Try and not Info.AllowNull then\n\9\9\9\9\9\9else\n\9\9\9\9\9\9\9if Info.Multi then\n\9\9\9\9\9\9\9\9Selected = Try\n\n\9\9\9\9\9\9\9\9if Selected then\n\9\9\9\9\9\9\9\9\9Dropdown.Value[Value] = true\n\9\9\9\9\9\9\9\9else\n\9\9\9\9\9\9\9\9\9Dropdown.Value[Value] = nil\n\9\9\9\9\9\9\9\9end\n\9\9\9\9\9\9\9else\n\9\9\9\9\9\9\9\9Selected = Try\n\n\9\9\9\9\9\9\9\9if Selected then\n\9\9\9\9\9\9\9\9\9Dropdown.Value = Value\n\9\9\9\9\9\9\9\9else\n\9\9\9\9\9\9\9\9\9Dropdown.Value = nil\n\9\9\9\9\9\9\9\9end\n\n\9\9\9\9\9\9\9\9for _, OtherButton in next, Buttons do\n\9\9\9\9\9\9\9\9\9OtherButton:UpdateButton()\n\9\9\9\9\9\9\9\9end\n\9\9\9\9\9\9\9end\n\n\9\9\9\9\9\9\9Table:UpdateButton()\n\9\9\9\9\9\9\9Dropdown:Display()\n\n\9\9\9\9\9\9\9Library:SafeCallback(Dropdown.Callback, Dropdown.Value)\n\9\9\9\9\9\9\9if Dropdown.Changed then\n\9\9\9\9\9\9\9\9Dropdown.Changed(Dropdown.Value)\n\9\9\9\9\9\9\9end\n\n\9\9\9\9\9\9\9Library:AttemptSave()\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\9\9\9\9end)\n\n\9\9\9\9Table:UpdateButton()\n\9\9\9\9Dropdown:Display()\n\n\9\9\9\9Buttons[Button] = Table\n\9\9\9end\n\n\9\9\9local Y = math.clamp(Count * 20, 0, MAX_DROPDOWN_ITEMS * 20) + 1\n\9\9\9ListOuter.Size = UDim2.new(1, -8, 0, Y)\n\9\9\9Scrolling.CanvasSize = UDim2.new(0, 0, 0, (Count * 20) + 1)\n\n\9\9\9-- ListOuter.Size = UDim2.new(1, -8, 0, (#Values * 20) + 2);\n\9\9end\n\n\9\9function Dropdown:OpenDropdown()\n\9\9\9ListOuter.Visible = true\n\9\9\9Library.OpenedFrames[ListOuter] = true\n\9\9\9DropdownArrow.Rotation = 180\n\9\9end\n\n\9\9function Dropdown:CloseDropdown()\n\9\9\9ListOuter.Visible = false\n\9\9\9Library.OpenedFrames[ListOuter] = nil\n\9\9\9DropdownArrow.Rotation = 0\n\9\9end\n\n\9\9function Dropdown:OnChanged(Func)\n\9\9\9Dropdown.Changed = Func\n\9\9\9Func(Dropdown.Value)\n\9\9end\n\n\9\9function Dropdown:SetValue(Val)\n\9\9\9if Dropdown.Multi then\n\9\9\9\9local nTable = {}\n\n\9\9\9\9for Value, Bool in next, Val do\n\9\9\9\9\9if table.find(Dropdown.Values, Value) then\n\9\9\9\9\9\9nTable[Value] = true\n\9\9\9\9\9end\n\9\9\9\9end\n\n\9\9\9\9Dropdown.Value = nTable\n\9\9\9else\n\9\9\9\9if not Val then\n\9\9\9\9\9Dropdown.Value = nil\n\9\9\9\9elseif table.find(Dropdown.Values, Val) then\n\9\9\9\9\9Dropdown.Value = Val\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9Dropdown:SetValues()\n\9\9\9Dropdown:Display()\n\n\9\9\9Library:SafeCallback(Dropdown.Callback, Dropdown.Value)\n\9\9\9if Dropdown.Changed then\n\9\9\9\9Dropdown.Changed(Dropdown.Value)\n\9\9\9end\n\9\9end\n\n\9\9DropdownOuter.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then\n\9\9\9\9if ListOuter.Visible then\n\9\9\9\9\9Dropdown:CloseDropdown()\n\9\9\9\9else\n\9\9\9\9\9Dropdown:OpenDropdown()\n\9\9\9\9end\n\9\9\9end\n\9\9end)\n\n\9\9InputService.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9local AbsPos, AbsSize = ListOuter.AbsolutePosition, ListOuter.AbsoluteSize\n\n\9\9\9\9if\n\9\9\9\9\9Mouse.X < AbsPos.X\n\9\9\9\9\9or Mouse.X > AbsPos.X + AbsSize.X\n\9\9\9\9\9or Mouse.Y < (AbsPos.Y - 20 - 1)\n\9\9\9\9\9or Mouse.Y > AbsPos.Y + AbsSize.Y\n\9\9\9\9then\n\9\9\9\9\9Dropdown:CloseDropdown()\n\9\9\9\9end\n\9\9\9end\n\9\9end)\n\n\9\9Dropdown:SetValues()\n\9\9Dropdown:Display()\n\n\9\9local Defaults = {}\n\n\9\9if type(Info.Default) == \"string\" then\n\9\9\9local Idx = table.find(Dropdown.Values, Info.Default)\n\9\9\9if Idx then\n\9\9\9\9table.insert(Defaults, Idx)\n\9\9\9end\n\9\9elseif type(Info.Default) == \"table\" then\n\9\9\9for _, Value in next, Info.Default do\n\9\9\9\9local Idx = table.find(Dropdown.Values, Value)\n\9\9\9\9if Idx then\n\9\9\9\9\9table.insert(Defaults, Idx)\n\9\9\9\9end\n\9\9\9end\n\9\9elseif type(Info.Default) == \"number\" and Dropdown.Values[Info.Default] ~= nil then\n\9\9\9table.insert(Defaults, Info.Default)\n\9\9end\n\n\9\9if next(Defaults) then\n\9\9\9for i = 1, #Defaults do\n\9\9\9\9local Index = Defaults[i]\n\9\9\9\9if Info.Multi then\n\9\9\9\9\9Dropdown.Value[Dropdown.Values[Index]] = true\n\9\9\9\9else\n\9\9\9\9\9Dropdown.Value = Dropdown.Values[Index]\n\9\9\9\9end\n\n\9\9\9\9if not Info.Multi then\n\9\9\9\9\9break\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9Dropdown:SetValues()\n\9\9\9Dropdown:Display()\n\9\9end\n\n\9\9Groupbox:AddBlank(Info.BlankSize or 5)\n\9\9Groupbox:Resize()\n\n\9\9Options[Idx] = Dropdown\n\n\9\9return Dropdown\n\9end\n\n\9BaseGroupbox.__index = Funcs\n\9BaseGroupbox.__namecall = function(Table, Key, ...)\n\9\9return Funcs[Key](...)\n\9end\nend\n\n-- < Create other UI elements >\ndo\n\9Library.NotificationArea = Library:Create(\"Frame\", {\n\9\9BackgroundTransparency = 1,\n\9\9Position = UDim2.new(0, 0, 0, 40),\n\9\9Size = UDim2.new(0, 300, 0, 200),\n\9\9ZIndex = 100,\n\9\9Parent = ScreenGui,\n\9})\n\n\9Library:Create(\"UIListLayout\", {\n\9\9Padding = UDim.new(0, 4),\n\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9Parent = Library.NotificationArea,\n\9})\n\n\9local WatermarkOuter = Library:Create(\"Frame\", {\n\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9Position = UDim2.new(0, 100, 0, -25),\n\9\9Size = UDim2.new(0, 213, 0, 20),\n\9\9ZIndex = 200,\n\9\9Visible = false,\n\9\9Parent = ScreenGui,\n\9})\n\n\9local WatermarkInner = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.MainColor,\n\9\9BorderColor3 = Library.AccentColor,\n\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9ZIndex = 201,\n\9\9Parent = WatermarkOuter,\n\9})\n\n\9Library:AddToRegistry(WatermarkInner, {\n\9\9BorderColor3 = \"AccentColor\",\n\9})\n\n\9local InnerFrame = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Color3.new(1, 1, 1),\n\9\9BorderSizePixel = 0,\n\9\9Position = UDim2.new(0, 1, 0, 1),\n\9\9Size = UDim2.new(1, -2, 1, -2),\n\9\9ZIndex = 202,\n\9\9Parent = WatermarkInner,\n\9})\n\n\9local Gradient = Library:Create(\"UIGradient\", {\n\9\9Color = ColorSequence.new({\n\9\9\9ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),\n\9\9\9ColorSequenceKeypoint.new(1, Library.MainColor),\n\9\9}),\n\9\9Rotation = -90,\n\9\9Parent = InnerFrame,\n\9})\n\n\9Library:AddToRegistry(Gradient, {\n\9\9Color = function()\n\9\9\9return ColorSequence.new({\n\9\9\9\9ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),\n\9\9\9\9ColorSequenceKeypoint.new(1, Library.MainColor),\n\9\9\9})\n\9\9end,\n\9})\n\n\9local WatermarkLabel = Library:CreateLabel({\n\9\9Position = UDim2.new(0, 5, 0, 0),\n\9\9Size = UDim2.new(1, -4, 1, 0),\n\9\9TextSize = 14,\n\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9ZIndex = 203,\n\9\9Parent = InnerFrame,\n\9})\n\n\9Library.Watermark = WatermarkOuter\n\9Library.WatermarkText = WatermarkLabel\n\9Library:MakeDraggable(Library.Watermark)\n\n\9local KeybindOuter = Library:Create(\"Frame\", {\n\9\9AnchorPoint = Vector2.new(0, 0.5),\n\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9Position = UDim2.new(0, 10, 0.5, 0),\n\9\9Size = UDim2.new(0, 210, 0, 20),\n\9\9Visible = false,\n\9\9ZIndex = 100,\n\9\9Parent = ScreenGui,\n\9})\n\n\9local KeybindInner = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.MainColor,\n\9\9BorderColor3 = Library.OutlineColor,\n\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9ZIndex = 101,\n\9\9Parent = KeybindOuter,\n\9})\n\n\9Library:AddToRegistry(KeybindInner, {\n\9\9BackgroundColor3 = \"MainColor\",\n\9\9BorderColor3 = \"OutlineColor\",\n\9}, true)\n\n\9local ColorFrame = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.AccentColor,\n\9\9BorderSizePixel = 0,\n\9\9Size = UDim2.new(1, 0, 0, 2),\n\9\9ZIndex = 102,\n\9\9Parent = KeybindInner,\n\9})\n\n\9Library:AddToRegistry(ColorFrame, {\n\9\9BackgroundColor3 = \"AccentColor\",\n\9}, true)\n\n\9local KeybindLabel = Library:CreateLabel({\n\9\9Size = UDim2.new(1, 0, 0, 20),\n\9\9Position = UDim2.fromOffset(5, 2),\n\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\n\9\9Text = \"Keybinds\",\n\9\9ZIndex = 104,\n\9\9Parent = KeybindInner,\n\9})\n\n\9local KeybindContainer = Library:Create(\"Frame\", {\n\9\9BackgroundTransparency = 1,\n\9\9Size = UDim2.new(1, 0, 1, -20),\n\9\9Position = UDim2.new(0, 0, 0, 20),\n\9\9ZIndex = 1,\n\9\9Parent = KeybindInner,\n\9})\n\n\9Library:Create(\"UIListLayout\", {\n\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9Parent = KeybindContainer,\n\9})\n\n\9Library:Create(\"UIPadding\", {\n\9\9PaddingLeft = UDim.new(0, 5),\n\9\9Parent = KeybindContainer,\n\9})\n\n\9Library.KeybindFrame = KeybindOuter\n\9Library.KeybindContainer = KeybindContainer\n\9Library:MakeDraggable(KeybindOuter)\nend\n\nfunction Library:SetWatermarkVisibility(Bool)\n\9Library.Watermark.Visible = Bool\nend\n\nfunction Library:SetWatermark(Text)\n\9local X, Y = Library:GetTextBounds(Text, Library.Font, 14)\n\9Library.Watermark.Size = UDim2.new(0, X + 15, 0, (Y * 1.5) + 3)\n\9Library:SetWatermarkVisibility(true)\n\n\9Library.WatermarkText.Text = Text\nend\n\nfunction Library:Notify(Text, Time)\n\9local XSize, YSize = Library:GetTextBounds(Text, Library.Font, 14)\n\n\9YSize = YSize + 7\n\n\9local NotifyOuter = Library:Create(\"Frame\", {\n\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9Position = UDim2.new(0, 100, 0, 10),\n\9\9Size = UDim2.new(0, 0, 0, YSize),\n\9\9ClipsDescendants = true,\n\9\9ZIndex = 100,\n\9\9Parent = Library.NotificationArea,\n\9})\n\n\9local NotifyInner = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.MainColor,\n\9\9BorderColor3 = Library.OutlineColor,\n\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9ZIndex = 101,\n\9\9Parent = NotifyOuter,\n\9})\n\n\9Library:AddToRegistry(NotifyInner, {\n\9\9BackgroundColor3 = \"MainColor\",\n\9\9BorderColor3 = \"OutlineColor\",\n\9}, true)\n\n\9local InnerFrame = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Color3.new(1, 1, 1),\n\9\9BorderSizePixel = 0,\n\9\9Position = UDim2.new(0, 1, 0, 1),\n\9\9Size = UDim2.new(1, -2, 1, -2),\n\9\9ZIndex = 102,\n\9\9Parent = NotifyInner,\n\9})\n\n\9local Gradient = Library:Create(\"UIGradient\", {\n\9\9Color = ColorSequence.new({\n\9\9\9ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),\n\9\9\9ColorSequenceKeypoint.new(1, Library.MainColor),\n\9\9}),\n\9\9Rotation = -90,\n\9\9Parent = InnerFrame,\n\9})\n\n\9Library:AddToRegistry(Gradient, {\n\9\9Color = function()\n\9\9\9return ColorSequence.new({\n\9\9\9\9ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),\n\9\9\9\9ColorSequenceKeypoint.new(1, Library.MainColor),\n\9\9\9})\n\9\9end,\n\9})\n\n\9local NotifyLabel = Library:CreateLabel({\n\9\9Position = UDim2.new(0, 4, 0, 0),\n\9\9Size = UDim2.new(1, -4, 1, 0),\n\9\9Text = Text,\n\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9TextSize = 14,\n\9\9ZIndex = 103,\n\9\9Parent = InnerFrame,\n\9})\n\n\9local LeftColor = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.AccentColor,\n\9\9BorderSizePixel = 0,\n\9\9Position = UDim2.new(0, -1, 0, -1),\n\9\9Size = UDim2.new(0, 3, 1, 2),\n\9\9ZIndex = 104,\n\9\9Parent = NotifyOuter,\n\9})\n\n\9Library:AddToRegistry(LeftColor, {\n\9\9BackgroundColor3 = \"AccentColor\",\n\9}, true)\n\n\9pcall(NotifyOuter.TweenSize, NotifyOuter, UDim2.new(0, XSize + 8 + 4, 0, YSize), \"Out\", \"Quad\", 0.4, true)\n\n\9task.spawn(function()\n\9\9wait(Time or 5)\n\n\9\9pcall(NotifyOuter.TweenSize, NotifyOuter, UDim2.new(0, 0, 0, YSize), \"Out\", \"Quad\", 0.4, true)\n\n\9\9wait(0.4)\n\n\9\9NotifyOuter:Destroy()\n\9end)\nend\n\nfunction Library:CreateWindow(...)\n\9local Arguments = { ... }\n\9local Config = { AnchorPoint = Vector2.zero }\n\n\9if type(...) == \"table\" then\n\9\9Config = ...\n\9else\n\9\9Config.Title = Arguments[1]\n\9\9Config.AutoShow = Arguments[2] or false\n\9end\n\n\9if type(Config.Title) ~= \"string\" then\n\9\9Config.Title = \"No title\"\n\9end\n\n\9if typeof(Config.Position) ~= \"UDim2\" then\n\9\9Config.Position = UDim2.fromOffset(175, 50)\n\9end\n\9if typeof(Config.Size) ~= \"UDim2\" then\n\9\9Config.Size = UDim2.fromOffset(550, 600)\n\9end\n\n\9if Config.Center then\n\9\9Config.AnchorPoint = Vector2.new(0.5, 0.5)\n\9\9Config.Position = UDim2.fromScale(0.5, 0.5)\n\9end\n\n\9local Window = {\n\9\9Tabs = {},\n\9}\n\n\9local Outer = Library:Create(\"Frame\", {\n\9\9AnchorPoint = Config.AnchorPoint,\n\9\9BackgroundColor3 = Color3.new(0, 0, 0),\n\9\9BorderSizePixel = 0,\n\9\9Position = Config.Position,\n\9\9Size = Config.Size,\n\9\9Visible = false,\n\9\9ZIndex = 1,\n\9\9Parent = ScreenGui,\n\9})\n\n\9Library:MakeDraggable(Outer, 25)\n\n\9local Inner = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.MainColor,\n\9\9BorderColor3 = Library.AccentColor,\n\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9Position = UDim2.new(0, 1, 0, 1),\n\9\9Size = UDim2.new(1, -2, 1, -2),\n\9\9ZIndex = 1,\n\9\9Parent = Outer,\n\9})\n\n\9Library:AddToRegistry(Inner, {\n\9\9BackgroundColor3 = \"MainColor\",\n\9\9BorderColor3 = \"AccentColor\",\n\9})\n\n\9local WindowLabel = Library:CreateLabel({\n\9\9Position = UDim2.new(0, 7, 0, 0),\n\9\9Size = UDim2.new(0, 0, 0, 25),\n\9\9Text = Config.Title or \"\",\n\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9ZIndex = 1,\n\9\9Parent = Inner,\n\9})\n\n\9local MainSectionOuter = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9BorderColor3 = Library.OutlineColor,\n\9\9Position = UDim2.new(0, 8, 0, 25),\n\9\9Size = UDim2.new(1, -16, 1, -33),\n\9\9ZIndex = 1,\n\9\9Parent = Inner,\n\9})\n\n\9Library:AddToRegistry(MainSectionOuter, {\n\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9BorderColor3 = \"OutlineColor\",\n\9})\n\n\9local MainSectionInner = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9Position = UDim2.new(0, 0, 0, 0),\n\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9ZIndex = 1,\n\9\9Parent = MainSectionOuter,\n\9})\n\n\9Library:AddToRegistry(MainSectionInner, {\n\9\9BackgroundColor3 = \"BackgroundColor\",\n\9})\n\n\9local TabArea = Library:Create(\"Frame\", {\n\9\9BackgroundTransparency = 1,\n\9\9Position = UDim2.new(0, 8, 0, 8),\n\9\9Size = UDim2.new(1, -16, 0, 21),\n\9\9ZIndex = 1,\n\9\9Parent = MainSectionInner,\n\9})\n\n\9local TabListLayout = Library:Create(\"UIListLayout\", {\n\9\9Padding = UDim.new(0, 0),\n\9\9FillDirection = Enum.FillDirection.Horizontal,\n\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9Parent = TabArea,\n\9})\n\n\9local TabContainer = Library:Create(\"Frame\", {\n\9\9BackgroundColor3 = Library.MainColor,\n\9\9BorderColor3 = Library.OutlineColor,\n\9\9Position = UDim2.new(0, 8, 0, 30),\n\9\9Size = UDim2.new(1, -16, 1, -38),\n\9\9ZIndex = 2,\n\9\9Parent = MainSectionInner,\n\9})\n\n\9Library:AddToRegistry(TabContainer, {\n\9\9BackgroundColor3 = \"MainColor\",\n\9\9BorderColor3 = \"OutlineColor\",\n\9})\n\n\9function Window:SetWindowTitle(Title)\n\9\9WindowLabel.Text = Title\n\9end\n\n\9function Window:AddTab(Name)\n\9\9local Tab = {\n\9\9\9Groupboxes = {},\n\9\9\9Tabboxes = {},\n\9\9}\n\n\9\9local TabButtonWidth = Library:GetTextBounds(Name, Library.Font, 16)\n\n\9\9local TabButton = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9Size = UDim2.new(0, TabButtonWidth + 8 + 4, 1, 0),\n\9\9\9ZIndex = 1,\n\9\9\9Parent = TabArea,\n\9\9})\n\n\9\9Library:AddToRegistry(TabButton, {\n\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9})\n\n\9\9local TabButtonLabel = Library:CreateLabel({\n\9\9\9Position = UDim2.new(0, 0, 0, 0),\n\9\9\9Size = UDim2.new(1, 0, 1, -1),\n\9\9\9Text = Name,\n\9\9\9ZIndex = 1,\n\9\9\9Parent = TabButton,\n\9\9})\n\n\9\9local Blocker = Library:Create(\"Frame\", {\n\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9BorderSizePixel = 0,\n\9\9\9Position = UDim2.new(0, 0, 1, 0),\n\9\9\9Size = UDim2.new(1, 0, 0, 1),\n\9\9\9BackgroundTransparency = 1,\n\9\9\9ZIndex = 3,\n\9\9\9Parent = TabButton,\n\9\9})\n\n\9\9Library:AddToRegistry(Blocker, {\n\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9})\n\n\9\9local TabFrame = Library:Create(\"Frame\", {\n\9\9\9Name = \"TabFrame\",\n\9\9\9BackgroundTransparency = 1,\n\9\9\9Position = UDim2.new(0, 0, 0, 0),\n\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9Visible = false,\n\9\9\9ZIndex = 2,\n\9\9\9Parent = TabContainer,\n\9\9})\n\n\9\9local LeftSide = Library:Create(\"Frame\", {\n\9\9\9BackgroundTransparency = 1,\n\9\9\9Position = UDim2.new(0, 8, 0, 8),\n\9\9\9Size = UDim2.new(0.5, -12, 0, 507),\n\9\9\9ZIndex = 2,\n\9\9\9Parent = TabFrame,\n\9\9})\n\n\9\9local RightSide = Library:Create(\"Frame\", {\n\9\9\9BackgroundTransparency = 1,\n\9\9\9Position = UDim2.new(0.5, 4, 0, 8),\n\9\9\9Size = UDim2.new(0.5, -12, 0, 507),\n\9\9\9ZIndex = 2,\n\9\9\9Parent = TabFrame,\n\9\9})\n\n\9\9Library:Create(\"UIListLayout\", {\n\9\9\9Padding = UDim.new(0, 8),\n\9\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9Parent = LeftSide,\n\9\9})\n\n\9\9Library:Create(\"UIListLayout\", {\n\9\9\9Padding = UDim.new(0, 8),\n\9\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9Parent = RightSide,\n\9\9})\n\n\9\9function Tab:ShowTab()\n\9\9\9for _, Tab in next, Window.Tabs do\n\9\9\9\9Tab:HideTab()\n\9\9\9end\n\n\9\9\9Blocker.BackgroundTransparency = 0\n\9\9\9TabButton.BackgroundColor3 = Library.MainColor\n\9\9\9Library.RegistryMap[TabButton].Properties.BackgroundColor3 = \"MainColor\"\n\9\9\9TabFrame.Visible = true\n\9\9end\n\n\9\9function Tab:HideTab()\n\9\9\9Blocker.BackgroundTransparency = 1\n\9\9\9TabButton.BackgroundColor3 = Library.BackgroundColor\n\9\9\9Library.RegistryMap[TabButton].Properties.BackgroundColor3 = \"BackgroundColor\"\n\9\9\9TabFrame.Visible = false\n\9\9end\n\n\9\9function Tab:SetLayoutOrder(Position)\n\9\9\9TabButton.LayoutOrder = Position\n\9\9\9TabListLayout:ApplyLayout()\n\9\9end\n\n\9\9function Tab:AddGroupbox(Info)\n\9\9\9local Groupbox = {}\n\n\9\9\9local BoxOuter = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9\9Size = UDim2.new(1, 0, 0, 507),\n\9\9\9\9ZIndex = 2,\n\9\9\9\9Parent = Info.Side == 1 and LeftSide or RightSide,\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(BoxOuter, {\n\9\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9\9})\n\n\9\9\9local BoxInner = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9\9ZIndex = 4,\n\9\9\9\9Parent = BoxOuter,\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(BoxInner, {\n\9\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9})\n\n\9\9\9local Highlight = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.AccentColor,\n\9\9\9\9BorderSizePixel = 0,\n\9\9\9\9Size = UDim2.new(1, 0, 0, 2),\n\9\9\9\9ZIndex = 5,\n\9\9\9\9Parent = BoxInner,\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(Highlight, {\n\9\9\9\9BackgroundColor3 = \"AccentColor\",\n\9\9\9})\n\n\9\9\9local GroupboxLabel = Library:CreateLabel({\n\9\9\9\9Size = UDim2.new(1, 0, 0, 18),\n\9\9\9\9Position = UDim2.new(0, 4, 0, 2),\n\9\9\9\9TextSize = 14,\n\9\9\9\9Text = Info.Name,\n\9\9\9\9TextXAlignment = Enum.TextXAlignment.Left,\n\9\9\9\9ZIndex = 5,\n\9\9\9\9Parent = BoxInner,\n\9\9\9})\n\n\9\9\9local Container = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundTransparency = 1,\n\9\9\9\9Position = UDim2.new(0, 4, 0, 20),\n\9\9\9\9Size = UDim2.new(1, -4, 1, -20),\n\9\9\9\9ZIndex = 1,\n\9\9\9\9Parent = BoxInner,\n\9\9\9})\n\n\9\9\9Library:Create(\"UIListLayout\", {\n\9\9\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9\9Parent = Container,\n\9\9\9})\n\n\9\9\9function Groupbox:Resize()\n\9\9\9\9local Size = 0\n\n\9\9\9\9for _, Element in next, Groupbox.Container:GetChildren() do\n\9\9\9\9\9if not Element:IsA(\"UIListLayout\") then\n\9\9\9\9\9\9Size = Size + Element.Size.Y.Offset\n\9\9\9\9\9end\n\9\9\9\9end\n\n\9\9\9\9BoxOuter.Size = UDim2.new(1, 0, 0, 20 + Size + 2)\n\9\9\9end\n\n\9\9\9Groupbox.Container = Container\n\9\9\9setmetatable(Groupbox, BaseGroupbox)\n\n\9\9\9Groupbox:AddBlank(3)\n\9\9\9Groupbox:Resize()\n\n\9\9\9Tab.Groupboxes[Info.Name] = Groupbox\n\n\9\9\9return Groupbox\n\9\9end\n\n\9\9function Tab:AddLeftGroupbox(Name)\n\9\9\9return Tab:AddGroupbox({ Side = 1, Name = Name })\n\9\9end\n\n\9\9function Tab:AddRightGroupbox(Name)\n\9\9\9return Tab:AddGroupbox({ Side = 2, Name = Name })\n\9\9end\n\n\9\9function Tab:AddTabbox(Info)\n\9\9\9local Tabbox = {\n\9\9\9\9Tabs = {},\n\9\9\9}\n\n\9\9\9local BoxOuter = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9\9BorderColor3 = Library.OutlineColor,\n\9\9\9\9Size = UDim2.new(1, 0, 0, 0),\n\9\9\9\9ZIndex = 2,\n\9\9\9\9Parent = Info.Side == 1 and LeftSide or RightSide,\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(BoxOuter, {\n\9\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9\9BorderColor3 = \"OutlineColor\",\n\9\9\9})\n\n\9\9\9local BoxInner = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9\9BorderMode = Enum.BorderMode.Inset,\n\9\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9\9ZIndex = 4,\n\9\9\9\9Parent = BoxOuter,\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(BoxInner, {\n\9\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9})\n\n\9\9\9local Highlight = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundColor3 = Library.AccentColor,\n\9\9\9\9BorderSizePixel = 0,\n\9\9\9\9Size = UDim2.new(1, 0, 0, 2),\n\9\9\9\9ZIndex = 10,\n\9\9\9\9Parent = BoxInner,\n\9\9\9})\n\n\9\9\9Library:AddToRegistry(Highlight, {\n\9\9\9\9BackgroundColor3 = \"AccentColor\",\n\9\9\9})\n\n\9\9\9local TabboxButtons = Library:Create(\"Frame\", {\n\9\9\9\9BackgroundTransparency = 1,\n\9\9\9\9Position = UDim2.new(0, 0, 0, 1),\n\9\9\9\9Size = UDim2.new(1, 0, 0, 18),\n\9\9\9\9ZIndex = 5,\n\9\9\9\9Parent = BoxInner,\n\9\9\9})\n\n\9\9\9Library:Create(\"UIListLayout\", {\n\9\9\9\9FillDirection = Enum.FillDirection.Horizontal,\n\9\9\9\9HorizontalAlignment = Enum.HorizontalAlignment.Left,\n\9\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9\9Parent = TabboxButtons,\n\9\9\9})\n\n\9\9\9function Tabbox:AddTab(Name)\n\9\9\9\9local Tab = {}\n\n\9\9\9\9local Button = Library:Create(\"Frame\", {\n\9\9\9\9\9BackgroundColor3 = Library.MainColor,\n\9\9\9\9\9BorderColor3 = Color3.new(0, 0, 0),\n\9\9\9\9\9Size = UDim2.new(0.5, 0, 1, 0),\n\9\9\9\9\9ZIndex = 6,\n\9\9\9\9\9Parent = TabboxButtons,\n\9\9\9\9})\n\n\9\9\9\9Library:AddToRegistry(Button, {\n\9\9\9\9\9BackgroundColor3 = \"MainColor\",\n\9\9\9\9})\n\n\9\9\9\9local ButtonLabel = Library:CreateLabel({\n\9\9\9\9\9Size = UDim2.new(1, 0, 1, 0),\n\9\9\9\9\9TextSize = 14,\n\9\9\9\9\9Text = Name,\n\9\9\9\9\9TextXAlignment = Enum.TextXAlignment.Center,\n\9\9\9\9\9ZIndex = 7,\n\9\9\9\9\9Parent = Button,\n\9\9\9\9})\n\n\9\9\9\9local Block = Library:Create(\"Frame\", {\n\9\9\9\9\9BackgroundColor3 = Library.BackgroundColor,\n\9\9\9\9\9BorderSizePixel = 0,\n\9\9\9\9\9Position = UDim2.new(0, 0, 1, 0),\n\9\9\9\9\9Size = UDim2.new(1, 0, 0, 1),\n\9\9\9\9\9Visible = false,\n\9\9\9\9\9ZIndex = 9,\n\9\9\9\9\9Parent = Button,\n\9\9\9\9})\n\n\9\9\9\9Library:AddToRegistry(Block, {\n\9\9\9\9\9BackgroundColor3 = \"BackgroundColor\",\n\9\9\9\9})\n\n\9\9\9\9local Container = Library:Create(\"Frame\", {\n\9\9\9\9\9Position = UDim2.new(0, 4, 0, 20),\n\9\9\9\9\9Size = UDim2.new(1, -4, 1, -20),\n\9\9\9\9\9ZIndex = 1,\n\9\9\9\9\9Visible = false,\n\9\9\9\9\9Parent = BoxInner,\n\9\9\9\9})\n\n\9\9\9\9Library:Create(\"UIListLayout\", {\n\9\9\9\9\9FillDirection = Enum.FillDirection.Vertical,\n\9\9\9\9\9SortOrder = Enum.SortOrder.LayoutOrder,\n\9\9\9\9\9Parent = Container,\n\9\9\9\9})\n\n\9\9\9\9function Tab:Show()\n\9\9\9\9\9for _, Tab in next, Tabbox.Tabs do\n\9\9\9\9\9\9Tab:Hide()\n\9\9\9\9\9end\n\n\9\9\9\9\9Container.Visible = true\n\9\9\9\9\9Block.Visible = true\n\n\9\9\9\9\9Button.BackgroundColor3 = Library.BackgroundColor\n\9\9\9\9\9Library.RegistryMap[Button].Properties.BackgroundColor3 = \"BackgroundColor\"\n\9\9\9\9end\n\n\9\9\9\9function Tab:Hide()\n\9\9\9\9\9Container.Visible = false\n\9\9\9\9\9Block.Visible = false\n\n\9\9\9\9\9Button.BackgroundColor3 = Library.MainColor\n\9\9\9\9\9Library.RegistryMap[Button].Properties.BackgroundColor3 = \"MainColor\"\n\9\9\9\9end\n\n\9\9\9\9function Tab:Resize()\n\9\9\9\9\9local TabCount = 0\n\n\9\9\9\9\9for _, Tab in next, Tabbox.Tabs do\n\9\9\9\9\9\9TabCount = TabCount + 1\n\9\9\9\9\9end\n\n\9\9\9\9\9for _, Button in next, TabboxButtons:GetChildren() do\n\9\9\9\9\9\9if not Button:IsA(\"UIListLayout\") then\n\9\9\9\9\9\9\9Button.Size = UDim2.new(1 / TabCount, 0, 1, 0)\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\n\9\9\9\9\9local Size = 0\n\n\9\9\9\9\9for _, Element in next, Tab.Container:GetChildren() do\n\9\9\9\9\9\9if not Element:IsA(\"UIListLayout\") then\n\9\9\9\9\9\9\9Size = Size + Element.Size.Y.Offset\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\n\9\9\9\9\9if BoxOuter.Size.Y.Offset < 20 + Size + 2 then\n\9\9\9\9\9\9BoxOuter.Size = UDim2.new(1, 0, 0, 20 + Size + 2)\n\9\9\9\9\9end\n\9\9\9\9end\n\n\9\9\9\9Button.InputBegan:Connect(function(Input)\n\9\9\9\9\9if\n\9\9\9\9\9\9Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()\n\9\9\9\9\9then\n\9\9\9\9\9\9Tab:Show()\n\9\9\9\9\9end\n\9\9\9\9end)\n\n\9\9\9\9Tab.Container = Container\n\9\9\9\9Tabbox.Tabs[Name] = Tab\n\n\9\9\9\9setmetatable(Tab, BaseGroupbox)\n\n\9\9\9\9Tab:AddBlank(3)\n\9\9\9\9Tab:Resize()\n\n\9\9\9\9if #TabboxButtons:GetChildren() == 2 then\n\9\9\9\9\9Tab:Show()\n\9\9\9\9end\n\n\9\9\9\9return Tab\n\9\9\9end\n\n\9\9\9Tab.Tabboxes[Info.Name or \"\"] = Tabbox\n\n\9\9\9return Tabbox\n\9\9end\n\n\9\9function Tab:AddLeftTabbox(Name)\n\9\9\9return Tab:AddTabbox({ Name = Name, Side = 1 })\n\9\9end\n\n\9\9function Tab:AddRightTabbox(Name)\n\9\9\9return Tab:AddTabbox({ Name = Name, Side = 2 })\n\9\9end\n\n\9\9TabButton.InputBegan:Connect(function(Input)\n\9\9\9if Input.UserInputType == Enum.UserInputType.MouseButton1 then\n\9\9\9\9Tab:ShowTab()\n\9\9\9end\n\9\9end)\n\n\9\9-- This was the first tab added, so we show it by default.\n\9\9if #TabContainer:GetChildren() == 1 then\n\9\9\9Tab:ShowTab()\n\9\9end\n\n\9\9Window.Tabs[Name] = Tab\n\9\9return Tab\n\9end\n\n\9local ModalElement = Library:Create(\"TextButton\", {\n\9\9BackgroundTransparency = 1,\n\9\9Size = UDim2.new(0, 0, 0, 0),\n\9\9Visible = true,\n\9\9Text = \"\",\n\9\9Modal = false,\n\9\9Parent = ScreenGui,\n\9})\n\n\9function Library.Toggle()\n\9\9Outer.Visible = not Outer.Visible\n\9\9ModalElement.Modal = Outer.Visible\n\n\9\9local oIcon = Mouse.Icon\n\9\9local State = InputService.MouseIconEnabled\n\n\9\9while Outer.Visible and ScreenGui.Parent do\n\9\9\9RenderStepped:Wait()\n\9\9end\n\9end\n\n\9Library:GiveSignal(InputService.InputBegan:Connect(function(Input, Processed)\n\9\9if type(Library.ToggleKeybind) == \"table\" and Library.ToggleKeybind.Type == \"KeyPicker\" then\n\9\9\9if\n\9\9\9\9Input.UserInputType == Enum.UserInputType.Keyboard\n\9\9\9\9and Input.KeyCode.Name == Library.ToggleKeybind.Value\n\9\9\9then\n\9\9\9\9task.spawn(Library.Toggle)\n\9\9\9end\n\9\9elseif\n\9\9\9Input.KeyCode == Enum.KeyCode.RightControl or (Input.KeyCode == Enum.KeyCode.RightShift and not Processed)\n\9\9then\n\9\9\9task.spawn(Library.Toggle)\n\9\9end\n\9end))\n\n\9if Config.AutoShow then\n\9\9task.spawn(Library.Toggle)\n\9end\n\n\9Window.Holder = Outer\n\n\9return Window\nend\n\nlocal function OnPlayerChange()\n\9local PlayerList = GetPlayersString()\n\9for _, Value in next, Options do\n\9\9if Value.Type == \"Dropdown\" and Value.SpecialType == \"Player\" then\n\9\9\9Value.Values = PlayerList\n\9\9\9Value:SetValues()\n\9\9end\n\9end\nend\nPlayers.PlayerAdded:Connect(OnPlayerChange)\nPlayers.PlayerRemoving:Connect(OnPlayerChange)\n\nreturn Library\n", "bundle-ex.shared.src.structures.ui-library.ui-library"))(__env)
end)
__rbx("util", "Folder", "bundle-ex.shared.src.util", "bundle-ex.shared.src")
__lua("character", "ModuleScript", "bundle-ex.shared.src.util.character", "bundle-ex.shared.src.util", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.shared.src.util.character\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)\nlocal exports = {}\nlocal Players = TS.import(script, script.Parent.Parent.Parent.Parent, \"include\", \"node_modules\", \"@rbxts\", \"services\").Players\nexports.localChar = Players.LocalPlayer.Character\nlocal _result = exports.localChar\nif _result ~= nil then\n\9_result = _result:WaitForChild(\"HumanoidRootPart\")\nend\nexports.localRoot = _result\nlocal _result_1 = exports.localChar\nif _result_1 ~= nil then\n\9_result_1 = _result_1:WaitForChild(\"Humanoid\")\nend\nexports.localHumanoid = _result_1\nlocal function registerCharacter(char)\n\9exports.localChar = char\n\9exports.localRoot = char:WaitForChild(\"HumanoidRootPart\")\n\9exports.localHumanoid = char:WaitForChild(\"Humanoid\")\n\9local connection\n\9connection = (exports.localHumanoid).Died:Connect(function()\n\9\9if connection then\n\9\9\9connection:Disconnect()\n\9\9\9connection = nil\n\9\9end\n\9\9exports.localChar = nil\n\9\9exports.localRoot = nil\n\9\9exports.localHumanoid = nil\n\9end)\nend\nPlayers.LocalPlayer.CharacterAdded:Connect(registerCharacter)\nif Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild(\"Humanoid\") then\n\9task.spawn(registerCharacter, Players.LocalPlayer.Character)\nend\nreturn exports\n", "bundle-ex.shared.src.util.character"))(__env)
end)
__rbx("include", "Folder", "bundle-ex.include", "bundle-ex")
__lua("Promise", "ModuleScript", "bundle-ex.include.Promise", "bundle-ex.include", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.Promise\")local script,require=_.script,_.require --[[\n\9An implementation of Promises similar to Promise/A+.\n]]\n\nlocal ERROR_NON_PROMISE_IN_LIST = \"Non-promise value passed into %s at index %s\"\nlocal ERROR_NON_LIST = \"Please pass a list of promises to %s\"\nlocal ERROR_NON_FUNCTION = \"Please pass a handler function to %s!\"\nlocal MODE_KEY_METATABLE = { __mode = \"k\" }\n\nlocal function isCallable(value)\n\9if type(value) == \"function\" then\n\9\9return true\n\9end\n\n\9if type(value) == \"table\" then\n\9\9local metatable = getmetatable(value)\n\9\9if metatable and type(rawget(metatable, \"__call\")) == \"function\" then\n\9\9\9return true\n\9\9end\n\9end\n\n\9return false\nend\n\n--[[\n\9Creates an enum dictionary with some metamethods to prevent common mistakes.\n]]\nlocal function makeEnum(enumName, members)\n\9local enum = {}\n\n\9for _, memberName in ipairs(members) do\n\9\9enum[memberName] = memberName\n\9end\n\n\9return setmetatable(enum, {\n\9\9__index = function(_, k)\n\9\9\9error(string.format(\"%s is not in %s!\", k, enumName), 2)\n\9\9end,\n\9\9__newindex = function()\n\9\9\9error(string.format(\"Creating new members in %s is not allowed!\", enumName), 2)\n\9\9end,\n\9})\nend\n\n--[=[\n\9An object to represent runtime errors that occur during execution.\n\9Promises that experience an error like this will be rejected with\n\9an instance of this object.\n\n\9@class Error\n]=]\nlocal Error\ndo\n\9Error = {\n\9\9Kind = makeEnum(\"Promise.Error.Kind\", {\n\9\9\9\"ExecutionError\",\n\9\9\9\"AlreadyCancelled\",\n\9\9\9\"NotResolvedInTime\",\n\9\9\9\"TimedOut\",\n\9\9}),\n\9}\n\9Error.__index = Error\n\n\9function Error.new(options, parent)\n\9\9options = options or {}\n\9\9return setmetatable({\n\9\9\9error = tostring(options.error) or \"[This error has no error text.]\",\n\9\9\9trace = options.trace,\n\9\9\9context = options.context,\n\9\9\9kind = options.kind,\n\9\9\9parent = parent,\n\9\9\9createdTick = os.clock(),\n\9\9\9createdTrace = debug.traceback(),\n\9\9}, Error)\n\9end\n\n\9function Error.is(anything)\n\9\9if type(anything) == \"table\" then\n\9\9\9local metatable = getmetatable(anything)\n\n\9\9\9if type(metatable) == \"table\" then\n\9\9\9\9return rawget(anything, \"error\") ~= nil and type(rawget(metatable, \"extend\")) == \"function\"\n\9\9\9end\n\9\9end\n\n\9\9return false\n\9end\n\n\9function Error.isKind(anything, kind)\n\9\9assert(kind ~= nil, \"Argument #2 to Promise.Error.isKind must not be nil\")\n\n\9\9return Error.is(anything) and anything.kind == kind\n\9end\n\n\9function Error:extend(options)\n\9\9options = options or {}\n\n\9\9options.kind = options.kind or self.kind\n\n\9\9return Error.new(options, self)\n\9end\n\n\9function Error:getErrorChain()\n\9\9local runtimeErrors = { self }\n\n\9\9while runtimeErrors[#runtimeErrors].parent do\n\9\9\9table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)\n\9\9end\n\n\9\9return runtimeErrors\n\9end\n\n\9function Error:__tostring()\n\9\9local errorStrings = {\n\9\9\9string.format(\"-- Promise.Error(%s) --\", self.kind or \"?\"),\n\9\9}\n\n\9\9for _, runtimeError in ipairs(self:getErrorChain()) do\n\9\9\9table.insert(\n\9\9\9\9errorStrings,\n\9\9\9\9table.concat({\n\9\9\9\9\9runtimeError.trace or runtimeError.error,\n\9\9\9\9\9runtimeError.context,\n\9\9\9\9}, \"\\n\")\n\9\9\9)\n\9\9end\n\n\9\9return table.concat(errorStrings, \"\\n\")\n\9end\nend\n\n--[[\n\9Packs a number of arguments into a table and returns its length.\n\n\9Used to cajole varargs without dropping sparse values.\n]]\nlocal function pack(...)\n\9return select(\"#\", ...), { ... }\nend\n\n--[[\n\9Returns first value (success), and packs all following values.\n]]\nlocal function packResult(success, ...)\n\9return success, select(\"#\", ...), { ... }\nend\n\nlocal function makeErrorHandler(traceback)\n\9assert(traceback ~= nil, \"traceback is nil\")\n\n\9return function(err)\n\9\9-- If the error object is already a table, forward it directly.\n\9\9-- Should we extend the error here and add our own trace?\n\n\9\9if type(err) == \"table\" then\n\9\9\9return err\n\9\9end\n\n\9\9return Error.new({\n\9\9\9error = err,\n\9\9\9kind = Error.Kind.ExecutionError,\n\9\9\9trace = debug.traceback(tostring(err), 2),\n\9\9\9context = \"Promise created at:\\n\\n\" .. traceback,\n\9\9})\n\9end\nend\n\n--[[\n\9Calls a Promise executor with error handling.\n]]\nlocal function runExecutor(traceback, callback, ...)\n\9return packResult(xpcall(callback, makeErrorHandler(traceback), ...))\nend\n\n--[[\n\9Creates a function that invokes a callback with correct error handling and\n\9resolution mechanisms.\n]]\nlocal function createAdvancer(traceback, callback, resolve, reject)\n\9return function(...)\n\9\9local ok, resultLength, result = runExecutor(traceback, callback, ...)\n\n\9\9if ok then\n\9\9\9resolve(unpack(result, 1, resultLength))\n\9\9else\n\9\9\9reject(result[1])\n\9\9end\n\9end\nend\n\nlocal function isEmpty(t)\n\9return next(t) == nil\nend\n\n--[=[\n\9An enum value used to represent the Promise's status.\n\9@interface Status\n\9@tag enum\n\9@within Promise\n\9.Started \"Started\" -- The Promise is executing, and not settled yet.\n\9.Resolved \"Resolved\" -- The Promise finished successfully.\n\9.Rejected \"Rejected\" -- The Promise was rejected.\n\9.Cancelled \"Cancelled\" -- The Promise was cancelled before it finished.\n]=]\n--[=[\n\9@prop Status Status\n\9@within Promise\n\9@readonly\n\9@tag enums\n\9A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.\n]=]\n--[=[\n\9A Promise is an object that represents a value that will exist in the future, but doesn't right now.\n\9Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),\n\9or if an error has occurred (known as *rejecting*).\n\n\9@class Promise\n\9@__index prototype\n]=]\nlocal Promise = {\n\9Error = Error,\n\9Status = makeEnum(\"Promise.Status\", { \"Started\", \"Resolved\", \"Rejected\", \"Cancelled\" }),\n\9_getTime = os.clock,\n\9_timeEvent = game:GetService(\"RunService\").Heartbeat,\n\9_unhandledRejectionCallbacks = {},\n}\nPromise.prototype = {}\nPromise.__index = Promise.prototype\n\nfunction Promise._new(traceback, callback, parent)\n\9if parent ~= nil and not Promise.is(parent) then\n\9\9error(\"Argument #2 to Promise.new must be a promise or nil\", 2)\n\9end\n\n\9local self = {\n\9\9-- Used to locate where a promise was created\n\9\9_source = traceback,\n\n\9\9_status = Promise.Status.Started,\n\n\9\9-- A table containing a list of all results, whether success or failure.\n\9\9-- Only valid if _status is set to something besides Started\n\9\9_values = nil,\n\n\9\9-- Lua doesn't like sparse arrays very much, so we explicitly store the\n\9\9-- length of _values to handle middle nils.\n\9\9_valuesLength = -1,\n\n\9\9-- Tracks if this Promise has no error observers..\n\9\9_unhandledRejection = true,\n\n\9\9-- Queues representing functions we should invoke when we update!\n\9\9_queuedResolve = {},\n\9\9_queuedReject = {},\n\9\9_queuedFinally = {},\n\n\9\9-- The function to run when/if this promise is cancelled.\n\9\9_cancellationHook = nil,\n\n\9\9-- The \"parent\" of this promise in a promise chain. Required for\n\9\9-- cancellation propagation upstream.\n\9\9_parent = parent,\n\n\9\9-- Consumers are Promises that have chained onto this one.\n\9\9-- We track them for cancellation propagation downstream.\n\9\9_consumers = setmetatable({}, MODE_KEY_METATABLE),\n\9}\n\n\9if parent and parent._status == Promise.Status.Started then\n\9\9parent._consumers[self] = true\n\9end\n\n\9setmetatable(self, Promise)\n\n\9local function resolve(...)\n\9\9self:_resolve(...)\n\9end\n\n\9local function reject(...)\n\9\9self:_reject(...)\n\9end\n\n\9local function onCancel(cancellationHook)\n\9\9if cancellationHook then\n\9\9\9if self._status == Promise.Status.Cancelled then\n\9\9\9\9cancellationHook()\n\9\9\9else\n\9\9\9\9self._cancellationHook = cancellationHook\n\9\9\9end\n\9\9end\n\n\9\9return self._status == Promise.Status.Cancelled\n\9end\n\n\9coroutine.wrap(function()\n\9\9local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)\n\n\9\9if not ok then\n\9\9\9reject(result[1])\n\9\9end\n\9end)()\n\n\9return self\nend\n\n--[=[\n\9Construct a new Promise that will be resolved or rejected with the given callbacks.\n\n\9If you `resolve` with a Promise, it will be chained onto.\n\n\9You can safely yield within the executor function and it will not block the creating thread.\n\n\9```lua\n\9local myFunction()\n\9\9return Promise.new(function(resolve, reject, onCancel)\n\9\9\9wait(1)\n\9\9\9resolve(\"Hello world!\")\n\9\9end)\n\9end\n\n\9myFunction():andThen(print)\n\9```\n\n\9You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.\n\n\9You may register an optional cancellation hook by using the `onCancel` argument:\n\n\9* This should be used to abort any ongoing operations leading up to the promise being settled.\n\9* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.\n\9* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.\n\9* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.\n\9* You can set the cancellation hook at any time before resolving.\n\9* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.\n\n\9@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\9@return Promise\n]=]\nfunction Promise.new(executor)\n\9return Promise._new(debug.traceback(nil, 2), executor)\nend\n\nfunction Promise:__tostring()\n\9return string.format(\"Promise(%s)\", self._status)\nend\n\n--[=[\n\9The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.\n\n\9This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.\n\n\9```lua\n\9local function waitForChild(instance, childName, timeout)\n\9  return Promise.defer(function(resolve, reject)\n\9\9local child = instance:WaitForChild(childName, timeout)\n\n\9\9;(child and resolve or reject)(child)\n\9  end)\n\9end\n\9```\n\n\9@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\9@return Promise\n]=]\nfunction Promise.defer(executor)\n\9local traceback = debug.traceback(nil, 2)\n\9local promise\n\9promise = Promise._new(traceback, function(resolve, reject, onCancel)\n\9\9local connection\n\9\9connection = Promise._timeEvent:Connect(function()\n\9\9\9connection:Disconnect()\n\9\9\9local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)\n\n\9\9\9if not ok then\n\9\9\9\9reject(result[1])\n\9\9\9end\n\9\9end)\n\9end)\n\n\9return promise\nend\n\n-- Backwards compatibility\nPromise.async = Promise.defer\n\n--[=[\n\9Creates an immediately resolved Promise with the given value.\n\n\9```lua\n\9-- Example using Promise.resolve to deliver cached values:\n\9function getSomething(name)\n\9\9if cache[name] then\n\9\9\9return Promise.resolve(cache[name])\n\9\9else\n\9\9\9return Promise.new(function(resolve, reject)\n\9\9\9\9local thing = getTheThing()\n\9\9\9\9cache[name] = thing\n\n\9\9\9\9resolve(thing)\n\9\9\9end)\n\9\9end\n\9end\n\9```\n\n\9@param ... any\n\9@return Promise<...any>\n]=]\nfunction Promise.resolve(...)\n\9local length, values = pack(...)\n\9return Promise._new(debug.traceback(nil, 2), function(resolve)\n\9\9resolve(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Creates an immediately rejected Promise with the given value.\n\n\9:::caution\n\9Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.\n\9:::\n\n\9@param ... any\n\9@return Promise<...any>\n]=]\nfunction Promise.reject(...)\n\9local length, values = pack(...)\n\9return Promise._new(debug.traceback(nil, 2), function(_, reject)\n\9\9reject(unpack(values, 1, length))\n\9end)\nend\n\n--[[\n\9Runs a non-promise-returning function as a Promise with the\n  given arguments.\n]]\nfunction Promise._try(traceback, callback, ...)\n\9local valuesLength, values = pack(...)\n\n\9return Promise._new(traceback, function(resolve)\n\9\9resolve(callback(unpack(values, 1, valuesLength)))\n\9end)\nend\n\n--[=[\n\9Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.\n\n\9:::info\n\9`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.\n\9:::\n\n\9```lua\n\9Promise.try(function()\n\9\9return math.random(1, 2) == 1 and \"ok\" or error(\"Oh an error!\")\n\9end)\n\9\9:andThen(function(text)\n\9\9\9print(text)\n\9\9end)\n\9\9:catch(function(err)\n\9\9\9warn(\"Something went wrong\")\n\9\9end)\n\9```\n\n\9@param callback (...: T...) -> ...any\n\9@param ... T... -- Additional arguments passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.try(callback, ...)\n\9return Promise._try(debug.traceback(nil, 2), callback, ...)\nend\n\n--[[\n\9Returns a new promise that:\n\9\9* is resolved when all input promises resolve\n\9\9* is rejected if ANY input promises reject\n]]\nfunction Promise._all(traceback, promises, amount)\n\9if type(promises) ~= \"table\" then\n\9\9error(string.format(ERROR_NON_LIST, \"Promise.all\"), 3)\n\9end\n\n\9-- We need to check that each value is a promise here so that we can produce\n\9-- a proper error rather than a rejected promise with our error.\n\9for i, promise in pairs(promises) do\n\9\9if not Promise.is(promise) then\n\9\9\9error(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.all\", tostring(i)), 3)\n\9\9end\n\9end\n\n\9-- If there are no values then return an already resolved promise.\n\9if #promises == 0 or amount == 0 then\n\9\9return Promise.resolve({})\n\9end\n\n\9return Promise._new(traceback, function(resolve, reject, onCancel)\n\9\9-- An array to contain our resolved values from the given promises.\n\9\9local resolvedValues = {}\n\9\9local newPromises = {}\n\n\9\9-- Keep a count of resolved promises because just checking the resolved\n\9\9-- values length wouldn't account for promises that resolve with nil.\n\9\9local resolvedCount = 0\n\9\9local rejectedCount = 0\n\9\9local done = false\n\n\9\9local function cancel()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end\n\n\9\9-- Called when a single value is resolved and resolves if all are done.\n\9\9local function resolveOne(i, ...)\n\9\9\9if done then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9resolvedCount = resolvedCount + 1\n\n\9\9\9if amount == nil then\n\9\9\9\9resolvedValues[i] = ...\n\9\9\9else\n\9\9\9\9resolvedValues[resolvedCount] = ...\n\9\9\9end\n\n\9\9\9if resolvedCount >= (amount or #promises) then\n\9\9\9\9done = true\n\9\9\9\9resolve(resolvedValues)\n\9\9\9\9cancel()\n\9\9\9end\n\9\9end\n\n\9\9onCancel(cancel)\n\n\9\9-- We can assume the values inside `promises` are all promises since we\n\9\9-- checked above.\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:andThen(function(...)\n\9\9\9\9resolveOne(i, ...)\n\9\9\9end, function(...)\n\9\9\9\9rejectedCount = rejectedCount + 1\n\n\9\9\9\9if amount == nil or #promises - rejectedCount < amount then\n\9\9\9\9\9cancel()\n\9\9\9\9\9done = true\n\n\9\9\9\9\9reject(...)\n\9\9\9\9end\n\9\9\9end)\n\9\9end\n\n\9\9if done then\n\9\9\9cancel()\n\9\9end\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new promise that:\n\9* is resolved after all input promises resolve.\n\9* is rejected if *any* input promises reject.\n\n\9:::info\n\9Only the first return value from each promise will be present in the resulting array.\n\9:::\n\n\9After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.all(promises)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<{T}>\n]=]\nfunction Promise.all(promises)\n\9return Promise._all(debug.traceback(nil, 2), promises)\nend\n\n--[=[\n\9Folds an array of values or promises into a single value. The array is traversed sequentially.\n\n\9The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.\n\n\9The folding will stop at the first rejection encountered.\n\9```lua\n\9local basket = {\"blueberry\", \"melon\", \"pear\", \"melon\"}\n\9Promise.fold(basket, function(cost, fruit)\n\9\9if fruit == \"blueberry\" then\n\9\9\9return cost -- blueberries are free!\n\9\9else\n\9\9\9-- call a function that returns a promise with the fruit price\n\9\9\9return fetchPrice(fruit):andThen(function(fruitCost)\n\9\9\9\9return cost + fruitCost\n\9\9\9end)\n\9\9end\n\9end, 0)\n\9```\n\n\9@since v3.1.0\n\9@param list {T | Promise<T>}\n\9@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>\n\9@param initialValue U\n]=]\nfunction Promise.fold(list, reducer, initialValue)\n\9assert(type(list) == \"table\", \"Bad argument #1 to Promise.fold: must be a table\")\n\9assert(isCallable(reducer), \"Bad argument #2 to Promise.fold: must be a function\")\n\n\9local accumulator = Promise.resolve(initialValue)\n\9return Promise.each(list, function(resolvedElement, i)\n\9\9accumulator = accumulator:andThen(function(previousValueResolved)\n\9\9\9return reducer(previousValueResolved, resolvedElement, i)\n\9\9end)\n\9end):andThen(function()\n\9\9return accumulator\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\9`count` 0 results in an empty array. The resultant array will never have more than `count` elements.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve\n\9```\n\n\9@param promises {Promise<T>}\n\9@param count number\n\9@return Promise<{T}>\n]=]\nfunction Promise.some(promises, count)\n\9assert(type(count) == \"number\", \"Bad argument #2 to Promise.some: must be a number\")\n\n\9return Promise._all(debug.traceback(nil, 2), promises, count)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\9Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<T>\n]=]\nfunction Promise.any(promises)\n\9return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)\n\9\9return values[1]\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.allSettled(promises)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<{Status}>\n]=]\nfunction Promise.allSettled(promises)\n\9if type(promises) ~= \"table\" then\n\9\9error(string.format(ERROR_NON_LIST, \"Promise.allSettled\"), 2)\n\9end\n\n\9-- We need to check that each value is a promise here so that we can produce\n\9-- a proper error rather than a rejected promise with our error.\n\9for i, promise in pairs(promises) do\n\9\9if not Promise.is(promise) then\n\9\9\9error(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.allSettled\", tostring(i)), 2)\n\9\9end\n\9end\n\n\9-- If there are no values then return an already resolved promise.\n\9if #promises == 0 then\n\9\9return Promise.resolve({})\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9-- An array to contain our resolved values from the given promises.\n\9\9local fates = {}\n\9\9local newPromises = {}\n\n\9\9-- Keep a count of resolved promises because just checking the resolved\n\9\9-- values length wouldn't account for promises that resolve with nil.\n\9\9local finishedCount = 0\n\n\9\9-- Called when a single value is resolved and resolves if all are done.\n\9\9local function resolveOne(i, ...)\n\9\9\9finishedCount = finishedCount + 1\n\n\9\9\9fates[i] = ...\n\n\9\9\9if finishedCount >= #promises then\n\9\9\9\9resolve(fates)\n\9\9\9end\n\9\9end\n\n\9\9onCancel(function()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end)\n\n\9\9-- We can assume the values inside `promises` are all promises since we\n\9\9-- checked above.\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:finally(function(...)\n\9\9\9\9resolveOne(i, ...)\n\9\9\9end)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.\n\n\9:::warning\n\9If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.\n\n\9If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.\n\9:::\n\n\9All other Promises that don't win the race will be cancelled if they have no other consumers.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.race(promises) -- Only returns 1st value to resolve or reject\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<T>\n]=]\nfunction Promise.race(promises)\n\9assert(type(promises) == \"table\", string.format(ERROR_NON_LIST, \"Promise.race\"))\n\n\9for i, promise in pairs(promises) do\n\9\9assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.race\", tostring(i)))\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\9\9local newPromises = {}\n\9\9local finished = false\n\n\9\9local function cancel()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end\n\n\9\9local function finalize(callback)\n\9\9\9return function(...)\n\9\9\9\9cancel()\n\9\9\9\9finished = true\n\9\9\9\9return callback(...)\n\9\9\9end\n\9\9end\n\n\9\9if onCancel(finalize(reject)) then\n\9\9\9return\n\9\9end\n\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))\n\9\9end\n\n\9\9if finished then\n\9\9\9cancel()\n\9\9end\n\9end)\nend\n\n--[=[\n\9Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.\n\n\9If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item\n\9in the array.\n\n\9:::info\n\9`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.\n\n\9But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.\n\n\9The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.\n\9:::\n\n\9```lua\n\9Promise.each({\n\9\9\"foo\",\n\9\9\"bar\",\n\9\9\"baz\",\n\9\9\"qux\"\n\9}, function(value, index)\n\9\9return Promise.delay(1):andThen(function()\n\9\9print((\"%d) Got %s!\"):format(index, value))\n\9\9end)\n\9end)\n\n\9--[[\n\9\9(1 second passes)\n\9\9> 1) Got foo!\n\9\9(1 second passes)\n\9\9> 2) Got bar!\n\9\9(1 second passes)\n\9\9> 3) Got baz!\n\9\9(1 second passes)\n\9\9> 4) Got qux!\n\9]]\n\9```\n\n\9If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.\n\n\9If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.\n\n\9If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.\n\n\9Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.\n\n\9If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:\n\9- Iteration will not continue.\n\9- Any Promises within the array of values will now be cancelled if they have no other consumers.\n\9- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.\n\n\9@since 3.0.0\n\9@param list {T | Promise<T>}\n\9@param predicate (value: T, index: number) -> U | Promise<U>\n\9@return Promise<{U}>\n]=]\nfunction Promise.each(list, predicate)\n\9assert(type(list) == \"table\", string.format(ERROR_NON_LIST, \"Promise.each\"))\n\9assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, \"Promise.each\"))\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\9\9local results = {}\n\9\9local promisesToCancel = {}\n\n\9\9local cancelled = false\n\n\9\9local function cancel()\n\9\9\9for _, promiseToCancel in ipairs(promisesToCancel) do\n\9\9\9\9promiseToCancel:cancel()\n\9\9\9end\n\9\9end\n\n\9\9onCancel(function()\n\9\9\9cancelled = true\n\n\9\9\9cancel()\n\9\9end)\n\n\9\9-- We need to preprocess the list of values and look for Promises.\n\9\9-- If we find some, we must register our andThen calls now, so that those Promises have a consumer\n\9\9-- from us registered. If we don't do this, those Promises might get cancelled by something else\n\9\9-- before we get to them in the series because it's not possible to tell that we plan to use it\n\9\9-- unless we indicate it here.\n\n\9\9local preprocessedList = {}\n\n\9\9for index, value in ipairs(list) do\n\9\9\9if Promise.is(value) then\n\9\9\9\9if value:getStatus() == Promise.Status.Cancelled then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(Error.new({\n\9\9\9\9\9\9error = \"Promise is cancelled\",\n\9\9\9\9\9\9kind = Error.Kind.AlreadyCancelled,\n\9\9\9\9\9\9context = string.format(\n\9\9\9\9\9\9\9\"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\\n\\nThat Promise was created at:\\n\\n%s\",\n\9\9\9\9\9\9\9index,\n\9\9\9\9\9\9\9value._source\n\9\9\9\9\9\9),\n\9\9\9\9\9}))\n\9\9\9\9elseif value:getStatus() == Promise.Status.Rejected then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(select(2, value:await()))\n\9\9\9\9end\n\n\9\9\9\9-- Chain a new Promise from this one so we only cancel ours\n\9\9\9\9local ourPromise = value:andThen(function(...)\n\9\9\9\9\9return ...\n\9\9\9\9end)\n\n\9\9\9\9table.insert(promisesToCancel, ourPromise)\n\9\9\9\9preprocessedList[index] = ourPromise\n\9\9\9else\n\9\9\9\9preprocessedList[index] = value\n\9\9\9end\n\9\9end\n\n\9\9for index, value in ipairs(preprocessedList) do\n\9\9\9if Promise.is(value) then\n\9\9\9\9local success\n\9\9\9\9success, value = value:await()\n\n\9\9\9\9if not success then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(value)\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9if cancelled then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9local predicatePromise = Promise.resolve(predicate(value, index))\n\n\9\9\9table.insert(promisesToCancel, predicatePromise)\n\n\9\9\9local success, result = predicatePromise:await()\n\n\9\9\9if not success then\n\9\9\9\9cancel()\n\9\9\9\9return reject(result)\n\9\9\9end\n\n\9\9\9results[index] = result\n\9\9end\n\n\9\9resolve(results)\n\9end)\nend\n\n--[=[\n\9Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.\n\n\9@param object any\n\9@return boolean -- `true` if the given `object` is a Promise.\n]=]\nfunction Promise.is(object)\n\9if type(object) ~= \"table\" then\n\9\9return false\n\9end\n\n\9local objectMetatable = getmetatable(object)\n\n\9if objectMetatable == Promise then\n\9\9-- The Promise came from this library.\n\9\9return true\n\9elseif objectMetatable == nil then\n\9\9-- No metatable, but we should still chain onto tables with andThen methods\n\9\9return isCallable(object.andThen)\n\9elseif\n\9\9type(objectMetatable) == \"table\"\n\9\9and type(rawget(objectMetatable, \"__index\")) == \"table\"\n\9\9and isCallable(rawget(rawget(objectMetatable, \"__index\"), \"andThen\"))\n\9then\n\9\9-- Maybe this came from a different or older Promise library.\n\9\9return true\n\9end\n\n\9return false\nend\n\n--[=[\n\9Wraps a function that yields into one that returns a Promise.\n\n\9Any errors that occur while executing the function will be turned into rejections.\n\n\9:::info\n\9`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.\n\9:::\n\n\9```lua\n\9local sleep = Promise.promisify(wait)\n\n\9sleep(1):andThen(print)\n\9```\n\n\9```lua\n\9local isPlayerInGroup = Promise.promisify(function(player, groupId)\n\9\9return player:IsInGroup(groupId)\n\9end)\n\9```\n\n\9@param callback (...: any) -> ...any\n\9@return (...: any) -> Promise\n]=]\nfunction Promise.promisify(callback)\n\9return function(...)\n\9\9return Promise._try(debug.traceback(nil, 2), callback, ...)\n\9end\nend\n\n--[=[\n\9Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.\n\n\9This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.\n\n\9:::warning\n\9Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.\n\9:::\n\n\9```lua\n\9\9Promise.delay(5):andThenCall(print, \"This prints after 5 seconds\")\n\9```\n\n\9@function delay\n\9@within Promise\n\9@param seconds number\n\9@return Promise<number>\n]=]\ndo\n\9-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert\n\n\9-- the initial node in the linked list\n\9local first\n\9local connection\n\n\9function Promise.delay(seconds)\n\9\9assert(type(seconds) == \"number\", \"Bad argument #1 to Promise.delay, must be a number.\")\n\9\9-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.\n\9\9-- This mirrors the behavior of wait()\n\9\9if not (seconds >= 1 / 60) or seconds == math.huge then\n\9\9\9seconds = 1 / 60\n\9\9end\n\n\9\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9\9local startTime = Promise._getTime()\n\9\9\9local endTime = startTime + seconds\n\n\9\9\9local node = {\n\9\9\9\9resolve = resolve,\n\9\9\9\9startTime = startTime,\n\9\9\9\9endTime = endTime,\n\9\9\9}\n\n\9\9\9if connection == nil then -- first is nil when connection is nil\n\9\9\9\9first = node\n\9\9\9\9connection = Promise._timeEvent:Connect(function()\n\9\9\9\9\9local threadStart = Promise._getTime()\n\n\9\9\9\9\9while first ~= nil and first.endTime < threadStart do\n\9\9\9\9\9\9local current = first\n\9\9\9\9\9\9first = current.next\n\n\9\9\9\9\9\9if first == nil then\n\9\9\9\9\9\9\9connection:Disconnect()\n\9\9\9\9\9\9\9connection = nil\n\9\9\9\9\9\9else\n\9\9\9\9\9\9\9first.previous = nil\n\9\9\9\9\9\9end\n\n\9\9\9\9\9\9current.resolve(Promise._getTime() - current.startTime)\n\9\9\9\9\9end\n\9\9\9\9end)\n\9\9\9else -- first is non-nil\n\9\9\9\9if first.endTime < endTime then -- if `node` should be placed after `first`\n\9\9\9\9\9-- we will insert `node` between `current` and `next`\n\9\9\9\9\9-- (i.e. after `current` if `next` is nil)\n\9\9\9\9\9local current = first\n\9\9\9\9\9local next = current.next\n\n\9\9\9\9\9while next ~= nil and next.endTime < endTime do\n\9\9\9\9\9\9current = next\n\9\9\9\9\9\9next = current.next\n\9\9\9\9\9end\n\n\9\9\9\9\9-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)\n\9\9\9\9\9current.next = node\n\9\9\9\9\9node.previous = current\n\n\9\9\9\9\9if next ~= nil then\n\9\9\9\9\9\9node.next = next\n\9\9\9\9\9\9next.previous = node\n\9\9\9\9\9end\n\9\9\9\9else\n\9\9\9\9\9-- set `node` to `first`\n\9\9\9\9\9node.next = first\n\9\9\9\9\9first.previous = node\n\9\9\9\9\9first = node\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9onCancel(function()\n\9\9\9\9-- remove node from queue\n\9\9\9\9local next = node.next\n\n\9\9\9\9if first == node then\n\9\9\9\9\9if next == nil then -- if `node` is the first and last\n\9\9\9\9\9\9connection:Disconnect()\n\9\9\9\9\9\9connection = nil\n\9\9\9\9\9else -- if `node` is `first` and not the last\n\9\9\9\9\9\9next.previous = nil\n\9\9\9\9\9end\n\9\9\9\9\9first = next\n\9\9\9\9else\n\9\9\9\9\9local previous = node.previous\n\9\9\9\9\9-- since `node` is not `first`, then we know `previous` is non-nil\n\9\9\9\9\9previous.next = next\n\n\9\9\9\9\9if next ~= nil then\n\9\9\9\9\9\9next.previous = previous\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end)\n\9\9end)\n\9end\nend\n\n--[=[\n\9Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.\n\n\9Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].\n\n\9```lua\n\9getSomething():timeout(5):andThen(function(something)\n\9\9-- got something and it only took at max 5 seconds\n\9end):catch(function(e)\n\9\9-- Either getting something failed or the time was exceeded.\n\n\9\9if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then\n\9\9\9warn(\"Operation timed out!\")\n\9\9else\n\9\9\9warn(\"Operation encountered an error!\")\n\9\9end\n\9end)\n\9```\n\n\9Sugar for:\n\n\9```lua\n\9Promise.race({\n\9\9Promise.delay(seconds):andThen(function()\n\9\9\9return Promise.reject(\n\9\9\9\9rejectionValue == nil\n\9\9\9\9and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })\n\9\9\9\9or rejectionValue\n\9\9\9)\n\9\9end),\n\9\9promise\n\9})\n\9```\n\n\9@param seconds number\n\9@param rejectionValue? any -- The value to reject with if the timeout is reached\n\9@return Promise\n]=]\nfunction Promise.prototype:timeout(seconds, rejectionValue)\n\9local traceback = debug.traceback(nil, 2)\n\n\9return Promise.race({\n\9\9Promise.delay(seconds):andThen(function()\n\9\9\9return Promise.reject(rejectionValue == nil and Error.new({\n\9\9\9\9kind = Error.Kind.TimedOut,\n\9\9\9\9error = \"Timed out\",\n\9\9\9\9context = string.format(\n\9\9\9\9\9\"Timeout of %d seconds exceeded.\\n:timeout() called at:\\n\\n%s\",\n\9\9\9\9\9seconds,\n\9\9\9\9\9traceback\n\9\9\9\9),\n\9\9\9}) or rejectionValue)\n\9\9end),\n\9\9self,\n\9})\nend\n\n--[=[\n\9Returns the current Promise status.\n\n\9@return Status\n]=]\nfunction Promise.prototype:getStatus()\n\9return self._status\nend\n\n--[[\n\9Creates a new promise that receives the result of this promise.\n\n\9The given callbacks are invoked depending on that result.\n]]\nfunction Promise.prototype:_andThen(traceback, successHandler, failureHandler)\n\9self._unhandledRejection = false\n\n\9-- Create a new promise to follow this part of the chain\n\9return Promise._new(traceback, function(resolve, reject)\n\9\9-- Our default callbacks just pass values onto the next promise.\n\9\9-- This lets success and failure cascade correctly!\n\n\9\9local successCallback = resolve\n\9\9if successHandler then\n\9\9\9successCallback = createAdvancer(traceback, successHandler, resolve, reject)\n\9\9end\n\n\9\9local failureCallback = reject\n\9\9if failureHandler then\n\9\9\9failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)\n\9\9end\n\n\9\9if self._status == Promise.Status.Started then\n\9\9\9-- If we haven't resolved yet, put ourselves into the queue\n\9\9\9table.insert(self._queuedResolve, successCallback)\n\9\9\9table.insert(self._queuedReject, failureCallback)\n\9\9elseif self._status == Promise.Status.Resolved then\n\9\9\9-- This promise has already resolved! Trigger success immediately.\n\9\9\9successCallback(unpack(self._values, 1, self._valuesLength))\n\9\9elseif self._status == Promise.Status.Rejected then\n\9\9\9-- This promise died a terrible death! Trigger failure immediately.\n\9\9\9failureCallback(unpack(self._values, 1, self._valuesLength))\n\9\9elseif self._status == Promise.Status.Cancelled then\n\9\9\9-- We don't want to call the success handler or the failure handler,\n\9\9\9-- we just reject this promise outright.\n\9\9\9reject(Error.new({\n\9\9\9\9error = \"Promise is cancelled\",\n\9\9\9\9kind = Error.Kind.AlreadyCancelled,\n\9\9\9\9context = \"Promise created at\\n\\n\" .. traceback,\n\9\9\9}))\n\9\9end\n\9end, self)\nend\n\n--[=[\n\9Chains onto an existing Promise and returns a new Promise.\n\n\9:::warning\n\9Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\9:::\n\n\9Return a Promise from the success or failure handler and it will be chained onto.\n\n\9@param successHandler (...: any) -> ...any\n\9@param failureHandler? (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:andThen(successHandler, failureHandler)\n\9assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\9assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\n\9return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)\nend\n\n--[=[\n\9Shorthand for `Promise:andThen(nil, failureHandler)`.\n\n\9Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.\n\n\9:::warning\n\9Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\9:::\n\n\n\9@param failureHandler (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:catch(failureHandler)\n\9assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:catch\"))\n\9return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)\nend\n\n--[=[\n\9Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.\n\n\9```lua\n\9\9getTheValue()\n\9\9:tap(print)\n\9\9:andThen(function(theValue)\n\9\9\9print(\"Got\", theValue, \"even though print returns nil!\")\n\9\9end)\n\9```\n\n\9If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.\n\n\9@param tapHandler (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:tap(tapHandler)\n\9assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, \"Promise:tap\"))\n\9return self:_andThen(debug.traceback(nil, 2), function(...)\n\9\9local callbackReturn = tapHandler(...)\n\n\9\9if Promise.is(callbackReturn) then\n\9\9\9local length, values = pack(...)\n\9\9\9return callbackReturn:andThen(function()\n\9\9\9\9return unpack(values, 1, length)\n\9\9\9end)\n\9\9end\n\n\9\9return ...\n\9end)\nend\n\n--[=[\n\9Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.\n\n\9```lua\n\9\9promise:andThenCall(someFunction, \"some\", \"arguments\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:andThen(function()\n\9\9return someFunction(\"some\", \"arguments\")\n\9\9end)\n\9```\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:andThenCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:andThenCall\"))\n\9local length, values = pack(...)\n\9return self:_andThen(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:andThenReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:andThen(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9:::caution\n\9Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].\n\9:::\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:andThenReturn(...)\n\9local length, values = pack(...)\n\9return self:_andThen(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end)\nend\n\n--[=[\n\9Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.\n\n\9Cancellations will propagate upwards and downwards through chained promises.\n\n\9Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.\n\n\9```lua\n\9\9promise:cancel()\n\9```\n]=]\nfunction Promise.prototype:cancel()\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Cancelled\n\n\9if self._cancellationHook then\n\9\9self._cancellationHook()\n\9end\n\n\9if self._parent then\n\9\9self._parent:_consumerCancelled(self)\n\9end\n\n\9for child in pairs(self._consumers) do\n\9\9child:cancel()\n\9end\n\n\9self:_finalize()\nend\n\n--[[\n\9Used to decrease the number of consumers by 1, and if there are no more,\n\9cancel this promise.\n]]\nfunction Promise.prototype:_consumerCancelled(consumer)\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._consumers[consumer] = nil\n\n\9if next(self._consumers) == nil then\n\9\9self:cancel()\n\9end\nend\n\n--[[\n\9Used to set a handler for when the promise resolves, rejects, or is\n\9cancelled. Returns a new promise chained from this promise.\n]]\nfunction Promise.prototype:_finally(traceback, finallyHandler, onlyOk)\n\9if not onlyOk then\n\9\9self._unhandledRejection = false\n\9end\n\n\9-- Return a promise chained off of this promise\n\9return Promise._new(traceback, function(resolve, reject)\n\9\9local finallyCallback = resolve\n\9\9if finallyHandler then\n\9\9\9finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)\n\9\9end\n\n\9\9if onlyOk then\n\9\9\9local callback = finallyCallback\n\9\9\9finallyCallback = function(...)\n\9\9\9\9if self._status == Promise.Status.Rejected then\n\9\9\9\9\9return resolve(self)\n\9\9\9\9end\n\n\9\9\9\9return callback(...)\n\9\9\9end\n\9\9end\n\n\9\9if self._status == Promise.Status.Started then\n\9\9\9-- The promise is not settled, so queue this.\n\9\9\9table.insert(self._queuedFinally, finallyCallback)\n\9\9else\n\9\9\9-- The promise already settled or was cancelled, run the callback now.\n\9\9\9finallyCallback(self._status)\n\9\9end\n\9end, self)\nend\n\n--[=[\n\9Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.\n\n\9Returns a new promise chained from this promise.\n\n\9:::caution\n\9If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.\n\9:::\n\n\9```lua\n\9local thing = createSomething()\n\n\9doSomethingWith(thing)\n\9\9:andThen(function()\n\9\9\9print(\"It worked!\")\n\9\9\9-- do something..\n\9\9end)\n\9\9:catch(function()\n\9\9\9warn(\"Oh no it failed!\")\n\9\9end)\n\9\9:finally(function()\n\9\9\9-- either way, destroy thing\n\n\9\9\9thing:Destroy()\n\9\9end)\n\n\9```\n\n\9@param finallyHandler (status: Status) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:finally(finallyHandler)\n\9assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, \"Promise:finally\"))\n\9return self:_finally(debug.traceback(nil, 2), finallyHandler)\nend\n\n--[=[\n\9Same as `andThenCall`, except for `finally`.\n\n\9Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:finallyCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:finallyCall\"))\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:finallyReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:finally(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:finallyReturn(...)\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end)\nend\n\n--[=[\n\9Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.\n\n\9:::caution\n\9`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href=\"/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence\">this example</a>). You should use `andThen` instead if you only care about the Resolved case.\n\9:::\n\n\9:::warning\n\9Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.\n\9:::\n\n\9Returns a new promise chained from this promise.\n\n\9@param doneHandler (status: Status) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:done(doneHandler)\n\9assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, \"Promise:done\"))\n\9return self:_finally(debug.traceback(nil, 2), doneHandler, true)\nend\n\n--[=[\n\9Same as `andThenCall`, except for `done`.\n\n\9Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:doneCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:doneCall\"))\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end, true)\nend\n\n--[=[\n\9Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:doneReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:done(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:doneReturn(...)\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end, true)\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.\n\n\9@yields\n\9@return Status -- The Status representing the fate of the Promise\n\9@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:awaitStatus()\n\9self._unhandledRejection = false\n\n\9if self._status == Promise.Status.Started then\n\9\9local bindable = Instance.new(\"BindableEvent\")\n\n\9\9self:finally(function()\n\9\9\9bindable:Fire()\n\9\9end)\n\n\9\9bindable.Event:Wait()\n\9\9bindable:Destroy()\n\9end\n\n\9if self._status == Promise.Status.Resolved then\n\9\9return self._status, unpack(self._values, 1, self._valuesLength)\n\9elseif self._status == Promise.Status.Rejected then\n\9\9return self._status, unpack(self._values, 1, self._valuesLength)\n\9end\n\n\9return self._status\nend\n\nlocal function awaitHelper(status, ...)\n\9return status == Promise.Status.Resolved, ...\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.\n\n\9:::caution\n\9If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.\n\9:::\n\n\9```lua\n\9\9local worked, value = getTheValue():await()\n\n\9if worked then\n\9\9print(\"got\", value)\n\9else\n\9\9warn(\"it failed\")\n\9end\n\9```\n\n\9@yields\n\9@return boolean -- `true` if the Promise successfully resolved\n\9@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:await()\n\9return awaitHelper(self:awaitStatus())\nend\n\nlocal function expectHelper(status, ...)\n\9if status ~= Promise.Status.Resolved then\n\9\9error((...) == nil and \"Expected Promise rejected with no value.\" or (...), 3)\n\9end\n\n\9return ...\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.\n\n\9```lua\n\9local worked = pcall(function()\n\9\9print(\"got\", getTheValue():expect())\n\9end)\n\n\9if not worked then\n\9\9warn(\"it failed\")\n\9end\n\9```\n\n\9This is essentially sugar for:\n\n\9```lua\n\9select(2, assert(promise:await()))\n\9```\n\n\9**Errors** if the Promise rejects or gets cancelled.\n\n\9@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.\n\9@yields\n\9@return ...any -- The values the Promise resolved with.\n]=]\nfunction Promise.prototype:expect()\n\9return expectHelper(self:awaitStatus())\nend\n\n-- Backwards compatibility\nPromise.prototype.awaitValue = Promise.prototype.expect\n\n--[[\n\9Intended for use in tests.\n\n\9Similar to await(), but instead of yielding if the promise is unresolved,\n\9_unwrap will throw. This indicates an assumption that a promise has\n\9resolved.\n]]\nfunction Promise.prototype:_unwrap()\n\9if self._status == Promise.Status.Started then\n\9\9error(\"Promise has not resolved or rejected.\", 2)\n\9end\n\n\9local success = self._status == Promise.Status.Resolved\n\n\9return success, unpack(self._values, 1, self._valuesLength)\nend\n\nfunction Promise.prototype:_resolve(...)\n\9if self._status ~= Promise.Status.Started then\n\9\9if Promise.is((...)) then\n\9\9\9(...):_consumerCancelled(self)\n\9\9end\n\9\9return\n\9end\n\n\9-- If the resolved value was a Promise, we chain onto it!\n\9if Promise.is((...)) then\n\9\9-- Without this warning, arguments sometimes mysteriously disappear\n\9\9if select(\"#\", ...) > 1 then\n\9\9\9local message = string.format(\n\9\9\9\9\"When returning a Promise from andThen, extra arguments are \" .. \"discarded! See:\\n\\n%s\",\n\9\9\9\9self._source\n\9\9\9)\n\9\9\9warn(message)\n\9\9end\n\n\9\9local chainedPromise = ...\n\n\9\9local promise = chainedPromise:andThen(function(...)\n\9\9\9self:_resolve(...)\n\9\9end, function(...)\n\9\9\9local maybeRuntimeError = chainedPromise._values[1]\n\n\9\9\9-- Backwards compatibility < v2\n\9\9\9if chainedPromise._error then\n\9\9\9\9maybeRuntimeError = Error.new({\n\9\9\9\9\9error = chainedPromise._error,\n\9\9\9\9\9kind = Error.Kind.ExecutionError,\n\9\9\9\9\9context = \"[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]\",\n\9\9\9\9})\n\9\9\9end\n\n\9\9\9if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then\n\9\9\9\9return self:_reject(maybeRuntimeError:extend({\n\9\9\9\9\9error = \"This Promise was chained to a Promise that errored.\",\n\9\9\9\9\9trace = \"\",\n\9\9\9\9\9context = string.format(\n\9\9\9\9\9\9\"The Promise at:\\n\\n%s\\n...Rejected because it was chained to the following Promise, which encountered an error:\\n\",\n\9\9\9\9\9\9self._source\n\9\9\9\9\9),\n\9\9\9\9}))\n\9\9\9end\n\n\9\9\9self:_reject(...)\n\9\9end)\n\n\9\9if promise._status == Promise.Status.Cancelled then\n\9\9\9self:cancel()\n\9\9elseif promise._status == Promise.Status.Started then\n\9\9\9-- Adopt ourselves into promise for cancellation propagation.\n\9\9\9self._parent = promise\n\9\9\9promise._consumers[self] = true\n\9\9end\n\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Resolved\n\9self._valuesLength, self._values = pack(...)\n\n\9-- We assume that these callbacks will not throw errors.\n\9for _, callback in ipairs(self._queuedResolve) do\n\9\9coroutine.wrap(callback)(...)\n\9end\n\n\9self:_finalize()\nend\n\nfunction Promise.prototype:_reject(...)\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Rejected\n\9self._valuesLength, self._values = pack(...)\n\n\9-- If there are any rejection handlers, call those!\n\9if not isEmpty(self._queuedReject) then\n\9\9-- We assume that these callbacks will not throw errors.\n\9\9for _, callback in ipairs(self._queuedReject) do\n\9\9\9coroutine.wrap(callback)(...)\n\9\9end\n\9else\n\9\9-- At this point, no one was able to observe the error.\n\9\9-- An error handler might still be attached if the error occurred\n\9\9-- synchronously. We'll wait one tick, and if there are still no\n\9\9-- observers, then we should put a message in the console.\n\n\9\9local err = tostring((...))\n\n\9\9coroutine.wrap(function()\n\9\9\9Promise._timeEvent:Wait()\n\n\9\9\9-- Someone observed the error, hooray!\n\9\9\9if not self._unhandledRejection then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9-- Build a reasonable message\n\9\9\9local message = string.format(\"Unhandled Promise rejection:\\n\\n%s\\n\\n%s\", err, self._source)\n\n\9\9\9for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do\n\9\9\9\9task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))\n\9\9\9end\n\n\9\9\9if Promise.TEST then\n\9\9\9\9-- Don't spam output when we're running tests.\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9warn(message)\n\9\9end)()\n\9end\n\n\9self:_finalize()\nend\n\n--[[\n\9Calls any :finally handlers. We need this to be a separate method and\n\9queue because we must call all of the finally callbacks upon a success,\n\9failure, *and* cancellation.\n]]\nfunction Promise.prototype:_finalize()\n\9for _, callback in ipairs(self._queuedFinally) do\n\9\9-- Purposefully not passing values to callbacks here, as it could be the\n\9\9-- resolved values, or rejected errors. If the developer needs the values,\n\9\9-- they should use :andThen or :catch explicitly.\n\9\9coroutine.wrap(callback)(self._status)\n\9end\n\n\9self._queuedFinally = nil\n\9self._queuedReject = nil\n\9self._queuedResolve = nil\n\n\9-- Clear references to other Promises to allow gc\n\9if not Promise.TEST then\n\9\9self._parent = nil\n\9\9self._consumers = nil\n\9end\nend\n\n--[=[\n\9Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.\n\n\9```lua\n\9doSomething()\n\9\9:now()\n\9\9:andThen(function(value)\n\9\9\9print(\"Got\", value, \"synchronously.\")\n\9\9end)\n\9```\n\n\9If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].\n\n\9@param rejectionValue? any -- The value to reject with if the Promise isn't resolved\n\9@return Promise\n]=]\nfunction Promise.prototype:now(rejectionValue)\n\9local traceback = debug.traceback(nil, 2)\n\9if self._status == Promise.Status.Resolved then\n\9\9return self:_andThen(traceback, function(...)\n\9\9\9return ...\n\9\9end)\n\9else\n\9\9return Promise.reject(rejectionValue == nil and Error.new({\n\9\9\9kind = Error.Kind.NotResolvedInTime,\n\9\9\9error = \"This Promise was not resolved in time for :now()\",\n\9\9\9context = \":now() was called at:\\n\\n\" .. traceback,\n\9\9}) or rejectionValue)\n\9end\nend\n\n--[=[\n\9Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.\n\n\9If the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\9```lua\n\9local function canFail(a, b, c)\n\9\9return Promise.new(function(resolve, reject)\n\9\9\9-- do something that can fail\n\n\9\9\9local failed, thing = doSomethingThatCanFail(a, b, c)\n\n\9\9\9if failed then\n\9\9\9\9reject(\"it failed\")\n\9\9\9else\n\9\9\9\9resolve(thing)\n\9\9\9end\n\9\9end)\n\9end\n\n\9local MAX_RETRIES = 10\n\9local value = Promise.retry(canFail, MAX_RETRIES, \"foo\", \"bar\", \"baz\") -- args to send to canFail\n\9```\n\n\9@since 3.0.0\n\9@param callback (...: P) -> Promise<T>\n\9@param times number\n\9@param ...? P\n]=]\nfunction Promise.retry(callback, times, ...)\n\9assert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\9assert(type(times) == \"number\", \"Parameter #2 to Promise.retry must be a number\")\n\n\9local args, length = { ... }, select(\"#\", ...)\n\n\9return Promise.resolve(callback(...)):catch(function(...)\n\9\9if times > 0 then\n\9\9\9return Promise.retry(callback, times - 1, unpack(args, 1, length))\n\9\9else\n\9\9\9return Promise.reject(...)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each\n\9retry, until the returned Promise resolves.\n\n\9If the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\9@since v3.2.0\n\9@param callback (...: P) -> Promise<T>\n\9@param times number\n\9@param seconds number\n\9@param ...? P\n]=]\nfunction Promise.retryWithDelay(callback, times, seconds, ...)\n\9assert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\9assert(type(times) == \"number\", \"Parameter #2 (times) to Promise.retry must be a number\")\n\9assert(type(seconds) == \"number\", \"Parameter #3 (seconds) to Promise.retry must be a number\")\n\n\9local args, length = { ... }, select(\"#\", ...)\n\n\9return Promise.resolve(callback(...)):catch(function(...)\n\9\9if times > 0 then\n\9\9\9Promise.delay(seconds):await()\n\n\9\9\9return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))\n\9\9else\n\9\9\9return Promise.reject(...)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Converts an event into a Promise which resolves the next time the event fires.\n\n\9The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.\n\n\9The Promise will resolve with the event arguments.\n\n\9:::tip\n\9This function will work given any object with a `Connect` method. This includes all Roblox events.\n\9:::\n\n\9```lua\n\9-- Creates a Promise which only resolves when `somePart` is touched\n\9-- by a part named `\"Something specific\"`.\n\9return Promise.fromEvent(somePart.Touched, function(part)\n\9\9return part.Name == \"Something specific\"\n\9end)\n\9```\n\n\9@since 3.0.0\n\9@param event Event -- Any object with a `Connect` method. This includes all Roblox events.\n\9@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.\n\9@return Promise<P>\n]=]\nfunction Promise.fromEvent(event, predicate)\n\9predicate = predicate or function()\n\9\9return true\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9local connection\n\9\9local shouldDisconnect = false\n\n\9\9local function disconnect()\n\9\9\9connection:Disconnect()\n\9\9\9connection = nil\n\9\9end\n\n\9\9-- We use shouldDisconnect because if the callback given to Connect is called before\n\9\9-- Connect returns, connection will still be nil. This happens with events that queue up\n\9\9-- events when there's nothing connected, such as RemoteEvents\n\n\9\9connection = event:Connect(function(...)\n\9\9\9local callbackValue = predicate(...)\n\n\9\9\9if callbackValue == true then\n\9\9\9\9resolve(...)\n\n\9\9\9\9if connection then\n\9\9\9\9\9disconnect()\n\9\9\9\9else\n\9\9\9\9\9shouldDisconnect = true\n\9\9\9\9end\n\9\9\9elseif type(callbackValue) ~= \"boolean\" then\n\9\9\9\9error(\"Promise.fromEvent predicate should always return a boolean\")\n\9\9\9end\n\9\9end)\n\n\9\9if shouldDisconnect and connection then\n\9\9\9return disconnect()\n\9\9end\n\n\9\9onCancel(disconnect)\n\9end)\nend\n\n--[=[\n\9Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise\n\9is rejected, and the rejection is not observed with `:catch`.\n\n\9The callback is called with the actual promise that rejected, followed by the rejection values.\n\n\9@since v3.2.0\n\9@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.\n\9@return () -> () -- Function that unregisters the `callback` when called\n]=]\nfunction Promise.onUnhandledRejection(callback)\n\9table.insert(Promise._unhandledRejectionCallbacks, callback)\n\n\9return function()\n\9\9local index = table.find(Promise._unhandledRejectionCallbacks, callback)\n\n\9\9if index then\n\9\9\9table.remove(Promise._unhandledRejectionCallbacks, index)\n\9\9end\n\9end\nend\n\nreturn Promise\n", "bundle-ex.include.Promise"))(__env)
end)
__lua("RuntimeLib", "ModuleScript", "bundle-ex.include.RuntimeLib", "bundle-ex.include", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.RuntimeLib\")local script,require=_.script,_.require local Promise = require(script.Parent.Promise)\n\nlocal RunService = game:GetService(\"RunService\")\n\nlocal OUTPUT_PREFIX = \"roblox-ts: \"\nlocal NODE_MODULES = \"node_modules\"\nlocal DEFAULT_SCOPE = \"@rbxts\"\n\nlocal TS = {}\n\nTS.Promise = Promise\n\nlocal function isPlugin(context)\n\9return RunService:IsStudio() and context:FindFirstAncestorWhichIsA(\"Plugin\") ~= nil\nend\n\nfunction TS.getModule(context, scope, moduleName)\n\9-- legacy call signature\n\9if moduleName == nil then\n\9\9moduleName = scope\n\9\9scope = DEFAULT_SCOPE\n\9end\n\n\9-- ensure modules have fully replicated\n\9if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then\n\9\9game.Loaded:Wait()\n\9end\n\n\9local object = context\n\9repeat\n\9\9local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)\n\9\9if nodeModulesFolder then\n\9\9\9local scopeFolder = nodeModulesFolder:FindFirstChild(scope)\n\9\9\9if scopeFolder then\n\9\9\9\9local module = scopeFolder:FindFirstChild(moduleName)\n\9\9\9\9if module then\n\9\9\9\9\9return module\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9object = object.Parent\n\9until object == nil\n\n\9error(OUTPUT_PREFIX .. \"Could not find module: \" .. moduleName, 2)\nend\n\n-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library\nlocal currentlyLoading = {}\nlocal registeredLibraries = {}\n\nfunction TS.import(context, module, ...)\n\9for i = 1, select(\"#\", ...) do\n\9\9module = module:WaitForChild((select(i, ...)))\n\9end\n\n\9if module.ClassName ~= \"ModuleScript\" then\n\9\9error(OUTPUT_PREFIX .. \"Failed to import! Expected ModuleScript, got \" .. module.ClassName, 2)\n\9end\n\n\9currentlyLoading[context] = module\n\n\9-- Check to see if a case like this occurs:\n\9-- module -> Module1 -> Module2 -> module\n\n\9-- WHERE currentlyLoading[module] is Module1\n\9-- and currentlyLoading[Module1] is Module2\n\9-- and currentlyLoading[Module2] is module\n\n\9local currentModule = module\n\9local depth = 0\n\n\9while currentModule do\n\9\9depth = depth + 1\n\9\9currentModule = currentlyLoading[currentModule]\n\n\9\9if currentModule == module then\n\9\9\9local str = currentModule.Name -- Get the string traceback\n\n\9\9\9for _ = 1, depth do\n\9\9\9\9currentModule = currentlyLoading[currentModule]\n\9\9\9\9str = str .. \"  ⇒ \" .. currentModule.Name\n\9\9\9end\n\n\9\9\9error(OUTPUT_PREFIX .. \"Failed to import! Detected a circular dependency chain: \" .. str, 2)\n\9\9end\n\9end\n\n\9if not registeredLibraries[module] then\n\9\9if _G[module] then\n\9\9\9error(\n\9\9\9\9OUTPUT_PREFIX\n\9\9\9\9.. \"Invalid module access! Do you have multiple TS runtimes trying to import this? \"\n\9\9\9\9.. module:GetFullName(),\n\9\9\9\0092\n\9\9\9)\n\9\9end\n\n\9\9_G[module] = TS\n\9\9registeredLibraries[module] = true -- register as already loaded for subsequent calls\n\9end\n\n\9local data = require(module)\n\n\9if currentlyLoading[context] == module then -- Thread-safe cleanup!\n\9\9currentlyLoading[context] = nil\n\9end\n\n\9return data\nend\n\nfunction TS.instanceof(obj, class)\n\9-- custom Class.instanceof() check\n\9if type(class) == \"table\" and type(class.instanceof) == \"function\" then\n\9\9return class.instanceof(obj)\n\9end\n\n\9-- metatable check\n\9if type(obj) == \"table\" then\n\9\9obj = getmetatable(obj)\n\9\9while obj ~= nil do\n\9\9\9if obj == class then\n\9\9\9\9return true\n\9\9\9end\n\9\9\9local mt = getmetatable(obj)\n\9\9\9if mt then\n\9\9\9\9obj = mt.__index\n\9\9\9else\n\9\9\9\9obj = nil\n\9\9\9end\n\9\9end\n\9end\n\n\9return false\nend\n\nfunction TS.async(callback)\n\9return function(...)\n\9\9local n = select(\"#\", ...)\n\9\9local args = { ... }\n\9\9return Promise.new(function(resolve, reject)\n\9\9\9coroutine.wrap(function()\n\9\9\9\9local ok, result = pcall(callback, unpack(args, 1, n))\n\9\9\9\9if ok then\n\9\9\9\9\9resolve(result)\n\9\9\9\9else\n\9\9\9\9\9reject(result)\n\9\9\9\9end\n\9\9\9end)()\n\9\9end)\n\9end\nend\n\nfunction TS.await(promise)\n\9if not Promise.is(promise) then\n\9\9return promise\n\9end\n\n\9local status, value = promise:awaitStatus()\n\9if status == Promise.Status.Resolved then\n\9\9return value\n\9elseif status == Promise.Status.Rejected then\n\9\9error(value, 2)\n\9else\n\9\9error(\"The awaited Promise was cancelled\", 2)\n\9end\nend\n\nlocal SIGN = 2 ^ 31\nlocal COMPLEMENT = 2 ^ 32\nlocal function bit_sign(num)\n\9-- Restores the sign after an unsigned conversion according to 2s complement.\n\9if bit32.btest(num, SIGN) then\n\9\9return num - COMPLEMENT\n\9else\n\9\9return num\n\9end\nend\n\nfunction TS.bit_lrsh(a, b)\n\9return bit_sign(bit32.arshift(a, b))\nend\n\nTS.TRY_RETURN = 1\nTS.TRY_BREAK = 2\nTS.TRY_CONTINUE = 3\n\nfunction TS.try(func, catch, finally)\n\9local err, traceback\n\9local success, exitType, returns = xpcall(\n\9\9func,\n\9\9function(errInner)\n\9\9\9err = errInner\n\9\9\9traceback = debug.traceback()\n\9\9end\n\9)\n\9if not success and catch then\n\9\9local newExitType, newReturns = catch(err, traceback)\n\9\9if newExitType then\n\9\9\9exitType, returns = newExitType, newReturns\n\9\9end\n\9end\n\9if finally then\n\9\9local newExitType, newReturns = finally()\n\9\9if newExitType then\n\9\9\9exitType, returns = newExitType, newReturns\n\9\9end\n\9end\n\9return exitType, returns\nend\n\nfunction TS.generator(callback)\n\9local co = coroutine.create(callback)\n\9return {\n\9\9next = function(...)\n\9\9\9if coroutine.status(co) == \"dead\" then\n\9\9\9\9return { done = true }\n\9\9\9else\n\9\9\9\9local success, value = coroutine.resume(co, ...)\n\9\9\9\9if success == false then\n\9\9\9\9\9error(value, 2)\n\9\9\9\9end\n\9\9\9\9return {\n\9\9\9\9\9value = value,\n\9\9\9\9\9done = coroutine.status(co) == \"dead\",\n\9\9\9\9}\n\9\9\9end\n\9\9end,\n\9}\nend\n\nreturn TS\n", "bundle-ex.include.RuntimeLib"))(__env)
end)
__rbx("node_modules", "Folder", "bundle-ex.include.node_modules", "bundle-ex.include")
__rbx("@flamework", "Folder", "bundle-ex.include.node_modules.@flamework", "bundle-ex.include.node_modules")
__rbx("core", "Folder", "bundle-ex.include.node_modules.@flamework.core", "bundle-ex.include.node_modules.@flamework")
__lua("out", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out", "bundle-ex.include.node_modules.@flamework.core", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\nlocal TS = _G[script]\nlocal exports = {}\nexports.Reflect = TS.import(script, script, \"reflect\").Reflect\nexports.Modding = TS.import(script, script, \"modding\").Modding\nlocal _flamework = TS.import(script, script, \"flamework\")\nexports.Controller = _flamework.Controller\nexports.Dependency = _flamework.Dependency\nexports.External = _flamework.External\nexports.Service = _flamework.Service\nexports.Flamework = _flamework.Flamework\nreturn exports\n", "bundle-ex.include.node_modules.@flamework.core.out"))(__env)
end)
__lua("flamework", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.flamework", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.flamework\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\nlocal TS = _G[script]\nlocal _services = TS.import(script, TS.getModule(script, \"@rbxts\", \"services\"))\nlocal Players = _services.Players\nlocal RunService = _services.RunService\nlocal Metadata = TS.import(script, script.Parent, \"metadata\").Metadata\nlocal Modding = TS.import(script, script.Parent, \"modding\").Modding\nlocal Reflect = TS.import(script, script.Parent, \"reflect\").Reflect\nlocal ArtificialDependency, Flamework\nlocal Flamework = {}\ndo\n\9local _container = Flamework\n\9local flameworkConfig = {\n\9\9isDefault = true,\n\9}\n\9_container.flameworkConfig = flameworkConfig\n\9_container.isInitialized = false\n\9local isPreloading = false\n\9-- * @hidden\n\9local hasFlameworkIgnited\n\9local function resolveDependency(id)\n\9\9if isPreloading then\n\9\9\9local source, line = debug.info(2, \"sl\")\n\9\9\9warn(\"[Flamework] Attempting to load dependency '\" .. (id .. \"' during preloading.\"))\n\9\9\9warn(\"This is prone to race conditions and is not guaranteed to succeed.\")\n\9\9\9warn(\"Script '\" .. (source .. (\"', Line \" .. tostring(line))))\n\9\9elseif not hasFlameworkIgnited and Metadata.gameConfig.disableDependencyWarnings ~= true then\n\9\9\9local source, line = debug.info(2, \"sl\")\n\9\9\9warn(\"[Flamework] Dependency '\" .. (id .. \"' was loaded before ignition.\"))\n\9\9\9warn(\"This is considered bad practice and should be avoided.\")\n\9\9\9warn(\"You can disable this warning in flamework.json\")\n\9\9\9warn(\"Script '\" .. (source .. (\"', Line \" .. tostring(line))))\n\9\9end\n\9\9return Modding.resolveDependency(ArtificialDependency, id, 0, {})\n\9end\n\9_container.resolveDependency = resolveDependency\n\9-- * @hidden\n\9local logIfVerbose\n\9local function _addPaths(...)\n\9\9local args = { ... }\n\9\9local preloadPaths = {}\n\9\9for _, arg in args do\n\9\9\9local service = table.remove(arg, 1)\n\9\9\9local currentPath = game:GetService(service)\n\9\9\9if service == \"StarterPlayer\" then\n\9\9\9\9if arg[1] ~= \"StarterPlayerScripts\" then\n\9\9\9\9\9error(\"StarterPlayer only supports StarterPlayerScripts\")\n\9\9\9\9end\n\9\9\9\9if not RunService:IsClient() then\n\9\9\9\9\9error(\"The server cannot load StarterPlayer content\")\n\9\9\9\9end\n\9\9\9\9currentPath = Players.LocalPlayer:WaitForChild(\"PlayerScripts\")\n\9\9\9\9table.remove(arg, 1)\n\9\9\9end\n\9\9\9do\n\9\9\9\9local i = 0\n\9\9\9\9local _shouldIncrement = false\n\9\9\9\9while true do\n\9\9\9\9\9if _shouldIncrement then\n\9\9\9\9\9\9i += 1\n\9\9\9\9\9else\n\9\9\9\9\9\9_shouldIncrement = true\n\9\9\9\9\9end\n\9\9\9\9\9if not (i < #arg) then\n\9\9\9\9\9\9break\n\9\9\9\9\9end\n\9\9\9\9\9currentPath = currentPath:WaitForChild(arg[i + 1])\n\9\9\9\9end\n\9\9\9end\n\9\9\9local _currentPath = currentPath\n\9\9\9table.insert(preloadPaths, _currentPath)\n\9\9end\n\9\9local preload = function(moduleScript)\n\9\9\9isPreloading = true\n\9\9\9local start = os.clock()\n\9\9\9local success, value = pcall(require, moduleScript)\n\9\9\9local endTime = math.floor((os.clock() - start) * 1000)\n\9\9\9isPreloading = false\n\9\9\9if not success then\n\9\9\9\9error(moduleScript:GetFullName() .. (\" failed to preload (\" .. (tostring(endTime) .. (\"ms): \" .. value))))\n\9\9\9end\n\9\9end\n\9\9for _, path in preloadPaths do\n\9\9\9logIfVerbose(\"Preloading directory \" .. path:GetFullName())\n\9\9\9if path:IsA(\"ModuleScript\") then\n\9\9\9\9preload(path)\n\9\9\9end\n\9\9\9for _1, instance in path:GetDescendants() do\n\9\9\9\9if instance:IsA(\"ModuleScript\") then\n\9\9\9\9\9preload(instance)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\n\9_container._addPaths = _addPaths\n\9-- * @hidden\n\9local function _implements(object, id)\n\9\9local _exp = Reflect.getMetadatas(object, \"flamework:implements\")\n\9\9local _arg0 = function(impl)\n\9\9\9local _impl = impl\n\9\9\9local _id = id\n\9\9\9return table.find(_impl, _id) ~= nil\n\9\9end\n\9\9-- ▼ ReadonlyArray.some ▼\n\9\9local _result = false\n\9\9for _k, _v in _exp do\n\9\9\9if _arg0(_v, _k - 1, _exp) then\n\9\9\9\9_result = true\n\9\9\9\9break\n\9\9\9end\n\9\9end\n\9\9-- ▲ ReadonlyArray.some ▲\n\9\9return _result\n\9end\n\9_container._implements = _implements\n\9function logIfVerbose(...)\n\9\9local args = { ... }\n\9\9if Metadata.getLogLevel() == \"verbose\" then\n\9\9\9print(\"[Flamework (verbose)]\", unpack(args))\n\9\9end\n\9end\n\9local function isConstructor(obj)\n\9\9return obj.new ~= nil and obj.constructor ~= nil\n\9end\n\9local function getIdentifier(obj, suffix)\n\9\9if suffix == nil then\n\9\9\9suffix = \"\"\n\9\9end\n\9\9local _condition = Reflect.getMetadata(obj, \"identifier\")\n\9\9if _condition == nil then\n\9\9\9_condition = \"UnidentifiedFlameworkListener\" .. suffix\n\9\9end\n\9\9return _condition\n\9end\n\9-- This returns a Map rather than an Array because table.sort is unstable and will not preserve element order.\n\9local function topologicalSort(objects)\n\9\9-- This implementation ignores circular dependency trees.\n\9\9local currentSize = 0\n\9\9local sorted = {}\n\9\9local visited = {}\n\9\9local visitor\n\9\9visitor = function(node)\n\9\9\9local _node = node\n\9\9\9if visited[_node] ~= nil then\n\9\9\9\9return nil\n\9\9\9end\n\9\9\9local _node_1 = node\n\9\9\9visited[_node_1] = true\n\9\9\9local _idToObj = Reflect.idToObj\n\9\9\9local _node_2 = node\n\9\9\9local object = _idToObj[_node_2]\n\9\9\9if not object then\n\9\9\9\9return nil\n\9\9\9end\n\9\9\9local dependencies = Reflect.getMetadata(object, \"flamework:parameters\")\n\9\9\9for _, dependency in dependencies or {} do\n\9\9\9\9visitor(dependency)\n\9\9\9end\n\9\9\9local _exp = node\n\9\9\9local _original = currentSize\n\9\9\9currentSize += 1\n\9\9\9sorted[_exp] = _original\n\9\9end\n\9\9for _, node in objects do\n\9\9\9visitor(node)\n\9\9end\n\9\9return sorted\n\9end\n\9local externalClasses = {}\n\9--[[\n\9\9*\n\9\9* Allow an external module to be bootstrapped by Flamework.ignite()\n\9]]\n\9local function registerExternalClass(ctor)\n\9\9local _ctor = ctor\n\9\9externalClasses[_ctor] = true\n\9end\n\9_container.registerExternalClass = registerExternalClass\n\9hasFlameworkIgnited = false\n\9--[[\n\9\9*\n\9\9* Initialize Flamework.\n\9\9*\n\9\9* This will start up the lifecycle events on all currently registered\n\9\9* classes.\n\9\9*\n\9\9* You should preload all necessary directories before calling this\n\9\9* as newly registered classes will not run their lifecycle events.\n\9\9*\n\9\9* @returns All the dependencies that have been loaded.\n\9]]\n\9local function ignite(patchedConfig)\n\9\9if hasFlameworkIgnited then\n\9\9\9error(\"Flamework.ignite() should only be called once\")\n\9\9end\n\9\9hasFlameworkIgnited = true\n\9\9if patchedConfig then\n\9\9\9for key, value in pairs(patchedConfig) do\n\9\9\9\9flameworkConfig[key] = value\n\9\9\9end\n\9\9end\n\9\9for ctor in Reflect.objToId do\n\9\9\9if not isConstructor(ctor) then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9if not Reflect.getMetadata(ctor, \"flamework:singleton\") then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9local isPatched = Reflect.getOwnMetadata(ctor, \"flamework:isPatched\")\n\9\9\9if flameworkConfig.loadOverride and (not (table.find(flameworkConfig.loadOverride, ctor) ~= nil) and not isPatched) then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9local isExternal = Reflect.getOwnMetadata(ctor, \"flamework:isExternal\")\n\9\9\9if isExternal and not (externalClasses[ctor] ~= nil) then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9Modding.resolveSingleton(ctor)\n\9\9\9logIfVerbose(\"Resolving singleton \" .. tostring(ctor))\n\9\9end\n\9\9local dependencies = {}\n\9\9for ctor, dependency in Modding.getSingletons() do\n\9\9\9local _condition = Reflect.getMetadata(ctor, \"flamework:loadOrder\")\n\9\9\9if _condition == nil then\n\9\9\9\9_condition = 1\n\9\9\9end\n\9\9\9local loadOrder = _condition\n\9\9\9local _arg0 = { dependency, loadOrder }\n\9\9\9table.insert(dependencies, _arg0)\n\9\9end\n\9\9local _arg0 = function(_param)\n\9\9\9local obj = _param[1]\n\9\9\9return getIdentifier(obj)\n\9\9end\n\9\9-- ▼ ReadonlyArray.map ▼\n\9\9local _newValue = table.create(#dependencies)\n\9\9for _k, _v in dependencies do\n\9\9\9_newValue[_k] = _arg0(_v, _k - 1, dependencies)\n\9\9end\n\9\9-- ▲ ReadonlyArray.map ▲\n\9\9local sortedDependencies = topologicalSort(_newValue)\n\9\9local start = {}\n\9\9local init = {}\n\9\9local tick = {}\n\9\9local render = {}\n\9\9local physics = {}\n\9\9local _arg0_1 = function(_param, _param_1)\n\9\9\9local depA = _param[1]\n\9\9\9local aOrder = _param[2]\n\9\9\9local depB = _param_1[1]\n\9\9\9local bOrder = _param_1[2]\n\9\9\9if aOrder ~= bOrder then\n\9\9\9\9return aOrder < bOrder\n\9\9\9end\n\9\9\9local _arg0_2 = getIdentifier(depA)\n\9\9\9local aIndex = sortedDependencies[_arg0_2]\n\9\9\9local _arg0_3 = getIdentifier(depB)\n\9\9\9local bIndex = sortedDependencies[_arg0_3]\n\9\9\9return aIndex < bIndex\n\9\9end\n\9\9table.sort(dependencies, _arg0_1)\n\9\9Modding.onListenerAdded(function(object)\n\9\9\9local _object = object\n\9\9\9local _arg1 = getIdentifier(object, \"/OnTick\")\n\9\9\9tick[_object] = _arg1\n\9\9\9return tick\n\9\9end, \"$:flamework@OnTick\")\n\9\9Modding.onListenerAdded(function(object)\n\9\9\9local _object = object\n\9\9\9local _arg1 = getIdentifier(object, \"/OnPhysics\")\n\9\9\9physics[_object] = _arg1\n\9\9\9return physics\n\9\9end, \"$:flamework@OnPhysics\")\n\9\9Modding.onListenerAdded(function(object)\n\9\9\9local _object = object\n\9\9\9local _arg1 = getIdentifier(object, \"/OnRender\")\n\9\9\9render[_object] = _arg1\n\9\9\9return render\n\9\9end, \"$:flamework@OnRender\")\n\9\9Modding.onListenerRemoved(function(object)\n\9\9\9local _object = object\n\9\9\9-- ▼ Map.delete ▼\n\9\9\9local _valueExisted = tick[_object] ~= nil\n\9\9\9tick[_object] = nil\n\9\9\9-- ▲ Map.delete ▲\n\9\9\9return _valueExisted\n\9\9end, \"$:flamework@OnTick\")\n\9\9Modding.onListenerRemoved(function(object)\n\9\9\9local _object = object\n\9\9\9-- ▼ Map.delete ▼\n\9\9\9local _valueExisted = physics[_object] ~= nil\n\9\9\9physics[_object] = nil\n\9\9\9-- ▲ Map.delete ▲\n\9\9\9return _valueExisted\n\9\9end, \"$:flamework@OnPhysics\")\n\9\9Modding.onListenerRemoved(function(object)\n\9\9\9local _object = object\n\9\9\9-- ▼ Map.delete ▼\n\9\9\9local _valueExisted = render[_object] ~= nil\n\9\9\9render[_object] = nil\n\9\9\9-- ▲ Map.delete ▲\n\9\9\9return _valueExisted\n\9\9end, \"$:flamework@OnRender\")\n\9\9for _, _binding in dependencies do\n\9\9\9local dependency = _binding[1]\n\9\9\9if Flamework._implements(dependency, \"$:flamework@OnInit\") then\n\9\9\9\9local _arg0_2 = { dependency, getIdentifier(dependency) }\n\9\9\9\9table.insert(init, _arg0_2)\n\9\9\9end\n\9\9\9if Flamework._implements(dependency, \"$:flamework@OnStart\") then\n\9\9\9\9local _arg0_2 = { dependency, getIdentifier(dependency) }\n\9\9\9\9table.insert(start, _arg0_2)\n\9\9\9end\n\9\9end\n\9\9for _, _binding in init do\n\9\9\9local dependency = _binding[1]\n\9\9\9local identifier = _binding[2]\n\9\9\9debug.setmemorycategory(identifier)\n\9\9\9logIfVerbose(\"OnInit \" .. identifier)\n\9\9\9local initResult = dependency:onInit()\n\9\9\9if TS.Promise.is(initResult) then\n\9\9\9\9local status, value = initResult:awaitStatus()\n\9\9\9\9if status == TS.Promise.Status.Rejected then\n\9\9\9\9\9error(\"OnInit failed for dependency '\" .. (identifier .. (\"'. \" .. tostring(value))))\n\9\9\9\9end\n\9\9\9end\n\9\9\9debug.resetmemorycategory()\n\9\9end\n\9\9_container.isInitialized = true\n\9\9RunService.Heartbeat:Connect(function(dt)\n\9\9\9for dependency, identifier in tick do\n\9\9\9\9task.spawn(function()\n\9\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9\9dependency:onTick(dt)\n\9\9\9\9end)\n\9\9\9end\n\9\9end)\n\9\9RunService.Stepped:Connect(function(time, dt)\n\9\9\9for dependency, identifier in physics do\n\9\9\9\9task.spawn(function()\n\9\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9\9dependency:onPhysics(dt, time)\n\9\9\9\9end)\n\9\9\9end\n\9\9end)\n\9\9if RunService:IsClient() then\n\9\9\9RunService.RenderStepped:Connect(function(dt)\n\9\9\9\9for dependency, identifier in render do\n\9\9\9\9\9task.spawn(function()\n\9\9\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9\9\9dependency:onRender(dt)\n\9\9\9\9\9end)\n\9\9\9\9end\n\9\9\9end)\n\9\9end\n\9\9for _, _binding in start do\n\9\9\9local dependency = _binding[1]\n\9\9\9local identifier = _binding[2]\n\9\9\9task.spawn(function()\n\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9logIfVerbose(\"OnStart \" .. identifier)\n\9\9\9\9dependency:onStart()\n\9\9\9end)\n\9\9end\n\9end\n\9_container.ignite = ignite\n\9--[[\n\9\9*\n\9\9* Preload the specified paths by requiring all ModuleScript descendants.\n\9]]\n\9--[[\n\9\9*\n\9\9* Preload the specified paths by requiring all ModuleScript descendants.\n\9]]\n\9--[[\n\9\9*\n\9\9* Retrieve the identifier for the specified type.\n\9]]\n\9--[[\n\9\9*\n\9\9* Check if the constructor implements the specified interface.\n\9]]\n\9--[[\n\9\9*\n\9\9* Check if object implements the specified interface.\n\9]]\n\9--[[\n\9\9*\n\9\9* Creates a type guard from any arbitrary type.\n\9]]\n\9--[[\n\9\9*\n\9\9* Hash a function using the method used internally by Flamework.\n\9\9* If a context is provided, then Flamework will create a new hash\n\9\9* if the specified string does not have one in that context.\n\9\9* @param str The string to hash\n\9\9* @param context A scope for the hash\n\9]]\n\9--[[\n\9\9*\n\9\9* Utility for use in test suites, not recommended for anything else.\n\9]]\n\9local Testing = {}\n\9do\n\9\9local _container_1 = Testing\n\9\9local function patchDependency(patchedClass, id)\n\9\9\9if id == nil then\n\9\9\9\9error(\"Patching failed, no ID\")\n\9\9\9end\n\9\9\9local _idToObj = Reflect.idToObj\n\9\9\9local _id = id\n\9\9\9local idCtor = _idToObj[_id]\n\9\9\9if idCtor == nil then\n\9\9\9\9error(\"Dependency \" .. (id .. \" was not found and cannot be patched.\"))\n\9\9\9end\n\9\9\9if Modding.getSingletons()[idCtor] ~= nil then\n\9\9\9\9error(id .. \" has already been resolved, continuing is unsafe\")\n\9\9\9end\n\9\9\9local objMetadata = Reflect.metadata[idCtor]\n\9\9\9if not objMetadata then\n\9\9\9\9error(\"Dependency \" .. (id .. \" has no existing metadata.\"))\n\9\9\9end\n\9\9\9Reflect.defineMetadata(idCtor, \"flamework:isPatched\", true)\n\9\9\9Reflect.metadata[idCtor] = nil\n\9\9\9local _metadata = Reflect.metadata\n\9\9\9local _patchedClass = patchedClass\n\9\9\9_metadata[_patchedClass] = objMetadata\n\9\9\9local _objToId = Reflect.objToId\n\9\9\9local _patchedClass_1 = patchedClass\n\9\9\9local _id_1 = id\n\9\9\9_objToId[_patchedClass_1] = _id_1\n\9\9\9local _idToObj_1 = Reflect.idToObj\n\9\9\9local _id_2 = id\n\9\9\9local _patchedClass_2 = patchedClass\n\9\9\9_idToObj_1[_id_2] = _patchedClass_2\n\9\9end\n\9\9_container_1.patchDependency = patchDependency\n\9end\n\9_container.Testing = Testing\nend\n--[[\n\9*\n\9* An internal class used for resolving the Dependency<T> macro.\n]]\ndo\n\9ArtificialDependency = setmetatable({}, {\n\9\9__tostring = function()\n\9\9\9return \"ArtificialDependency\"\n\9\9end,\n\9})\n\9ArtificialDependency.__index = ArtificialDependency\n\9function ArtificialDependency.new(...)\n\9\9local self = setmetatable({}, ArtificialDependency)\n\9\9return self:constructor(...) or self\n\9end\n\9function ArtificialDependency:constructor()\n\9end\nend\nReflect.defineMetadata(ArtificialDependency, \"identifier\", \"$:flamework@ArtificialDependency\")\nReflect.defineMetadata(ArtificialDependency, \"flamework:isArtificial\", true)\n--[[\n\9*\n\9* Register a class as a Service.\n\9*\n\9* @server\n\9* @metadata flamework:implements flamework:parameters\n]]\nlocal Service = Modding.createDecorator(\"Class\", function(descriptor, _param)\n\9local cfg = _param[1]\n\9if RunService:IsServer() then\n\9\9Reflect.defineMetadata(descriptor.object, \"flamework:singleton\", true)\n\9\9local _fn = Reflect\n\9\9local _exp = descriptor.object\n\9\9local _result = cfg\n\9\9if _result ~= nil then\n\9\9\9_result = _result.loadOrder\n\9\9end\n\9\9_fn.defineMetadata(_exp, \"flamework:loadOrder\", _result)\n\9end\nend)\n--[[\n\9*\n\9* Register a class as a Controller.\n\9*\n\9* @client\n\9* @metadata flamework:implements flamework:parameters\n]]\nlocal Controller = Modding.createDecorator(\"Class\", function(descriptor, _param)\n\9local cfg = _param[1]\n\9if RunService:IsClient() then\n\9\9Reflect.defineMetadata(descriptor.object, \"flamework:singleton\", true)\n\9\9local _fn = Reflect\n\9\9local _exp = descriptor.object\n\9\9local _result = cfg\n\9\9if _result ~= nil then\n\9\9\9_result = _result.loadOrder\n\9\9end\n\9\9_fn.defineMetadata(_exp, \"flamework:loadOrder\", _result)\n\9end\nend)\n--[[\n\9*\n\9* Marks this class as an external class.\n\9*\n\9* External classes are designed for packages and won't be\n\9* bootstrapped unless explicitly specified. Excluding this\n\9* inside of a package will make the class load as long as\n\9* it has been loaded.\n]]\nlocal External = Modding.createDecorator(\"Class\", function(descriptor)\n\9Reflect.defineMetadata(descriptor.object, \"flamework:isExternal\", true)\nend)\n--[[\n\9*\n\9* Hook into the OnInit lifecycle event.\n]]\n--[[\n\9*\n\9* Hook into the OnStart lifecycle event.\n]]\n--[[\n\9*\n\9* Hook into the OnTick lifecycle event.\n\9* Equivalent to: RunService.Heartbeat\n]]\n--[[\n\9*\n\9* Hook into the OnPhysics lifecycle event.\n\9* Equivalent to: RunService.Stepped\n]]\n--[[\n\9*\n\9* Hook into the OnRender lifecycle event.\n\9* Equivalent to: RunService.RenderStepped\n\9*\n\9* @client\n]]\nreturn {\n\9Flamework = Flamework,\n\9Service = Service,\n\9Controller = Controller,\n\9External = External,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.flamework"))(__env)
end)
__lua("metadata", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.metadata", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.metadata\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\n--[[\n\9*\n\9* Metadata exposed by the Flamework transformer.\n]]\nlocal Metadata = {}\ndo\n\9local _container = Metadata\n\9--[[\n\9\9*\n\9\9* Runtime metadata generated by the transformer\n\9]]\n\9--[[\n\9\9*\n\9\9* Runtime metadata generated by the transformer\n\9]]\n\9local function getConfigContainer()\n\9\9local current = script\n\9\9while current do\n\9\9\9local flamework = current:FindFirstChild(\"flamework\")\n\9\9\9if flamework then\n\9\9\9\9local metadata = flamework:FindFirstChild(\"config\")\n\9\9\9\9if metadata then\n\9\9\9\9\9return require(metadata)\n\9\9\9\9end\n\9\9\9end\n\9\9\9current = current.Parent\n\9\9end\n\9end\n\9local configContainer\n\9local function getConfig(packageId)\n\9\9local _result\n\9\9if packageId == nil then\n\9\9\9local _result_1 = configContainer\n\9\9\9if _result_1 ~= nil then\n\9\9\9\9_result_1 = _result_1.game\n\9\9\9end\n\9\9\9_result = _result_1\n\9\9else\n\9\9\9local _result_1 = configContainer\n\9\9\9if _result_1 ~= nil then\n\9\9\9\9local _packages = _result_1.packages\n\9\9\9\9local _packageId = packageId\n\9\9\9\9_result_1 = _packages[_packageId]\n\9\9\9end\n\9\9\9_result = _result_1\n\9\9end\n\9\9return _result\n\9end\n\9configContainer = getConfigContainer()\n\9_container.configContainer = configContainer\n\9local _result = configContainer\n\9if _result ~= nil then\n\9\9_result = _result.game\n\9end\n\9local _condition = _result\n\9if _condition == nil then\n\9\9_condition = {}\n\9end\n\9local gameConfig = _condition\n\9_container.gameConfig = gameConfig\n\9local function getLogLevel(packageId)\n\9\9local config = getConfig(packageId)\n\9\9if not config or config.logLevel == nil then\n\9\9\9return \"none\"\n\9\9end\n\9\9return config.logLevel\n\9end\n\9_container.getLogLevel = getLogLevel\nend\nreturn {\n\9Metadata = Metadata,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.metadata"))(__env)
end)
__lua("modding", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.modding", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.modding\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\nlocal TS = _G[script]\nlocal Signal = TS.import(script, TS.getModule(script, \"@rbxts\", \"signal\"))\nlocal Reflect = TS.import(script, script.Parent, \"reflect\").Reflect\nlocal getDeferredConstructor, isConstructor\nlocal Modding = {}\ndo\n\9local _container = Modding\n\9local listeners = {}\n\9local lifecycleListeners = {}\n\9local decoratorListeners = {}\n\9local listenerAdded = Signal.new()\n\9local listenerRemoved = Signal.new()\n\9local listenerAddedEvents = {}\n\9local listenerRemovedEvents = {}\n\9local dependencyResolution = {}\n\9local resolvedSingletons = {}\n\9local loadingList = {}\n\9--[[\n\9\9*\n\9\9* Registers a listener for lifecycle events.\n\9]]\n\9local function addListener(object)\n\9\9local listener = {\n\9\9\9eventIds = {},\n\9\9\9involvement = {},\n\9\9}\n\9\9for _, lifecycleEvents in Reflect.getMetadatas(object, \"flamework:implements\") do\n\9\9\9for _1, lifecycleEvent in lifecycleEvents do\n\9\9\9\9if listener.eventIds[lifecycleEvent] ~= nil then\n\9\9\9\9\9continue\n\9\9\9\9end\n\9\9\9\9local lifecycleListener = lifecycleListeners[lifecycleEvent]\n\9\9\9\9if not lifecycleListener then\n\9\9\9\9\9lifecycleListener = {}\n\9\9\9\9\9local _lifecycleListener = lifecycleListener\n\9\9\9\9\9lifecycleListeners[lifecycleEvent] = _lifecycleListener\n\9\9\9\9end\n\9\9\9\9local _lifecycleListener = lifecycleListener\n\9\9\9\9local _object = object\n\9\9\9\9_lifecycleListener[_object] = true\n\9\9\9\9listener.eventIds[lifecycleEvent] = true\n\9\9\9\9local _involvement = listener.involvement\n\9\9\9\9local _lifecycleListener_1 = lifecycleListener\n\9\9\9\9table.insert(_involvement, _lifecycleListener_1)\n\9\9\9\9local _result = listenerAddedEvents[lifecycleEvent]\n\9\9\9\9if _result ~= nil then\n\9\9\9\9\9_result:Fire(object)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9local decorators = Reflect.getMetadata(object, \"flamework:decorators\")\n\9\9if decorators then\n\9\9\9for _, decorator in decorators do\n\9\9\9\9if listener.eventIds[decorator] ~= nil then\n\9\9\9\9\9continue\n\9\9\9\9end\n\9\9\9\9local decoratorListener = decoratorListeners[decorator]\n\9\9\9\9if not decoratorListener then\n\9\9\9\9\9decoratorListener = {}\n\9\9\9\9\9local _decoratorListener = decoratorListener\n\9\9\9\9\9decoratorListeners[decorator] = _decoratorListener\n\9\9\9\9end\n\9\9\9\9local _decoratorListener = decoratorListener\n\9\9\9\9local _object = object\n\9\9\9\9_decoratorListener[_object] = true\n\9\9\9\9listener.eventIds[decorator] = true\n\9\9\9\9local _involvement = listener.involvement\n\9\9\9\9local _decoratorListener_1 = decoratorListener\n\9\9\9\9table.insert(_involvement, _decoratorListener_1)\n\9\9\9\9local _result = listenerAddedEvents[decorator]\n\9\9\9\9if _result ~= nil then\n\9\9\9\9\9_result:Fire(object)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9local _object = object\n\9\9listeners[_object] = listener\n\9\9listenerAdded:Fire(object)\n\9end\n\9_container.addListener = addListener\n\9--[[\n\9\9*\n\9\9* Removes a listener for lifecycle events and decorators.\n\9]]\n\9local function removeListener(object)\n\9\9local _object = object\n\9\9local listener = listeners[_object]\n\9\9if not listener then\n\9\9\9return nil\n\9\9end\n\9\9for _, set in listener.involvement do\n\9\9\9local _object_1 = object\n\9\9\9set[_object_1] = nil\n\9\9end\n\9\9for id in listener.eventIds do\n\9\9\9local _result = listenerRemovedEvents[id]\n\9\9\9if _result ~= nil then\n\9\9\9\9_result:Fire(object)\n\9\9\9end\n\9\9end\n\9\9local _object_1 = object\n\9\9listeners[_object_1] = nil\n\9\9listenerRemoved:Fire(object)\n\9end\n\9_container.removeListener = removeListener\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9\9* Fires whenever any listener is added.\n\9\9*\n\9\9* Fires for all existing listeners.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9\9* Fires whenever a listener has a decorator with the specified ID.\n\9\9*\n\9\9* Fires for all existing listeners.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9\9* Fires whenever a listener has a lifecycle event with the specified ID.\n\9\9*\n\9\9* Fires for all existing listeners.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9]]\n\9local function onListenerAdded(func, id)\n\9\9if id ~= nil then\n\9\9\9local _id = id\n\9\9\9local listenerAddedEvent = listenerAddedEvents[_id]\n\9\9\9if not listenerAddedEvent then\n\9\9\9\9local _exp = id\n\9\9\9\9listenerAddedEvent = Signal.new()\n\9\9\9\9local _listenerAddedEvent = listenerAddedEvent\n\9\9\9\9listenerAddedEvents[_exp] = _listenerAddedEvent\n\9\9\9end\n\9\9\9local _id_1 = id\n\9\9\9local _condition = lifecycleListeners[_id_1]\n\9\9\9if not _condition then\n\9\9\9\9local _id_2 = id\n\9\9\9\9_condition = decoratorListeners[_id_2]\n\9\9\9end\n\9\9\9local existingListeners = _condition\n\9\9\9if existingListeners then\n\9\9\9\9for listener in existingListeners do\n\9\9\9\9\9task.spawn(func, listener)\n\9\9\9\9end\n\9\9\9end\n\9\9\9return listenerAddedEvent:Connect(func)\n\9\9else\n\9\9\9for listener in listeners do\n\9\9\9\9task.spawn(func, listener)\n\9\9\9end\n\9\9\9return listenerAdded:Connect(func)\n\9\9end\n\9end\n\9_container.onListenerAdded = onListenerAdded\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9\9*\n\9\9* Fires whenever any listener is removed.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9\9*\n\9\9* Fires whenever a listener has a decorator with the specified ID.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9\9*\n\9\9* Fires whenever a listener has a lifecycle event with the specified ID.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9]]\n\9local function onListenerRemoved(func, id)\n\9\9if id ~= nil then\n\9\9\9local _id = id\n\9\9\9local listenerRemovedEvent = listenerRemovedEvents[_id]\n\9\9\9if not listenerRemovedEvent then\n\9\9\9\9local _exp = id\n\9\9\9\9listenerRemovedEvent = Signal.new()\n\9\9\9\9local _listenerRemovedEvent = listenerRemovedEvent\n\9\9\9\9listenerRemovedEvents[_exp] = _listenerRemovedEvent\n\9\9\9end\n\9\9\9return listenerRemovedEvent:Connect(func)\n\9\9else\n\9\9\9return listenerRemoved:Connect(func)\n\9\9end\n\9end\n\9_container.onListenerRemoved = onListenerRemoved\n\9--[[\n\9\9*\n\9\9* Registers a class decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a method decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a property decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a decorator.\n\9]]\n\9local defineDecoratorMetadata\n\9local function createDecorator(_kind, func)\n\9\9return {\n\9\9\9func = function(descriptor, config)\n\9\9\9\9defineDecoratorMetadata(descriptor, config)\n\9\9\9\9func(descriptor, config)\n\9\9\9end,\n\9\9}\n\9end\n\9_container.createDecorator = createDecorator\n\9--[[\n\9\9*\n\9\9* Registers a metadata class decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a metadata method decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a metadata property decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a metadata decorator.\n\9]]\n\9local function createMetaDecorator(_kind)\n\9\9return {\n\9\9\9func = function(descriptor, config)\n\9\9\9\9defineDecoratorMetadata(descriptor, config)\n\9\9\9end,\n\9\9}\n\9end\n\9_container.createMetaDecorator = createMetaDecorator\n\9--[[\n\9\9*\n\9\9* Retrieves registered decorators.\n\9]]\n\9local function getDecorators(id)\n\9\9local _arg0 = id ~= nil\n\9\9assert(_arg0)\n\9\9local _decorators = Reflect.decorators\n\9\9local _id = id\n\9\9local decorators = _decorators[_id]\n\9\9if not decorators then\n\9\9\9return {}\n\9\9end\n\9\9local _arg0_1 = function(object)\n\9\9\9local decoratorConfig = Reflect.getOwnMetadata(object, \"flamework:decorators.\" .. id)\n\9\9\9assert(decoratorConfig)\n\9\9\9return {\n\9\9\9\9object = object,\n\9\9\9\9arguments = decoratorConfig.arguments,\n\9\9\9}\n\9\9end\n\9\9-- ▼ ReadonlyArray.map ▼\n\9\9local _newValue = table.create(#decorators)\n\9\9for _k, _v in decorators do\n\9\9\9_newValue[_k] = _arg0_1(_v, _k - 1, decorators)\n\9\9end\n\9\9-- ▲ ReadonlyArray.map ▲\n\9\9return _newValue\n\9end\n\9_container.getDecorators = getDecorators\n\9--[[\n\9\9*\n\9\9* Creates a map of every property using the specified decorator.\n\9]]\n\9local getDecorator\n\9local function getPropertyDecorators(obj, id)\n\9\9local decorators = {}\n\9\9local _arg0 = id ~= nil\n\9\9assert(_arg0)\n\9\9for _, prop in Reflect.getProperties(obj) do\n\9\9\9local decorator = getDecorator(obj, prop, id)\n\9\9\9if decorator then\n\9\9\9\9decorators[prop] = decorator\n\9\9\9end\n\9\9end\n\9\9return decorators\n\9end\n\9_container.getPropertyDecorators = getPropertyDecorators\n\9--[[\n\9\9*\n\9\9* Retrieves a decorator from an object or its properties.\n\9]]\n\9function getDecorator(object, property, id)\n\9\9local decorator = Reflect.getMetadata(object, \"flamework:decorators.\" .. tostring(id), property)\n\9\9if not decorator then\n\9\9\9return nil\n\9\9end\n\9\9return decorator\n\9end\n\9_container.getDecorator = getDecorator\n\9--[[\n\9\9*\n\9\9* Retrieves a singleton or instantiates one if it does not exist.\n\9]]\n\9local createDependency\n\9local function resolveSingleton(ctor)\n\9\9local _ctor = ctor\n\9\9local resolvedDependency = resolvedSingletons[_ctor]\n\9\9if resolvedDependency ~= nil then\n\9\9\9return resolvedDependency\n\9\9end\n\9\9local _ctor_1 = ctor\n\9\9if table.find(loadingList, _ctor_1) ~= nil then\n\9\9\9-- ▼ ReadonlyArray.join ▼\n\9\9\9local _result = table.create(#loadingList)\n\9\9\9for _k, _v in loadingList do\n\9\9\9\9_result[_k] = tostring(_v)\n\9\9\9end\n\9\9\9-- ▲ ReadonlyArray.join ▲\n\9\9\9error(\"Circular dependency detected \" .. (table.concat(_result, \" <=> \") .. (\" <=> \" .. tostring(ctor))))\n\9\9end\n\9\9local _ctor_2 = ctor\n\9\9table.insert(loadingList, _ctor_2)\n\9\9-- Flamework can resolve singletons at any arbitrary point,\n\9\9-- so we should fetch custom dependency resolution (added via decorator) through the Reflect api.\n\9\9local opts = Reflect.getOwnMetadata(ctor, \"flamework:dependency_resolution\")\n\9\9local dependency = createDependency(ctor, opts)\n\9\9local _ctor_3 = ctor\n\9\9resolvedSingletons[_ctor_3] = dependency\n\9\9loadingList[#loadingList] = nil\n\9\9addListener(dependency)\n\9\9return dependency\n\9end\n\9_container.resolveSingleton = resolveSingleton\n\9-- * @internal Used for bootstrapping\n\9local function getSingletons()\n\9\9return resolvedSingletons\n\9end\n\9_container.getSingletons = getSingletons\n\9--[[\n\9\9*\n\9\9* Modifies dependency resolution for a specific ID.\n\9\9*\n\9\9* If a function is passed, it will be called, passing the target constructor, every time that ID needs to be resolved.\n\9\9* Otherwise, the passed object is returned directly.\n\9]]\n\9local function registerDependency(dependency, id)\n\9\9local _arg0 = id ~= nil\n\9\9assert(_arg0)\n\9\9local _dependency = dependency\n\9\9if type(_dependency) == \"function\" then\n\9\9\9local _id = id\n\9\9\9local _dependency_1 = dependency\n\9\9\9dependencyResolution[_id] = _dependency_1\n\9\9else\n\9\9\9local _id = id\n\9\9\9local _arg1 = function()\n\9\9\9\9return dependency\n\9\9\9end\n\9\9\9dependencyResolution[_id] = _arg1\n\9\9end\n\9end\n\9_container.registerDependency = registerDependency\n\9--[[\n\9\9*\n\9\9* Instantiates this class using dependency injection.\n\9]]\n\9local createDeferredDependency\n\9function createDependency(ctor, options)\n\9\9if options == nil then\n\9\9\9options = {}\n\9\9end\n\9\9local _binding = createDeferredDependency(ctor, options)\n\9\9local obj = _binding[1]\n\9\9local construct = _binding[2]\n\9\9construct()\n\9\9return obj\n\9end\n\9_container.createDependency = createDependency\n\9--[[\n\9\9*\n\9\9* Creates an object for this class and returns a deferred constructor.\n\9]]\n\9local resolveDependency\n\9function createDeferredDependency(ctor, options)\n\9\9if options == nil then\n\9\9\9options = {}\n\9\9end\n\9\9local _binding = getDeferredConstructor(ctor)\n\9\9local obj = _binding[1]\n\9\9local construct = _binding[2]\n\9\9return { obj, function()\n\9\9\9local dependencies = Reflect.getMetadata(ctor, \"flamework:parameters\")\n\9\9\9local constructorDependencies = {}\n\9\9\9if dependencies then\n\9\9\9\9for index, dependencyId in pairs(dependencies) do\n\9\9\9\9\9constructorDependencies[index - 1 + 1] = resolveDependency(ctor, dependencyId, index - 1, options)\n\9\9\9\9end\n\9\9\9end\n\9\9\9construct(unpack(constructorDependencies))\n\9\9end }\n\9end\n\9_container.createDeferredDependency = createDeferredDependency\n\9--[[\n\9\9*\n\9\9* Dependency resolution logic.\n\9\9* @internal\n\9]]\n\9function resolveDependency(ctor, dependencyId, index, options)\n\9\9if options.handle ~= nil then\n\9\9\9local dependency = options.handle(dependencyId, index)\n\9\9\9if dependency ~= nil then\n\9\9\9\9return dependency\n\9\9\9end\n\9\9end\n\9\9local _dependencyId = dependencyId\n\9\9local resolution = dependencyResolution[_dependencyId]\n\9\9if resolution ~= nil then\n\9\9\9return resolution(ctor)\n\9\9end\n\9\9local _idToObj = Reflect.idToObj\n\9\9local _dependencyId_1 = dependencyId\n\9\9local dependencyCtor = _idToObj[_dependencyId_1]\n\9\9if dependencyCtor and isConstructor(dependencyCtor) then\n\9\9\9return resolveSingleton(dependencyCtor)\n\9\9end\n\9\9if string.sub(dependencyId, 1, 2) == \"$p\" then\n\9\9\9if string.sub(dependencyId, 1, 3) == \"$ps\" then\n\9\9\9\9return string.sub(dependencyId, 5)\n\9\9\9end\n\9\9\9if string.sub(dependencyId, 1, 3) == \"$pn\" then\n\9\9\9\9local _condition = tonumber(string.sub(dependencyId, 5))\n\9\9\9\9if _condition == nil then\n\9\9\9\9\9_condition = 0\n\9\9\9\9end\n\9\9\9\9return _condition\n\9\9\9end\n\9\9\9if options.handlePrimitive ~= nil then\n\9\9\9\9return options.handlePrimitive(dependencyId, index)\n\9\9\9end\n\9\9\9error(\"Unexpected primitive dependency '\" .. (dependencyId .. (\"' while constructing \" .. tostring(ctor))))\n\9\9end\n\9\9error(\"Could not find constructor for \" .. (dependencyId .. (\" while constructing \" .. tostring(ctor))))\n\9end\n\9_container.resolveDependency = resolveDependency\n\9--[[\n\9\9*\n\9\9* @hidden\n\9\9* @deprecated\n\9]]\n\9local function macro(values, directValue)\n\9\9local _values = values\n\9\9if type(_values) == \"string\" then\n\9\9\9return {\n\9\9\9\9[values] = directValue,\n\9\9\9}\n\9\9end\n\9\9local result = {}\n\9\9for _, _binding in values do\n\9\9\9local name = _binding[1]\n\9\9\9local value = _binding[2]\n\9\9\9result[name] = value\n\9\9end\n\9\9return result\n\9end\n\9_container.macro = macro\n\9function defineDecoratorMetadata(descriptor, config)\n\9\9local propertyKey = if descriptor.isStatic then \"static:\" .. descriptor.property else descriptor.property\n\9\9Reflect.defineMetadata(descriptor.object, \"flamework:decorators.\" .. descriptor.id, {\n\9\9\9arguments = config,\n\9\9}, propertyKey)\n\9\9local decoratorList = Reflect.getMetadata(descriptor.object, \"flamework:decorators\", propertyKey)\n\9\9if not decoratorList then\n\9\9\9local _fn = Reflect\n\9\9\9local _exp = descriptor.object\n\9\9\9decoratorList = {}\n\9\9\9_fn.defineMetadata(_exp, \"flamework:decorators\", decoratorList, propertyKey)\n\9\9end\n\9\9local _decoratorList = decoratorList\n\9\9local _id = descriptor.id\n\9\9table.insert(_decoratorList, _id)\n\9end\nend\nfunction isConstructor(obj)\n\9return obj.new ~= nil and obj.constructor ~= nil\nend\nfunction getDeferredConstructor(ctor)\n\9local obj = setmetatable({}, ctor)\n\9return { obj, function(...)\n\9\9local args = { ... }\n\9\9local result = obj:constructor(unpack(args))\n\9\9local _arg0 = result == nil or result == obj\n\9\9assert(_arg0, \"Deferred constructors are not allowed to return values.\")\n\9end }\nend\nreturn {\n\9Modding = Modding,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.modding"))(__env)
end)
__lua("reflect", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.reflect", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.reflect\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\n--[[\n\9*\n\9* Reflection/metadata API\n]]\nlocal Reflect = {}\ndo\n\9local _container = Reflect\n\9-- object -> property -> key -> value\n\9local metadata = setmetatable({}, {\n\9\9__mode = \"k\",\n\9})\n\9_container.metadata = metadata\n\9local decorators = {}\n\9_container.decorators = decorators\n\9local idToObj = {}\n\9_container.idToObj = idToObj\n\9local objToId = {}\n\9_container.objToId = objToId\n\9local NO_PROP_MARKER = {}\n\9local function getObjMetadata(obj, prop, create)\n\9\9local _condition = prop\n\9\9if _condition == nil then\n\9\9\9_condition = NO_PROP_MARKER\n\9\9end\n\9\9local realProp = _condition\n\9\9if create then\n\9\9\9local _obj = obj\n\9\9\9local objMetadata = metadata[_obj]\n\9\9\9if not objMetadata then\n\9\9\9\9local _exp = obj\n\9\9\9\9objMetadata = {}\n\9\9\9\9local _objMetadata = objMetadata\n\9\9\9\9metadata[_exp] = _objMetadata\n\9\9\9end\n\9\9\9local propMetadata = objMetadata[realProp]\n\9\9\9if not propMetadata then\n\9\9\9\9local _objMetadata = objMetadata\n\9\9\9\9propMetadata = {}\n\9\9\9\9local _propMetadata = propMetadata\n\9\9\9\9_objMetadata[realProp] = _propMetadata\n\9\9\9end\n\9\9\9return propMetadata\n\9\9else\n\9\9\9local _obj = obj\n\9\9\9local _result = metadata[_obj]\n\9\9\9if _result ~= nil then\n\9\9\9\9_result = _result[realProp]\n\9\9\9end\n\9\9\9return _result\n\9\9end\n\9end\n\9local function getParentConstructor(obj)\n\9\9local metatable = getmetatable(obj)\n\9\9if metatable and type(metatable) == \"table\" then\n\9\9\9return rawget(metatable, \"__index\")\n\9\9end\n\9end\n\9--[[\n\9\9*\n\9\9* Apply metadata onto this object.\n\9]]\n\9local function defineMetadata(obj, key, value, property)\n\9\9-- 'identifier' is a special, unique ID across all metadata classes.\n\9\9if key == \"identifier\" then\n\9\9\9local _value = value\n\9\9\9local _arg0 = type(_value) == \"string\"\n\9\9\9assert(_arg0, \"identifier must be a string.\")\n\9\9\9local _obj = obj\n\9\9\9local _arg0_1 = not (objToId[_obj] ~= nil)\n\9\9\9assert(_arg0_1, \"obj is already registered.\")\n\9\9\9local _value_1 = value\n\9\9\9local _arg0_2 = not (idToObj[_value_1] ~= nil)\n\9\9\9assert(_arg0_2, \"id is already registered.\")\n\9\9\9local _obj_1 = obj\n\9\9\9local _value_2 = value\n\9\9\9objToId[_obj_1] = _value_2\n\9\9\9local _value_3 = value\n\9\9\9local _obj_2 = obj\n\9\9\9idToObj[_value_3] = _obj_2\n\9\9end\n\9\9local metadata = getObjMetadata(obj, property, true)\n\9\9local _key = key\n\9\9local _value = value\n\9\9metadata[_key] = _value\n\9end\n\9_container.defineMetadata = defineMetadata\n\9--[[\n\9\9*\n\9\9* Apply metadata in batch onto this object.\n\9]]\n\9local function defineMetadataBatch(obj, list, property)\n\9\9local metadata = getObjMetadata(obj, property, true)\n\9\9for key, value in pairs(list) do\n\9\9\9metadata[key] = value\n\9\9end\n\9end\n\9_container.defineMetadataBatch = defineMetadataBatch\n\9--[[\n\9\9*\n\9\9* Delete metadata from this object.\n\9]]\n\9local function deleteMetadata(obj, key, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _key = key\n\9\9\9_result[_key] = nil\n\9\9end\n\9end\n\9_container.deleteMetadata = deleteMetadata\n\9--[[\n\9\9*\n\9\9* Get metadata from this object.\n\9\9* Type parameter is an assertion.\n\9]]\n\9local function getOwnMetadata(obj, key, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _key = key\n\9\9\9_result = _result[_key]\n\9\9end\n\9\9return _result\n\9end\n\9_container.getOwnMetadata = getOwnMetadata\n\9--[[\n\9\9*\n\9\9* Check if this object has the specified metadata key.\n\9]]\n\9local function hasOwnMetadata(obj, key, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _key = key\n\9\9\9_result = _result[_key] ~= nil\n\9\9end\n\9\9local _condition = _result\n\9\9if _condition == nil then\n\9\9\9_condition = false\n\9\9end\n\9\9return _condition\n\9end\n\9_container.hasOwnMetadata = hasOwnMetadata\n\9--[[\n\9\9*\n\9\9* Retrieve all metadata keys for this object.\n\9]]\n\9local function getOwnMetadataKeys(obj, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local keys = {}\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _arg0 = function(_, key)\n\9\9\9\9local _key = key\n\9\9\9\9table.insert(keys, _key)\n\9\9\9\9return #keys\n\9\9\9end\n\9\9\9for _k, _v in _result do\n\9\9\9\9_arg0(_v, _k, _result)\n\9\9\9end\n\9\9end\n\9\9return keys\n\9end\n\9_container.getOwnMetadataKeys = getOwnMetadataKeys\n\9--[[\n\9\9*\n\9\9* Retrieves all properties (that contain metadata) on this object.\n\9]]\n\9local function getOwnProperties(obj)\n\9\9local _obj = obj\n\9\9local properties = metadata[_obj]\n\9\9if not properties then\n\9\9\9return {}\n\9\9end\n\9\9local keys = {}\n\9\9for key in properties do\n\9\9\9if key ~= NO_PROP_MARKER then\n\9\9\9\9table.insert(keys, key)\n\9\9\9end\n\9\9end\n\9\9return keys\n\9end\n\9_container.getOwnProperties = getOwnProperties\n\9--[[\n\9\9*\n\9\9* Retrieve all values for the specified key from the object and its parents.\n\9\9* Type parameter is an assertion.\n\9]]\n\9local function getMetadatas(obj, key, property)\n\9\9local values = {}\n\9\9local value = getOwnMetadata(obj, key, property)\n\9\9if value ~= nil then\n\9\9\9table.insert(values, value)\n\9\9end\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9local _exp = getMetadatas(parent, key, property)\n\9\9\9local _arg0 = function(value)\n\9\9\9\9local _value = value\n\9\9\9\9table.insert(values, _value)\n\9\9\9\9return #values\n\9\9\9end\n\9\9\9for _k, _v in _exp do\n\9\9\9\9_arg0(_v, _k - 1, _exp)\n\9\9\9end\n\9\9end\n\9\9return values\n\9end\n\9_container.getMetadatas = getMetadatas\n\9--[[\n\9\9*\n\9\9* Get metadata from this object or its parents.\n\9\9* Type parameter is an assertion.\n\9]]\n\9local function getMetadata(obj, key, property)\n\9\9local value = getOwnMetadata(obj, key, property)\n\9\9if value ~= nil then\n\9\9\9return value\n\9\9end\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9return getMetadata(parent, key, property)\n\9\9end\n\9end\n\9_container.getMetadata = getMetadata\n\9--[[\n\9\9*\n\9\9* Check if this object or any of its parents has the specified metadata key.\n\9]]\n\9local function hasMetadata(obj, key, property)\n\9\9local value = hasOwnMetadata(obj, key, property)\n\9\9if value then\n\9\9\9return value\n\9\9end\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9return hasMetadata(parent, key, property)\n\9\9end\n\9\9return false\n\9end\n\9_container.hasMetadata = hasMetadata\n\9--[[\n\9\9*\n\9\9* Retrieve all metadata keys for this object and its parents.\n\9]]\n\9local function getMetadataKeys(obj, property)\n\9\9local _set = {}\n\9\9for _, _v in getOwnMetadataKeys(obj, property) do\n\9\9\9_set[_v] = true\n\9\9end\n\9\9local keys = _set\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9local _exp = getMetadataKeys(parent, property)\n\9\9\9local _arg0 = function(key)\n\9\9\9\9local _key = key\n\9\9\9\9keys[_key] = true\n\9\9\9\9return keys\n\9\9\9end\n\9\9\9for _k, _v in _exp do\n\9\9\9\9_arg0(_v, _k - 1, _exp)\n\9\9\9end\n\9\9end\n\9\9local _array = {}\n\9\9local _length = #_array\n\9\9for _v in keys do\n\9\9\9_length += 1\n\9\9\9_array[_length] = _v\n\9\9end\n\9\9return _array\n\9end\n\9_container.getMetadataKeys = getMetadataKeys\n\9--[[\n\9\9*\n\9\9* Retrieves all properties (that contain metadata) on this object and its parents.\n\9]]\n\9local function getProperties(obj)\n\9\9local _set = {}\n\9\9for _, _v in getOwnProperties(obj) do\n\9\9\9_set[_v] = true\n\9\9end\n\9\9local keys = _set\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9local _exp = getProperties(parent)\n\9\9\9local _arg0 = function(key)\n\9\9\9\9local _key = key\n\9\9\9\9keys[_key] = true\n\9\9\9\9return keys\n\9\9\9end\n\9\9\9for _k, _v in _exp do\n\9\9\9\9_arg0(_v, _k - 1, _exp)\n\9\9\9end\n\9\9end\n\9\9local _array = {}\n\9\9local _length = #_array\n\9\9for _v in keys do\n\9\9\9_length += 1\n\9\9\9_array[_length] = _v\n\9\9end\n\9\9return _array\n\9end\n\9_container.getProperties = getProperties\n\9-- * @hidden\n\9local function decorate(object, id, rawDecoration, args, property, isStatic)\n\9\9if isStatic == nil then\n\9\9\9isStatic = false\n\9\9end\n\9\9local decoration = rawDecoration\n\9\9local descriptor = {\n\9\9\9id = id,\n\9\9\9isStatic = isStatic,\n\9\9\9object = object,\n\9\9\9property = property,\n\9\9}\n\9\9if property == nil then\n\9\9\9local _id = id\n\9\9\9local decoratedObjects = decorators[_id]\n\9\9\9if not decoratedObjects then\n\9\9\9\9local _exp = id\n\9\9\9\9decoratedObjects = {}\n\9\9\9\9local _decoratedObjects = decoratedObjects\n\9\9\9\9decorators[_exp] = _decoratedObjects\n\9\9\9end\n\9\9\9local _decoratedObjects = decoratedObjects\n\9\9\9local _object = object\n\9\9\9table.insert(_decoratedObjects, _object)\n\9\9end\n\9\9decoration.func(descriptor, args)\n\9end\n\9_container.decorate = decorate\nend\nreturn {\n\9Reflect = Reflect,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.reflect"))(__env)
end)
__rbx("@rbxts", "Folder", "bundle-ex.include.node_modules.@rbxts", "bundle-ex.include.node_modules")
__rbx("compiler-types", "Folder", "bundle-ex.include.node_modules.@rbxts.compiler-types", "bundle-ex.include.node_modules.@rbxts")
__rbx("types", "Folder", "bundle-ex.include.node_modules.@rbxts.compiler-types.types", "bundle-ex.include.node_modules.@rbxts.compiler-types")
__rbx("hax", "Folder", "bundle-ex.include.node_modules.@rbxts.hax", "bundle-ex.include.node_modules.@rbxts")
__lua("package-lock", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.hax.package-lock", "bundle-ex.include.node_modules.@rbxts.hax", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.hax.package-lock\")local script,require=_.script,_.require return {\n\9dependencies = {\n\9\9[\"@eslint/eslintrc\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-lTVWHs7O2hjBFZunXTZYnYqtB9GakA1lnxIf+gKq2nY5gxkkNi/lQvveW6t8gFdOHTg6nG50Xs95PrLqVpcaLg==\",\n\9\9\9requires = {\n\9\9\9\9ajv = \"^6.12.4\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9espree = \"^9.3.1\",\n\9\9\9\9globals = \"^13.9.0\",\n\9\9\9\9ignore = \"^5.2.0\",\n\9\9\9\9[\"import-fresh\"] = \"^3.2.1\",\n\9\9\9\9[\"js-yaml\"] = \"^4.1.0\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9\9[\"strip-json-comments\"] = \"^3.1.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-1.2.2.tgz\",\n\9\9\9version = \"1.2.2\",\n\9\9},\n\9\9[\"@humanwhocodes/config-array\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-ObyMyWxZiCu/yTisA7uzx81s40xR2fD5Cg/2Kq7G02ajkNubJf6BopgDTmDyc3U7sXpNKM8cYOw7s7Tyr+DnCw==\",\n\9\9\9requires = {\n\9\9\9\9[\"@humanwhocodes/object-schema\"] = \"^1.2.1\",\n\9\9\9\9debug = \"^4.1.1\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.9.5.tgz\",\n\9\9\9version = \"0.9.5\",\n\9\9},\n\9\9[\"@humanwhocodes/object-schema\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz\",\n\9\9\9version = \"1.2.1\",\n\9\9},\n\9\9[\"@nodelib/fs.scandir\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==\",\n\9\9\9requires = {\n\9\9\9\9[\"@nodelib/fs.stat\"] = \"2.0.5\",\n\9\9\9\9[\"run-parallel\"] = \"^1.1.9\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz\",\n\9\9\9version = \"2.1.5\",\n\9\9},\n\9\9[\"@nodelib/fs.stat\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz\",\n\9\9\9version = \"2.0.5\",\n\9\9},\n\9\9[\"@nodelib/fs.walk\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==\",\n\9\9\9requires = {\n\9\9\9\9[\"@nodelib/fs.scandir\"] = \"2.1.5\",\n\9\9\9\9fastq = \"^1.6.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz\",\n\9\9\9version = \"1.2.8\",\n\9\9},\n\9\9[\"@rbxts/compiler-types\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-iWeioe5WziBTnY+FIT7aQ5bimlw81PYZ5d9WO0h1kX3joEigXPQpn2yHGRxzrqIssqQr47Y6fwknklaaQ6IPMQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@rbxts/compiler-types/-/compiler-types-1.3.3-types.1.tgz\",\n\9\9\9version = \"1.3.3-types.1\",\n\9\9},\n\9\9[\"@rbxts/types\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-dRZt8VJuh8nRNiMtsgjPpEKPr/3Bko2KsB/R9l5yPrdgU7d+uHDV6hdx77NW+q/9u017q8tt6GBL5CNniRk70g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@rbxts/types/-/types-1.0.589.tgz\",\n\9\9\9version = \"1.0.589\",\n\9\9},\n\9\9[\"@types/json-schema\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-wOuvG1SN4Us4rez+tylwwwCV1psiNVOkJeM3AUWUNWg/jDQY2+HE/444y5gc+jBmRqASOm2Oeh5c1axHobwRKQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.11.tgz\",\n\9\9\9version = \"7.0.11\",\n\9\9},\n\9\9[\"@types/node\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-0PJ0vg+JyU0MIan58IOIFRtSvsb7Ri+7Wltx2qAg94eMOrpg4+uuP3aUHCpxXc1i0jCXiC+zIamSZh3l9AbcQA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@types/node/-/node-16.11.33.tgz\",\n\9\9\9version = \"16.11.33\",\n\9\9},\n\9\9[\"@typescript-eslint/eslint-plugin\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-YCiy5PUzpAeOPGQ7VSGDEY2NeYUV1B0swde2e0HzokRsHBYjSdF6DZ51OuRZxVPHx0032lXGLvOMls91D8FXlg==\",\n\9\9\9requires = {\n\9\9\9\9[\"@typescript-eslint/scope-manager\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/type-utils\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/utils\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9[\"functional-red-black-tree\"] = \"^1.0.1\",\n\9\9\9\9ignore = \"^5.1.8\",\n\9\9\9\9regexpp = \"^3.2.0\",\n\9\9\9\9semver = \"^7.3.5\",\n\9\9\9\9tsutils = \"^3.21.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/experimental-utils\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-rKxoCUtAHwEH6IcAoVpqipY6Th+YKW7WFspAKu0IFdbdKZpveFBeqxxE9Xn+GWikhq1o03V3VXbxIe+GdhggiQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"@typescript-eslint/utils\"] = \"5.22.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/parser\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-piwC4krUpRDqPaPbFaycN70KCP87+PC5WZmrWs+DlVOxxmF+zI6b6hETv7Quy4s9wbkV16ikMeZgXsvzwI3icQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"@typescript-eslint/scope-manager\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/typescript-estree\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/scope-manager\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-yA9G5NJgV5esANJCO0oF15MkBO20mIskbZ8ijfmlKIvQKg0ynVKfHZ15/nhAJN5m8Jn3X5qkwriQCiUntC9AbA==\",\n\9\9\9requires = {\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/visitor-keys\"] = \"5.22.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/type-utils\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-iqfLZIsZhK2OEJ4cQ01xOq3NaCuG5FQRKyHicA3xhZxMgaxQazLUHbH/B2k9y5i7l3+o+B5ND9Mf1AWETeMISA==\",\n\9\9\9requires = {\n\9\9\9\9[\"@typescript-eslint/utils\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9tsutils = \"^3.21.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/types\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-T7owcXW4l0v7NTijmjGWwWf/1JqdlWiBzPqzAWhobxft0SiEvMJB56QXmeCQjrPuM8zEfGUKyPQr/L8+cFUBLw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/types/-/types-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/typescript-estree\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-EyBEQxvNjg80yinGE2xdhpDYm41so/1kOItl0qrjIiJ1kX/L/L8WWGmJg8ni6eG3DwqmOzDqOhe6763bF92nOw==\",\n\9\9\9requires = {\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/visitor-keys\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9globby = \"^11.0.4\",\n\9\9\9\9[\"is-glob\"] = \"^4.0.3\",\n\9\9\9\9semver = \"^7.3.5\",\n\9\9\9\9tsutils = \"^3.21.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/utils\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-HodsGb037iobrWSUMS7QH6Hl1kppikjA1ELiJlNSTYf/UdMEwzgj0WIp+lBNb6WZ3zTwb0tEz51j0Wee3iJ3wQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"@types/json-schema\"] = \"^7.0.9\",\n\9\9\9\9[\"@typescript-eslint/scope-manager\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/typescript-estree\"] = \"5.22.0\",\n\9\9\9\9[\"eslint-scope\"] = \"^5.1.1\",\n\9\9\9\9[\"eslint-utils\"] = \"^3.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/utils/-/utils-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"@typescript-eslint/visitor-keys\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-DbgTqn2Dv5RFWluG88tn0pP6Ex0ROF+dpDO1TNNZdRtLjUr6bdznjA6f/qNqJLjd2PgguAES2Zgxh/JzwzETDg==\",\n\9\9\9requires = {\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^3.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9acorn = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-Xx54uLJQZ19lKygFXOWsscKUbsBZW0CPykPhVQdhIeIwrbPmJzqeASDInc8nKBnp/JT6igTs82qPXz069H8I/A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/acorn/-/acorn-8.7.1.tgz\",\n\9\9\9version = \"8.7.1\",\n\9\9},\n\9\9[\"acorn-jsx\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==\",\n\9\9\9requires = {\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz\",\n\9\9\9version = \"5.3.2\",\n\9\9},\n\9\9ajv = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==\",\n\9\9\9requires = {\n\9\9\9\9[\"fast-deep-equal\"] = \"^3.1.1\",\n\9\9\9\9[\"fast-json-stable-stringify\"] = \"^2.0.0\",\n\9\9\9\9[\"json-schema-traverse\"] = \"^0.4.1\",\n\9\9\9\9[\"uri-js\"] = \"^4.2.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz\",\n\9\9\9version = \"6.12.6\",\n\9\9},\n\9\9[\"ansi-regex\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n\9\9\9version = \"5.0.1\",\n\9\9},\n\9\9[\"ansi-styles\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==\",\n\9\9\9requires = {\n\9\9\9\9[\"color-convert\"] = \"^2.0.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz\",\n\9\9\9version = \"4.3.0\",\n\9\9},\n\9\9argparse = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz\",\n\9\9\9version = \"2.0.1\",\n\9\9},\n\9\9[\"array-union\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz\",\n\9\9\9version = \"2.1.0\",\n\9\9},\n\9\9[\"balanced-match\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n\9\9\9version = \"1.0.2\",\n\9\9},\n\9\9[\"brace-expansion\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n\9\9\9requires = {\n\9\9\9\9[\"balanced-match\"] = \"^1.0.0\",\n\9\9\9\9[\"concat-map\"] = \"0.0.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n\9\9\9version = \"1.1.11\",\n\9\9},\n\9\9braces = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==\",\n\9\9\9requires = {\n\9\9\9\9[\"fill-range\"] = \"^7.0.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/braces/-/braces-3.0.2.tgz\",\n\9\9\9version = \"3.0.2\",\n\9\9},\n\9\9callsites = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz\",\n\9\9\9version = \"3.1.0\",\n\9\9},\n\9\9chalk = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==\",\n\9\9\9requires = {\n\9\9\9\9[\"ansi-styles\"] = \"^4.1.0\",\n\9\9\9\9[\"supports-color\"] = \"^7.1.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz\",\n\9\9\9version = \"4.1.2\",\n\9\9},\n\9\9[\"color-convert\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"color-name\"] = \"~1.1.4\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",\n\9\9\9version = \"2.0.1\",\n\9\9},\n\9\9[\"color-name\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",\n\9\9\9version = \"1.1.4\",\n\9\9},\n\9\9[\"concat-map\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=\",\n\9\9\9resolved = \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n\9\9\9version = \"0.0.1\",\n\9\9},\n\9\9[\"cross-spawn\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==\",\n\9\9\9requires = {\n\9\9\9\9[\"path-key\"] = \"^3.1.0\",\n\9\9\9\9[\"shebang-command\"] = \"^2.0.0\",\n\9\9\9\9which = \"^2.0.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz\",\n\9\9\9version = \"7.0.3\",\n\9\9},\n\9\9debug = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==\",\n\9\9\9requires = {\n\9\9\9\9ms = \"2.1.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/debug/-/debug-4.3.4.tgz\",\n\9\9\9version = \"4.3.4\",\n\9\9},\n\9\9[\"deep-is\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz\",\n\9\9\9version = \"0.1.4\",\n\9\9},\n\9\9[\"dir-glob\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==\",\n\9\9\9requires = {\n\9\9\9\9[\"path-type\"] = \"^4.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz\",\n\9\9\9version = \"3.0.1\",\n\9\9},\n\9\9doctrine = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==\",\n\9\9\9requires = {\n\9\9\9\9esutils = \"^2.0.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9[\"escape-string-regexp\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9eslint = {\n\9\9\9dependencies = {\n\9\9\9\9[\"eslint-scope\"] = {\n\9\9\9\9\9dev = true,\n\9\9\9\9\9integrity = \"sha512-QKQM/UXpIiHcLqJ5AOyIW7XZmzjkzQXYE54n1++wb0u9V/abW3l9uQnxX8Z5Xd18xyKIMTUAyQ0k1e8pz6LUrw==\",\n\9\9\9\9\9requires = {\n\9\9\9\9\9\9esrecurse = \"^4.3.0\",\n\9\9\9\9\9\9estraverse = \"^5.2.0\",\n\9\9\9\9\9},\n\9\9\9\9\9resolved = \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-7.1.1.tgz\",\n\9\9\9\9\9version = \"7.1.1\",\n\9\9\9\9},\n\9\9\9\9estraverse = {\n\9\9\9\9\9dev = true,\n\9\9\9\9\9integrity = \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n\9\9\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n\9\9\9\9\9version = \"5.3.0\",\n\9\9\9\9},\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-3/CE4aJX7LNEiE3i6FeodHmI/38GZtWCsAtsymScmzYapx8q1nVVb+eLcLSzATmCPXw5pT4TqVs1E0OmxAd9tw==\",\n\9\9\9requires = {\n\9\9\9\9[\"@eslint/eslintrc\"] = \"^1.2.2\",\n\9\9\9\9[\"@humanwhocodes/config-array\"] = \"^0.9.2\",\n\9\9\9\9ajv = \"^6.10.0\",\n\9\9\9\9chalk = \"^4.0.0\",\n\9\9\9\9[\"cross-spawn\"] = \"^7.0.2\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9doctrine = \"^3.0.0\",\n\9\9\9\9[\"escape-string-regexp\"] = \"^4.0.0\",\n\9\9\9\9[\"eslint-scope\"] = \"^7.1.1\",\n\9\9\9\9[\"eslint-utils\"] = \"^3.0.0\",\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^3.3.0\",\n\9\9\9\9espree = \"^9.3.1\",\n\9\9\9\9esquery = \"^1.4.0\",\n\9\9\9\9esutils = \"^2.0.2\",\n\9\9\9\9[\"fast-deep-equal\"] = \"^3.1.3\",\n\9\9\9\9[\"file-entry-cache\"] = \"^6.0.1\",\n\9\9\9\9[\"functional-red-black-tree\"] = \"^1.0.1\",\n\9\9\9\9[\"glob-parent\"] = \"^6.0.1\",\n\9\9\9\9globals = \"^13.6.0\",\n\9\9\9\9ignore = \"^5.2.0\",\n\9\9\9\9[\"import-fresh\"] = \"^3.0.0\",\n\9\9\9\9imurmurhash = \"^0.1.4\",\n\9\9\9\9[\"is-glob\"] = \"^4.0.0\",\n\9\9\9\9[\"js-yaml\"] = \"^4.1.0\",\n\9\9\9\9[\"json-stable-stringify-without-jsonify\"] = \"^1.0.1\",\n\9\9\9\9levn = \"^0.4.1\",\n\9\9\9\9[\"lodash.merge\"] = \"^4.6.2\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9\9[\"natural-compare\"] = \"^1.4.0\",\n\9\9\9\9optionator = \"^0.9.1\",\n\9\9\9\9regexpp = \"^3.2.0\",\n\9\9\9\9[\"strip-ansi\"] = \"^6.0.1\",\n\9\9\9\9[\"strip-json-comments\"] = \"^3.1.0\",\n\9\9\9\9[\"text-table\"] = \"^0.2.0\",\n\9\9\9\9[\"v8-compile-cache\"] = \"^2.0.3\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint/-/eslint-8.14.0.tgz\",\n\9\9\9version = \"8.14.0\",\n\9\9},\n\9\9[\"eslint-config-prettier\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-obmWKLUNCnhtQRKc+tmnYuQl0pFU1ibYJQ5BGhTVB08bHe9wC8qUeG7c08dj9XX+AuPj1YSGSQIHl1pnDHZR0Q==\",\n\9\9\9requires = {\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-8.5.0.tgz\",\n\9\9\9version = \"8.5.0\",\n\9\9},\n\9\9[\"eslint-plugin-prettier\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-98MqmCJ7vJodoQK359bqQWaxOE0CS8paAz/GgjaZLyex4TTk3g9HugoO89EqWCrFiOqn9EVvcoo7gZzONCWVwQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"prettier-linter-helpers\"] = \"^1.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-plugin-prettier/-/eslint-plugin-prettier-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9[\"eslint-plugin-roblox-ts\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-zbwahPiQha5KGwY/J3pVXtyR4ORBSP8qouc4DGfnyGcdz0HOFFu+sACWX2u7/c4HVymtZlKRkTL4uR5qZ+THgg==\",\n\9\9\9requires = {\n\9\9\9\9[\"@types/node\"] = \"^16.10.4\",\n\9\9\9\9[\"@typescript-eslint/experimental-utils\"] = \"^5.0.0\",\n\9\9\9\9typescript = \"^4.4.4\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-plugin-roblox-ts/-/eslint-plugin-roblox-ts-0.0.32.tgz\",\n\9\9\9version = \"0.0.32\",\n\9\9},\n\9\9[\"eslint-scope\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==\",\n\9\9\9requires = {\n\9\9\9\9esrecurse = \"^4.3.0\",\n\9\9\9\9estraverse = \"^4.1.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz\",\n\9\9\9version = \"5.1.1\",\n\9\9},\n\9\9[\"eslint-utils\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"eslint-visitor-keys\"] = {\n\9\9\9\9\9dev = true,\n\9\9\9\9\9integrity = \"sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==\",\n\9\9\9\9\9resolved = \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz\",\n\9\9\9\9\9version = \"2.1.0\",\n\9\9\9\9},\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-uuQC43IGctw68pJA1RgbQS8/NP7rch6Cwd4j3ZBtgo4/8Flj4eGE7ZYSZRN3iq5pVUv6GPdW5Z1RFleo84uLDA==\",\n\9\9\9requires = {\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^2.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-utils/-/eslint-utils-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9[\"eslint-visitor-keys\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-mQ+suqKJVyeuwGYHAdjMFqjCyfl8+Ldnxuyp3ldiMBFKkvytrXUZWaiPCEav8qDHKty44bD+qV1IP4T+w+xXRA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.3.0.tgz\",\n\9\9\9version = \"3.3.0\",\n\9\9},\n\9\9espree = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-bvdyLmJMfwkV3NCRl5ZhJf22zBFo1y8bYh3VYb+bfzqNB4Je68P2sSuXyuFquzWLebHpNd2/d5uv7yoP9ISnGQ==\",\n\9\9\9requires = {\n\9\9\9\9acorn = \"^8.7.0\",\n\9\9\9\9[\"acorn-jsx\"] = \"^5.3.1\",\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^3.3.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/espree/-/espree-9.3.1.tgz\",\n\9\9\9version = \"9.3.1\",\n\9\9},\n\9\9esquery = {\n\9\9\9dependencies = {\n\9\9\9\9estraverse = {\n\9\9\9\9\9dev = true,\n\9\9\9\9\9integrity = \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n\9\9\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n\9\9\9\9\9version = \"5.3.0\",\n\9\9\9\9},\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-cCDispWt5vHHtwMY2YrAQ4ibFkAL8RbH5YGBnZBc90MolvvfkkQcJro/aZiAQUlQ3qgrYS6D6v8Gc5G5CQsc9w==\",\n\9\9\9requires = {\n\9\9\9\9estraverse = \"^5.1.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/esquery/-/esquery-1.4.0.tgz\",\n\9\9\9version = \"1.4.0\",\n\9\9},\n\9\9esrecurse = {\n\9\9\9dependencies = {\n\9\9\9\9estraverse = {\n\9\9\9\9\9dev = true,\n\9\9\9\9\9integrity = \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n\9\9\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n\9\9\9\9\9version = \"5.3.0\",\n\9\9\9\9},\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==\",\n\9\9\9requires = {\n\9\9\9\9estraverse = \"^5.2.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz\",\n\9\9\9version = \"4.3.0\",\n\9\9},\n\9\9estraverse = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz\",\n\9\9\9version = \"4.3.0\",\n\9\9},\n\9\9esutils = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz\",\n\9\9\9version = \"2.0.3\",\n\9\9},\n\9\9[\"fast-deep-equal\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\",\n\9\9\9version = \"3.1.3\",\n\9\9},\n\9\9[\"fast-diff\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-xJuoT5+L99XlZ8twedaRf6Ax2TgQVxvgZOYoPKqZufmJib0tL2tegPBOZb1pVNgIhlqDlA0eO0c3wBvQcmzx4w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-diff/-/fast-diff-1.2.0.tgz\",\n\9\9\9version = \"1.2.0\",\n\9\9},\n\9\9[\"fast-glob\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"glob-parent\"] = {\n\9\9\9\9\9dev = true,\n\9\9\9\9\9integrity = \"sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==\",\n\9\9\9\9\9requires = {\n\9\9\9\9\9\9[\"is-glob\"] = \"^4.0.1\",\n\9\9\9\9\9},\n\9\9\9\9\9resolved = \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz\",\n\9\9\9\9\9version = \"5.1.2\",\n\9\9\9\9},\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-xrO3+1bxSo3ZVHAnqzyuewYT6aMFHRAd4Kcs92MAonjwQZLsK9d0SF1IyQ3k5PoirxTW0Oe/RqFgMQ6TcNE5Ew==\",\n\9\9\9requires = {\n\9\9\9\9[\"@nodelib/fs.stat\"] = \"^2.0.2\",\n\9\9\9\9[\"@nodelib/fs.walk\"] = \"^1.2.3\",\n\9\9\9\9[\"glob-parent\"] = \"^5.1.2\",\n\9\9\9\9merge2 = \"^1.3.0\",\n\9\9\9\9micromatch = \"^4.0.4\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.11.tgz\",\n\9\9\9version = \"3.2.11\",\n\9\9},\n\9\9[\"fast-json-stable-stringify\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz\",\n\9\9\9version = \"2.1.0\",\n\9\9},\n\9\9[\"fast-levenshtein\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz\",\n\9\9\9version = \"2.0.6\",\n\9\9},\n\9\9fastq = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-YpkpUnK8od0o1hmeSc7UUs/eB/vIPWJYjKck2QKIzAf71Vm1AAQ3EbuZB3g2JIy+pg+ERD0vqI79KyZiB2e2Nw==\",\n\9\9\9requires = {\n\9\9\9\9reusify = \"^1.0.4\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/fastq/-/fastq-1.13.0.tgz\",\n\9\9\9version = \"1.13.0\",\n\9\9},\n\9\9[\"file-entry-cache\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==\",\n\9\9\9requires = {\n\9\9\9\9[\"flat-cache\"] = \"^3.0.4\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz\",\n\9\9\9version = \"6.0.1\",\n\9\9},\n\9\9[\"fill-range\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"to-regex-range\"] = \"^5.0.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz\",\n\9\9\9version = \"7.0.1\",\n\9\9},\n\9\9[\"flat-cache\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==\",\n\9\9\9requires = {\n\9\9\9\9flatted = \"^3.1.0\",\n\9\9\9\9rimraf = \"^3.0.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz\",\n\9\9\9version = \"3.0.4\",\n\9\9},\n\9\9flatted = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-WIWGi2L3DyTUvUrwRKgGi9TwxQMUEqPOPQBVi71R96jZXJdFskXEmf54BoZaS1kknGODoIGASGEzBUYdyMCBJg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/flatted/-/flatted-3.2.5.tgz\",\n\9\9\9version = \"3.2.5\",\n\9\9},\n\9\9[\"fs.realpath\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-FQStJSMVjKpA20onh8sBQRmU6k8=\",\n\9\9\9resolved = \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n\9\9\9version = \"1.0.0\",\n\9\9},\n\9\9[\"functional-red-black-tree\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=\",\n\9\9\9resolved = \"https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9glob = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-lmLf6gtyrPq8tTjSmrO94wBeQbFR3HbLHbuyD69wuyQkImp2hWqMGB47OX65FBkPffO641IP9jWa1z4ivqG26Q==\",\n\9\9\9requires = {\n\9\9\9\9[\"fs.realpath\"] = \"^1.0.0\",\n\9\9\9\9inflight = \"^1.0.4\",\n\9\9\9\9inherits = \"2\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9\9once = \"^1.3.0\",\n\9\9\9\9[\"path-is-absolute\"] = \"^1.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/glob/-/glob-7.2.0.tgz\",\n\9\9\9version = \"7.2.0\",\n\9\9},\n\9\9[\"glob-parent\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==\",\n\9\9\9requires = {\n\9\9\9\9[\"is-glob\"] = \"^4.0.3\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz\",\n\9\9\9version = \"6.0.2\",\n\9\9},\n\9\9globals = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-EQ7Q18AJlPwp3vUDL4mKA0KXrXyNIQyWon6T6XQiBQF0XHvRsiCSrWmmeATpUzdJN2HhWZU6Pdl0a9zdep5p6A==\",\n\9\9\9requires = {\n\9\9\9\9[\"type-fest\"] = \"^0.20.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/globals/-/globals-13.13.0.tgz\",\n\9\9\9version = \"13.13.0\",\n\9\9},\n\9\9globby = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==\",\n\9\9\9requires = {\n\9\9\9\9[\"array-union\"] = \"^2.1.0\",\n\9\9\9\9[\"dir-glob\"] = \"^3.0.1\",\n\9\9\9\9[\"fast-glob\"] = \"^3.2.9\",\n\9\9\9\9ignore = \"^5.2.0\",\n\9\9\9\9merge2 = \"^1.4.1\",\n\9\9\9\9slash = \"^3.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/globby/-/globby-11.1.0.tgz\",\n\9\9\9version = \"11.1.0\",\n\9\9},\n\9\9[\"has-flag\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9ignore = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-CmxgYGiEPCLhfLnpPp1MoRmifwEIOgjcHXxOBjv7mY96c+eWScsOP9c112ZyLdWHi0FxHjI+4uVhKYp/gcdRmQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ignore/-/ignore-5.2.0.tgz\",\n\9\9\9version = \"5.2.0\",\n\9\9},\n\9\9[\"import-fresh\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==\",\n\9\9\9requires = {\n\9\9\9\9[\"parent-module\"] = \"^1.0.0\",\n\9\9\9\9[\"resolve-from\"] = \"^4.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz\",\n\9\9\9version = \"3.3.0\",\n\9\9},\n\9\9imurmurhash = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-khi5srkoojixPcT7a21XbyMUU+o=\",\n\9\9\9resolved = \"https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz\",\n\9\9\9version = \"0.1.4\",\n\9\9},\n\9\9inflight = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\",\n\9\9\9requires = {\n\9\9\9\9once = \"^1.3.0\",\n\9\9\9\9wrappy = \"1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n\9\9\9version = \"1.0.6\",\n\9\9},\n\9\9inherits = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n\9\9\9version = \"2.0.4\",\n\9\9},\n\9\9[\"is-extglob\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=\",\n\9\9\9resolved = \"https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz\",\n\9\9\9version = \"2.1.1\",\n\9\9},\n\9\9[\"is-glob\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==\",\n\9\9\9requires = {\n\9\9\9\9[\"is-extglob\"] = \"^2.1.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz\",\n\9\9\9version = \"4.0.3\",\n\9\9},\n\9\9[\"is-number\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==\",\n\9\9\9resolved = \"https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz\",\n\9\9\9version = \"7.0.0\",\n\9\9},\n\9\9isexe = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=\",\n\9\9\9resolved = \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n\9\9\9version = \"2.0.0\",\n\9\9},\n\9\9[\"js-yaml\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==\",\n\9\9\9requires = {\n\9\9\9\9argparse = \"^2.0.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz\",\n\9\9\9version = \"4.1.0\",\n\9\9},\n\9\9[\"json-schema-traverse\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz\",\n\9\9\9version = \"0.4.1\",\n\9\9},\n\9\9[\"json-stable-stringify-without-jsonify\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=\",\n\9\9\9resolved = \"https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9levn = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"prelude-ls\"] = \"^1.2.1\",\n\9\9\9\9[\"type-check\"] = \"~0.4.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/levn/-/levn-0.4.1.tgz\",\n\9\9\9version = \"0.4.1\",\n\9\9},\n\9\9[\"lodash.merge\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz\",\n\9\9\9version = \"4.6.2\",\n\9\9},\n\9\9[\"lru-cache\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==\",\n\9\9\9requires = {\n\9\9\9\9yallist = \"^4.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz\",\n\9\9\9version = \"6.0.0\",\n\9\9},\n\9\9merge2 = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz\",\n\9\9\9version = \"1.4.1\",\n\9\9},\n\9\9micromatch = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==\",\n\9\9\9requires = {\n\9\9\9\9braces = \"^3.0.2\",\n\9\9\9\9picomatch = \"^2.3.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz\",\n\9\9\9version = \"4.0.5\",\n\9\9},\n\9\9minimatch = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n\9\9\9requires = {\n\9\9\9\9[\"brace-expansion\"] = \"^1.1.7\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n\9\9\9version = \"3.1.2\",\n\9\9},\n\9\9ms = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\",\n\9\9\9version = \"2.1.2\",\n\9\9},\n\9\9[\"natural-compare\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=\",\n\9\9\9resolved = \"https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz\",\n\9\9\9version = \"1.4.0\",\n\9\9},\n\9\9once = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\",\n\9\9\9requires = {\n\9\9\9\9wrappy = \"1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n\9\9\9version = \"1.4.0\",\n\9\9},\n\9\9optionator = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==\",\n\9\9\9requires = {\n\9\9\9\9[\"deep-is\"] = \"^0.1.3\",\n\9\9\9\9[\"fast-levenshtein\"] = \"^2.0.6\",\n\9\9\9\9levn = \"^0.4.1\",\n\9\9\9\9[\"prelude-ls\"] = \"^1.2.1\",\n\9\9\9\9[\"type-check\"] = \"^0.4.0\",\n\9\9\9\9[\"word-wrap\"] = \"^1.2.3\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz\",\n\9\9\9version = \"0.9.1\",\n\9\9},\n\9\9[\"parent-module\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==\",\n\9\9\9requires = {\n\9\9\9\9callsites = \"^3.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9[\"path-is-absolute\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-F0uSaHNVNP+8es5r9TpanhtcX18=\",\n\9\9\9resolved = \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9[\"path-key\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n\9\9\9version = \"3.1.1\",\n\9\9},\n\9\9[\"path-type\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9picomatch = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz\",\n\9\9\9version = \"2.3.1\",\n\9\9},\n\9\9[\"prelude-ls\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz\",\n\9\9\9version = \"1.2.1\",\n\9\9},\n\9\9prettier = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-PkUpF+qoXTqhOeWL9fu7As8LXsIUZ1WYaJiY/a7McAQzxjk82OF0tibkFXVCDImZtWxbvojFjerkiLb0/q8mew==\",\n\9\9\9resolved = \"https://registry.npmjs.org/prettier/-/prettier-2.6.2.tgz\",\n\9\9\9version = \"2.6.2\",\n\9\9},\n\9\9[\"prettier-linter-helpers\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-GbK2cP9nraSSUF9N2XwUwqfzlAFlMNYYl+ShE/V+H8a9uNl/oUqB1w2EL54Jh0OlyRSd8RfWYJ3coVS4TROP2w==\",\n\9\9\9requires = {\n\9\9\9\9[\"fast-diff\"] = \"^1.1.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/prettier-linter-helpers/-/prettier-linter-helpers-1.0.0.tgz\",\n\9\9\9version = \"1.0.0\",\n\9\9},\n\9\9punycode = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz\",\n\9\9\9version = \"2.1.1\",\n\9\9},\n\9\9[\"queue-microtask\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz\",\n\9\9\9version = \"1.2.3\",\n\9\9},\n\9\9regexpp = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz\",\n\9\9\9version = \"3.2.0\",\n\9\9},\n\9\9[\"resolve-from\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9reusify = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz\",\n\9\9\9version = \"1.0.4\",\n\9\9},\n\9\9rimraf = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==\",\n\9\9\9requires = {\n\9\9\9\9glob = \"^7.1.3\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz\",\n\9\9\9version = \"3.0.2\",\n\9\9},\n\9\9[\"run-parallel\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==\",\n\9\9\9requires = {\n\9\9\9\9[\"queue-microtask\"] = \"^1.2.2\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz\",\n\9\9\9version = \"1.2.0\",\n\9\9},\n\9\9semver = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-QlYTucUYOews+WeEujDoEGziz4K6c47V/Bd+LjSSYcA94p+DmINdf7ncaUinThfvZyu13lN9OY1XDxt8C0Tw0g==\",\n\9\9\9requires = {\n\9\9\9\9[\"lru-cache\"] = \"^6.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/semver/-/semver-7.3.7.tgz\",\n\9\9\9version = \"7.3.7\",\n\9\9},\n\9\9[\"shebang-command\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n\9\9\9requires = {\n\9\9\9\9[\"shebang-regex\"] = \"^3.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n\9\9\9version = \"2.0.0\",\n\9\9},\n\9\9[\"shebang-regex\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9slash = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/slash/-/slash-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9[\"strip-ansi\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n\9\9\9requires = {\n\9\9\9\9[\"ansi-regex\"] = \"^5.0.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n\9\9\9version = \"6.0.1\",\n\9\9},\n\9\9[\"strip-json-comments\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==\",\n\9\9\9resolved = \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz\",\n\9\9\9version = \"3.1.1\",\n\9\9},\n\9\9[\"supports-color\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\",\n\9\9\9requires = {\n\9\9\9\9[\"has-flag\"] = \"^4.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",\n\9\9\9version = \"7.2.0\",\n\9\9},\n\9\9[\"text-table\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=\",\n\9\9\9resolved = \"https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz\",\n\9\9\9version = \"0.2.0\",\n\9\9},\n\9\9[\"to-regex-range\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==\",\n\9\9\9requires = {\n\9\9\9\9[\"is-number\"] = \"^7.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz\",\n\9\9\9version = \"5.0.1\",\n\9\9},\n\9\9tslib = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz\",\n\9\9\9version = \"1.14.1\",\n\9\9},\n\9\9tsutils = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==\",\n\9\9\9requires = {\n\9\9\9\9tslib = \"^1.8.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz\",\n\9\9\9version = \"3.21.0\",\n\9\9},\n\9\9[\"type-check\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==\",\n\9\9\9requires = {\n\9\9\9\9[\"prelude-ls\"] = \"^1.2.1\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz\",\n\9\9\9version = \"0.4.0\",\n\9\9},\n\9\9[\"type-fest\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz\",\n\9\9\9version = \"0.20.2\",\n\9\9},\n\9\9typescript = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-9ia/jWHIEbo49HfjrLGfKbZSuWo9iTMwXO+Ca3pRsSpbsMbc7/IU8NKdCZVRRBafVPGnoJeFL76ZOAA84I9fEg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/typescript/-/typescript-4.6.4.tgz\",\n\9\9\9version = \"4.6.4\",\n\9\9},\n\9\9[\"uri-js\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==\",\n\9\9\9requires = {\n\9\9\9\9punycode = \"^2.1.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz\",\n\9\9\9version = \"4.4.1\",\n\9\9},\n\9\9[\"v8-compile-cache\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz\",\n\9\9\9version = \"2.3.0\",\n\9\9},\n\9\9which = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n\9\9\9requires = {\n\9\9\9\9isexe = \"^2.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n\9\9\9version = \"2.0.2\",\n\9\9},\n\9\9[\"word-wrap\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz\",\n\9\9\9version = \"1.2.3\",\n\9\9},\n\9\9wrappy = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\",\n\9\9\9resolved = \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n\9\9\9version = \"1.0.2\",\n\9\9},\n\9\9yallist = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9},\n\9lockfileVersion = 2,\n\9name = \"@rbxts/hax\",\n\9packages = {\n\9\9[\"\"] = {\n\9\9\9devDependencies = {\n\9\9\9\9[\"@rbxts/compiler-types\"] = \"^1.3.3-types.1\",\n\9\9\9\9[\"@rbxts/types\"] = \"^1.0.589\",\n\9\9\9\9[\"@typescript-eslint/eslint-plugin\"] = \"^5.22.0\",\n\9\9\9\9[\"@typescript-eslint/parser\"] = \"^5.22.0\",\n\9\9\9\9eslint = \"^8.14.0\",\n\9\9\9\9[\"eslint-config-prettier\"] = \"^8.5.0\",\n\9\9\9\9[\"eslint-plugin-prettier\"] = \"^4.0.0\",\n\9\9\9\9[\"eslint-plugin-roblox-ts\"] = \"^0.0.32\",\n\9\9\9\9prettier = \"^2.6.2\",\n\9\9\9\9typescript = \"^4.6.4\",\n\9\9\9},\n\9\9\9license = \"MIT\",\n\9\9\9name = \"@rbxts/rbxts-hax\",\n\9\9\9version = \"1.1.0\",\n\9\9},\n\9\9[\"node_modules/@eslint/eslintrc\"] = {\n\9\9\9dependencies = {\n\9\9\9\9ajv = \"^6.12.4\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9espree = \"^9.3.1\",\n\9\9\9\9globals = \"^13.9.0\",\n\9\9\9\9ignore = \"^5.2.0\",\n\9\9\9\9[\"import-fresh\"] = \"^3.2.1\",\n\9\9\9\9[\"js-yaml\"] = \"^4.1.0\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9\9[\"strip-json-comments\"] = \"^3.1.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-lTVWHs7O2hjBFZunXTZYnYqtB9GakA1lnxIf+gKq2nY5gxkkNi/lQvveW6t8gFdOHTg6nG50Xs95PrLqVpcaLg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-1.2.2.tgz\",\n\9\9\9version = \"1.2.2\",\n\9\9},\n\9\9[\"node_modules/@humanwhocodes/config-array\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@humanwhocodes/object-schema\"] = \"^1.2.1\",\n\9\9\9\9debug = \"^4.1.1\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-ObyMyWxZiCu/yTisA7uzx81s40xR2fD5Cg/2Kq7G02ajkNubJf6BopgDTmDyc3U7sXpNKM8cYOw7s7Tyr+DnCw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.9.5.tgz\",\n\9\9\9version = \"0.9.5\",\n\9\9},\n\9\9[\"node_modules/@humanwhocodes/object-schema\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz\",\n\9\9\9version = \"1.2.1\",\n\9\9},\n\9\9[\"node_modules/@nodelib/fs.scandir\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@nodelib/fs.stat\"] = \"2.0.5\",\n\9\9\9\9[\"run-parallel\"] = \"^1.1.9\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz\",\n\9\9\9version = \"2.1.5\",\n\9\9},\n\9\9[\"node_modules/@nodelib/fs.stat\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz\",\n\9\9\9version = \"2.0.5\",\n\9\9},\n\9\9[\"node_modules/@nodelib/fs.walk\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@nodelib/fs.scandir\"] = \"2.1.5\",\n\9\9\9\9fastq = \"^1.6.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz\",\n\9\9\9version = \"1.2.8\",\n\9\9},\n\9\9[\"node_modules/@rbxts/compiler-types\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-iWeioe5WziBTnY+FIT7aQ5bimlw81PYZ5d9WO0h1kX3joEigXPQpn2yHGRxzrqIssqQr47Y6fwknklaaQ6IPMQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@rbxts/compiler-types/-/compiler-types-1.3.3-types.1.tgz\",\n\9\9\9version = \"1.3.3-types.1\",\n\9\9},\n\9\9[\"node_modules/@rbxts/types\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-dRZt8VJuh8nRNiMtsgjPpEKPr/3Bko2KsB/R9l5yPrdgU7d+uHDV6hdx77NW+q/9u017q8tt6GBL5CNniRk70g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@rbxts/types/-/types-1.0.589.tgz\",\n\9\9\9version = \"1.0.589\",\n\9\9},\n\9\9[\"node_modules/@types/json-schema\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-wOuvG1SN4Us4rez+tylwwwCV1psiNVOkJeM3AUWUNWg/jDQY2+HE/444y5gc+jBmRqASOm2Oeh5c1axHobwRKQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.11.tgz\",\n\9\9\9version = \"7.0.11\",\n\9\9},\n\9\9[\"node_modules/@types/node\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-0PJ0vg+JyU0MIan58IOIFRtSvsb7Ri+7Wltx2qAg94eMOrpg4+uuP3aUHCpxXc1i0jCXiC+zIamSZh3l9AbcQA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@types/node/-/node-16.11.33.tgz\",\n\9\9\9version = \"16.11.33\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/eslint-plugin\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@typescript-eslint/scope-manager\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/type-utils\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/utils\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9[\"functional-red-black-tree\"] = \"^1.0.1\",\n\9\9\9\9ignore = \"^5.1.8\",\n\9\9\9\9regexpp = \"^3.2.0\",\n\9\9\9\9semver = \"^7.3.5\",\n\9\9\9\9tsutils = \"^3.21.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-YCiy5PUzpAeOPGQ7VSGDEY2NeYUV1B0swde2e0HzokRsHBYjSdF6DZ51OuRZxVPHx0032lXGLvOMls91D8FXlg==\",\n\9\9\9peerDependencies = {\n\9\9\9\9[\"@typescript-eslint/parser\"] = \"^5.0.0\",\n\9\9\9\9eslint = \"^6.0.0 || ^7.0.0 || ^8.0.0\",\n\9\9\9},\n\9\9\9peerDependenciesMeta = {\n\9\9\9\9typescript = {\n\9\9\9\9\9optional = true,\n\9\9\9\9},\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/experimental-utils\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@typescript-eslint/utils\"] = \"5.22.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-rKxoCUtAHwEH6IcAoVpqipY6Th+YKW7WFspAKu0IFdbdKZpveFBeqxxE9Xn+GWikhq1o03V3VXbxIe+GdhggiQ==\",\n\9\9\9peerDependencies = {\n\9\9\9\9eslint = \"^6.0.0 || ^7.0.0 || ^8.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/parser\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@typescript-eslint/scope-manager\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/typescript-estree\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-piwC4krUpRDqPaPbFaycN70KCP87+PC5WZmrWs+DlVOxxmF+zI6b6hETv7Quy4s9wbkV16ikMeZgXsvzwI3icQ==\",\n\9\9\9peerDependencies = {\n\9\9\9\9eslint = \"^6.0.0 || ^7.0.0 || ^8.0.0\",\n\9\9\9},\n\9\9\9peerDependenciesMeta = {\n\9\9\9\9typescript = {\n\9\9\9\9\9optional = true,\n\9\9\9\9},\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/scope-manager\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/visitor-keys\"] = \"5.22.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-yA9G5NJgV5esANJCO0oF15MkBO20mIskbZ8ijfmlKIvQKg0ynVKfHZ15/nhAJN5m8Jn3X5qkwriQCiUntC9AbA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/type-utils\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@typescript-eslint/utils\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9tsutils = \"^3.21.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-iqfLZIsZhK2OEJ4cQ01xOq3NaCuG5FQRKyHicA3xhZxMgaxQazLUHbH/B2k9y5i7l3+o+B5ND9Mf1AWETeMISA==\",\n\9\9\9peerDependencies = {\n\9\9\9\9eslint = \"*\",\n\9\9\9},\n\9\9\9peerDependenciesMeta = {\n\9\9\9\9typescript = {\n\9\9\9\9\9optional = true,\n\9\9\9\9},\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/types\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-T7owcXW4l0v7NTijmjGWwWf/1JqdlWiBzPqzAWhobxft0SiEvMJB56QXmeCQjrPuM8zEfGUKyPQr/L8+cFUBLw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/types/-/types-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/typescript-estree\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/visitor-keys\"] = \"5.22.0\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9globby = \"^11.0.4\",\n\9\9\9\9[\"is-glob\"] = \"^4.0.3\",\n\9\9\9\9semver = \"^7.3.5\",\n\9\9\9\9tsutils = \"^3.21.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-EyBEQxvNjg80yinGE2xdhpDYm41so/1kOItl0qrjIiJ1kX/L/L8WWGmJg8ni6eG3DwqmOzDqOhe6763bF92nOw==\",\n\9\9\9peerDependenciesMeta = {\n\9\9\9\9typescript = {\n\9\9\9\9\9optional = true,\n\9\9\9\9},\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/utils\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@types/json-schema\"] = \"^7.0.9\",\n\9\9\9\9[\"@typescript-eslint/scope-manager\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"@typescript-eslint/typescript-estree\"] = \"5.22.0\",\n\9\9\9\9[\"eslint-scope\"] = \"^5.1.1\",\n\9\9\9\9[\"eslint-utils\"] = \"^3.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-HodsGb037iobrWSUMS7QH6Hl1kppikjA1ELiJlNSTYf/UdMEwzgj0WIp+lBNb6WZ3zTwb0tEz51j0Wee3iJ3wQ==\",\n\9\9\9peerDependencies = {\n\9\9\9\9eslint = \"^6.0.0 || ^7.0.0 || ^8.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/utils/-/utils-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/@typescript-eslint/visitor-keys\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@typescript-eslint/types\"] = \"5.22.0\",\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^3.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9type = \"opencollective\",\n\9\9\9\9url = \"https://opencollective.com/typescript-eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-DbgTqn2Dv5RFWluG88tn0pP6Ex0ROF+dpDO1TNNZdRtLjUr6bdznjA6f/qNqJLjd2PgguAES2Zgxh/JzwzETDg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-5.22.0.tgz\",\n\9\9\9version = \"5.22.0\",\n\9\9},\n\9\9[\"node_modules/acorn\"] = {\n\9\9\9bin = {\n\9\9\9\9acorn = \"bin/acorn\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.4.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-Xx54uLJQZ19lKygFXOWsscKUbsBZW0CPykPhVQdhIeIwrbPmJzqeASDInc8nKBnp/JT6igTs82qPXz069H8I/A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/acorn/-/acorn-8.7.1.tgz\",\n\9\9\9version = \"8.7.1\",\n\9\9},\n\9\9[\"node_modules/acorn-jsx\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==\",\n\9\9\9peerDependencies = {\n\9\9\9\9acorn = \"^6.0.0 || ^7.0.0 || ^8.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz\",\n\9\9\9version = \"5.3.2\",\n\9\9},\n\9\9[\"node_modules/ajv\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"fast-deep-equal\"] = \"^3.1.1\",\n\9\9\9\9[\"fast-json-stable-stringify\"] = \"^2.0.0\",\n\9\9\9\9[\"json-schema-traverse\"] = \"^0.4.1\",\n\9\9\9\9[\"uri-js\"] = \"^4.2.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9funding = {\n\9\9\9\9type = \"github\",\n\9\9\9\9url = \"https://github.com/sponsors/epoberezkin\",\n\9\9\9},\n\9\9\9integrity = \"sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz\",\n\9\9\9version = \"6.12.6\",\n\9\9},\n\9\9[\"node_modules/ansi-regex\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n\9\9\9version = \"5.0.1\",\n\9\9},\n\9\9[\"node_modules/ansi-styles\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"color-convert\"] = \"^2.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/chalk/ansi-styles?sponsor=1\",\n\9\9\9},\n\9\9\9integrity = \"sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz\",\n\9\9\9version = \"4.3.0\",\n\9\9},\n\9\9[\"node_modules/argparse\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz\",\n\9\9\9version = \"2.0.1\",\n\9\9},\n\9\9[\"node_modules/array-union\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz\",\n\9\9\9version = \"2.1.0\",\n\9\9},\n\9\9[\"node_modules/balanced-match\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n\9\9\9version = \"1.0.2\",\n\9\9},\n\9\9[\"node_modules/brace-expansion\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"balanced-match\"] = \"^1.0.0\",\n\9\9\9\9[\"concat-map\"] = \"0.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n\9\9\9version = \"1.1.11\",\n\9\9},\n\9\9[\"node_modules/braces\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"fill-range\"] = \"^7.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/braces/-/braces-3.0.2.tgz\",\n\9\9\9version = \"3.0.2\",\n\9\9},\n\9\9[\"node_modules/callsites\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6\",\n\9\9\9},\n\9\9\9integrity = \"sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz\",\n\9\9\9version = \"3.1.0\",\n\9\9},\n\9\9[\"node_modules/chalk\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"ansi-styles\"] = \"^4.1.0\",\n\9\9\9\9[\"supports-color\"] = \"^7.1.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/chalk/chalk?sponsor=1\",\n\9\9\9},\n\9\9\9integrity = \"sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz\",\n\9\9\9version = \"4.1.2\",\n\9\9},\n\9\9[\"node_modules/color-convert\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"color-name\"] = \"~1.1.4\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=7.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",\n\9\9\9version = \"2.0.1\",\n\9\9},\n\9\9[\"node_modules/color-name\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",\n\9\9\9version = \"1.1.4\",\n\9\9},\n\9\9[\"node_modules/concat-map\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=\",\n\9\9\9resolved = \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n\9\9\9version = \"0.0.1\",\n\9\9},\n\9\9[\"node_modules/cross-spawn\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"path-key\"] = \"^3.1.0\",\n\9\9\9\9[\"shebang-command\"] = \"^2.0.0\",\n\9\9\9\9which = \"^2.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz\",\n\9\9\9version = \"7.0.3\",\n\9\9},\n\9\9[\"node_modules/debug\"] = {\n\9\9\9dependencies = {\n\9\9\9\9ms = \"2.1.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==\",\n\9\9\9peerDependenciesMeta = {\n\9\9\9\9[\"supports-color\"] = {\n\9\9\9\9\9optional = true,\n\9\9\9\9},\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/debug/-/debug-4.3.4.tgz\",\n\9\9\9version = \"4.3.4\",\n\9\9},\n\9\9[\"node_modules/deep-is\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz\",\n\9\9\9version = \"0.1.4\",\n\9\9},\n\9\9[\"node_modules/dir-glob\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"path-type\"] = \"^4.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz\",\n\9\9\9version = \"3.0.1\",\n\9\9},\n\9\9[\"node_modules/doctrine\"] = {\n\9\9\9dependencies = {\n\9\9\9\9esutils = \"^2.0.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9[\"node_modules/escape-string-regexp\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/sindresorhus\",\n\9\9\9},\n\9\9\9integrity = \"sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9[\"node_modules/eslint\"] = {\n\9\9\9bin = {\n\9\9\9\9eslint = \"bin/eslint.js\",\n\9\9\9},\n\9\9\9dependencies = {\n\9\9\9\9[\"@eslint/eslintrc\"] = \"^1.2.2\",\n\9\9\9\9[\"@humanwhocodes/config-array\"] = \"^0.9.2\",\n\9\9\9\9ajv = \"^6.10.0\",\n\9\9\9\9chalk = \"^4.0.0\",\n\9\9\9\9[\"cross-spawn\"] = \"^7.0.2\",\n\9\9\9\9debug = \"^4.3.2\",\n\9\9\9\9doctrine = \"^3.0.0\",\n\9\9\9\9[\"escape-string-regexp\"] = \"^4.0.0\",\n\9\9\9\9[\"eslint-scope\"] = \"^7.1.1\",\n\9\9\9\9[\"eslint-utils\"] = \"^3.0.0\",\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^3.3.0\",\n\9\9\9\9espree = \"^9.3.1\",\n\9\9\9\9esquery = \"^1.4.0\",\n\9\9\9\9esutils = \"^2.0.2\",\n\9\9\9\9[\"fast-deep-equal\"] = \"^3.1.3\",\n\9\9\9\9[\"file-entry-cache\"] = \"^6.0.1\",\n\9\9\9\9[\"functional-red-black-tree\"] = \"^1.0.1\",\n\9\9\9\9[\"glob-parent\"] = \"^6.0.1\",\n\9\9\9\9globals = \"^13.6.0\",\n\9\9\9\9ignore = \"^5.2.0\",\n\9\9\9\9[\"import-fresh\"] = \"^3.0.0\",\n\9\9\9\9imurmurhash = \"^0.1.4\",\n\9\9\9\9[\"is-glob\"] = \"^4.0.0\",\n\9\9\9\9[\"js-yaml\"] = \"^4.1.0\",\n\9\9\9\9[\"json-stable-stringify-without-jsonify\"] = \"^1.0.1\",\n\9\9\9\9levn = \"^0.4.1\",\n\9\9\9\9[\"lodash.merge\"] = \"^4.6.2\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9\9[\"natural-compare\"] = \"^1.4.0\",\n\9\9\9\9optionator = \"^0.9.1\",\n\9\9\9\9regexpp = \"^3.2.0\",\n\9\9\9\9[\"strip-ansi\"] = \"^6.0.1\",\n\9\9\9\9[\"strip-json-comments\"] = \"^3.1.0\",\n\9\9\9\9[\"text-table\"] = \"^0.2.0\",\n\9\9\9\9[\"v8-compile-cache\"] = \"^2.0.3\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://opencollective.com/eslint\",\n\9\9\9},\n\9\9\9integrity = \"sha512-3/CE4aJX7LNEiE3i6FeodHmI/38GZtWCsAtsymScmzYapx8q1nVVb+eLcLSzATmCPXw5pT4TqVs1E0OmxAd9tw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/eslint/-/eslint-8.14.0.tgz\",\n\9\9\9version = \"8.14.0\",\n\9\9},\n\9\9[\"node_modules/eslint-config-prettier\"] = {\n\9\9\9bin = {\n\9\9\9\9[\"eslint-config-prettier\"] = \"bin/cli.js\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-obmWKLUNCnhtQRKc+tmnYuQl0pFU1ibYJQ5BGhTVB08bHe9wC8qUeG7c08dj9XX+AuPj1YSGSQIHl1pnDHZR0Q==\",\n\9\9\9peerDependencies = {\n\9\9\9\9eslint = \">=7.0.0\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-8.5.0.tgz\",\n\9\9\9version = \"8.5.0\",\n\9\9},\n\9\9[\"node_modules/eslint-plugin-prettier\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"prettier-linter-helpers\"] = \"^1.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-98MqmCJ7vJodoQK359bqQWaxOE0CS8paAz/GgjaZLyex4TTk3g9HugoO89EqWCrFiOqn9EVvcoo7gZzONCWVwQ==\",\n\9\9\9peerDependencies = {\n\9\9\9\9eslint = \">=7.28.0\",\n\9\9\9\9prettier = \">=2.0.0\",\n\9\9\9},\n\9\9\9peerDependenciesMeta = {\n\9\9\9\9[\"eslint-config-prettier\"] = {\n\9\9\9\9\9optional = true,\n\9\9\9\9},\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-plugin-prettier/-/eslint-plugin-prettier-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9[\"node_modules/eslint-plugin-roblox-ts\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@types/node\"] = \"^16.10.4\",\n\9\9\9\9[\"@typescript-eslint/experimental-utils\"] = \"^5.0.0\",\n\9\9\9\9typescript = \"^4.4.4\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-zbwahPiQha5KGwY/J3pVXtyR4ORBSP8qouc4DGfnyGcdz0HOFFu+sACWX2u7/c4HVymtZlKRkTL4uR5qZ+THgg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-plugin-roblox-ts/-/eslint-plugin-roblox-ts-0.0.32.tgz\",\n\9\9\9version = \"0.0.32\",\n\9\9},\n\9\9[\"node_modules/eslint-scope\"] = {\n\9\9\9dependencies = {\n\9\9\9\9esrecurse = \"^4.3.0\",\n\9\9\9\9estraverse = \"^4.1.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz\",\n\9\9\9version = \"5.1.1\",\n\9\9},\n\9\9[\"node_modules/eslint-utils\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^2.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^10.0.0 || ^12.0.0 || >= 14.0.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/mysticatea\",\n\9\9\9},\n\9\9\9integrity = \"sha512-uuQC43IGctw68pJA1RgbQS8/NP7rch6Cwd4j3ZBtgo4/8Flj4eGE7ZYSZRN3iq5pVUv6GPdW5Z1RFleo84uLDA==\",\n\9\9\9peerDependencies = {\n\9\9\9\9eslint = \">=5\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-utils/-/eslint-utils-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9[\"node_modules/eslint-utils/node_modules/eslint-visitor-keys\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10\",\n\9\9\9},\n\9\9\9integrity = \"sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz\",\n\9\9\9version = \"2.1.0\",\n\9\9},\n\9\9[\"node_modules/eslint-visitor-keys\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-mQ+suqKJVyeuwGYHAdjMFqjCyfl8+Ldnxuyp3ldiMBFKkvytrXUZWaiPCEav8qDHKty44bD+qV1IP4T+w+xXRA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.3.0.tgz\",\n\9\9\9version = \"3.3.0\",\n\9\9},\n\9\9[\"node_modules/eslint/node_modules/eslint-scope\"] = {\n\9\9\9dependencies = {\n\9\9\9\9esrecurse = \"^4.3.0\",\n\9\9\9\9estraverse = \"^5.2.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-QKQM/UXpIiHcLqJ5AOyIW7XZmzjkzQXYE54n1++wb0u9V/abW3l9uQnxX8Z5Xd18xyKIMTUAyQ0k1e8pz6LUrw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-7.1.1.tgz\",\n\9\9\9version = \"7.1.1\",\n\9\9},\n\9\9[\"node_modules/eslint/node_modules/estraverse\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=4.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n\9\9\9version = \"5.3.0\",\n\9\9},\n\9\9[\"node_modules/espree\"] = {\n\9\9\9dependencies = {\n\9\9\9\9acorn = \"^8.7.0\",\n\9\9\9\9[\"acorn-jsx\"] = \"^5.3.1\",\n\9\9\9\9[\"eslint-visitor-keys\"] = \"^3.3.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^12.22.0 || ^14.17.0 || >=16.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-bvdyLmJMfwkV3NCRl5ZhJf22zBFo1y8bYh3VYb+bfzqNB4Je68P2sSuXyuFquzWLebHpNd2/d5uv7yoP9ISnGQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/espree/-/espree-9.3.1.tgz\",\n\9\9\9version = \"9.3.1\",\n\9\9},\n\9\9[\"node_modules/esquery\"] = {\n\9\9\9dependencies = {\n\9\9\9\9estraverse = \"^5.1.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.10\",\n\9\9\9},\n\9\9\9integrity = \"sha512-cCDispWt5vHHtwMY2YrAQ4ibFkAL8RbH5YGBnZBc90MolvvfkkQcJro/aZiAQUlQ3qgrYS6D6v8Gc5G5CQsc9w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/esquery/-/esquery-1.4.0.tgz\",\n\9\9\9version = \"1.4.0\",\n\9\9},\n\9\9[\"node_modules/esquery/node_modules/estraverse\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=4.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n\9\9\9version = \"5.3.0\",\n\9\9},\n\9\9[\"node_modules/esrecurse\"] = {\n\9\9\9dependencies = {\n\9\9\9\9estraverse = \"^5.2.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=4.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==\",\n\9\9\9resolved = \"https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz\",\n\9\9\9version = \"4.3.0\",\n\9\9},\n\9\9[\"node_modules/esrecurse/node_modules/estraverse\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=4.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n\9\9\9version = \"5.3.0\",\n\9\9},\n\9\9[\"node_modules/estraverse\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=4.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz\",\n\9\9\9version = \"4.3.0\",\n\9\9},\n\9\9[\"node_modules/esutils\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz\",\n\9\9\9version = \"2.0.3\",\n\9\9},\n\9\9[\"node_modules/fast-deep-equal\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\",\n\9\9\9version = \"3.1.3\",\n\9\9},\n\9\9[\"node_modules/fast-diff\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-xJuoT5+L99XlZ8twedaRf6Ax2TgQVxvgZOYoPKqZufmJib0tL2tegPBOZb1pVNgIhlqDlA0eO0c3wBvQcmzx4w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-diff/-/fast-diff-1.2.0.tgz\",\n\9\9\9version = \"1.2.0\",\n\9\9},\n\9\9[\"node_modules/fast-glob\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"@nodelib/fs.stat\"] = \"^2.0.2\",\n\9\9\9\9[\"@nodelib/fs.walk\"] = \"^1.2.3\",\n\9\9\9\9[\"glob-parent\"] = \"^5.1.2\",\n\9\9\9\9merge2 = \"^1.3.0\",\n\9\9\9\9micromatch = \"^4.0.4\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8.6.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-xrO3+1bxSo3ZVHAnqzyuewYT6aMFHRAd4Kcs92MAonjwQZLsK9d0SF1IyQ3k5PoirxTW0Oe/RqFgMQ6TcNE5Ew==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.11.tgz\",\n\9\9\9version = \"3.2.11\",\n\9\9},\n\9\9[\"node_modules/fast-glob/node_modules/glob-parent\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"is-glob\"] = \"^4.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 6\",\n\9\9\9},\n\9\9\9integrity = \"sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==\",\n\9\9\9resolved = \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz\",\n\9\9\9version = \"5.1.2\",\n\9\9},\n\9\9[\"node_modules/fast-json-stable-stringify\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz\",\n\9\9\9version = \"2.1.0\",\n\9\9},\n\9\9[\"node_modules/fast-levenshtein\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=\",\n\9\9\9resolved = \"https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz\",\n\9\9\9version = \"2.0.6\",\n\9\9},\n\9\9[\"node_modules/fastq\"] = {\n\9\9\9dependencies = {\n\9\9\9\9reusify = \"^1.0.4\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-YpkpUnK8od0o1hmeSc7UUs/eB/vIPWJYjKck2QKIzAf71Vm1AAQ3EbuZB3g2JIy+pg+ERD0vqI79KyZiB2e2Nw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fastq/-/fastq-1.13.0.tgz\",\n\9\9\9version = \"1.13.0\",\n\9\9},\n\9\9[\"node_modules/file-entry-cache\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"flat-cache\"] = \"^3.0.4\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^10.12.0 || >=12.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz\",\n\9\9\9version = \"6.0.1\",\n\9\9},\n\9\9[\"node_modules/fill-range\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"to-regex-range\"] = \"^5.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz\",\n\9\9\9version = \"7.0.1\",\n\9\9},\n\9\9[\"node_modules/flat-cache\"] = {\n\9\9\9dependencies = {\n\9\9\9\9flatted = \"^3.1.0\",\n\9\9\9\9rimraf = \"^3.0.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"^10.12.0 || >=12.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz\",\n\9\9\9version = \"3.0.4\",\n\9\9},\n\9\9[\"node_modules/flatted\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-WIWGi2L3DyTUvUrwRKgGi9TwxQMUEqPOPQBVi71R96jZXJdFskXEmf54BoZaS1kknGODoIGASGEzBUYdyMCBJg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/flatted/-/flatted-3.2.5.tgz\",\n\9\9\9version = \"3.2.5\",\n\9\9},\n\9\9[\"node_modules/fs.realpath\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-FQStJSMVjKpA20onh8sBQRmU6k8=\",\n\9\9\9resolved = \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n\9\9\9version = \"1.0.0\",\n\9\9},\n\9\9[\"node_modules/functional-red-black-tree\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=\",\n\9\9\9resolved = \"https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9[\"node_modules/glob\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"fs.realpath\"] = \"^1.0.0\",\n\9\9\9\9inflight = \"^1.0.4\",\n\9\9\9\9inherits = \"2\",\n\9\9\9\9minimatch = \"^3.0.4\",\n\9\9\9\9once = \"^1.3.0\",\n\9\9\9\9[\"path-is-absolute\"] = \"^1.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"*\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/isaacs\",\n\9\9\9},\n\9\9\9integrity = \"sha512-lmLf6gtyrPq8tTjSmrO94wBeQbFR3HbLHbuyD69wuyQkImp2hWqMGB47OX65FBkPffO641IP9jWa1z4ivqG26Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/glob/-/glob-7.2.0.tgz\",\n\9\9\9version = \"7.2.0\",\n\9\9},\n\9\9[\"node_modules/glob-parent\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"is-glob\"] = \"^4.0.3\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10.13.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz\",\n\9\9\9version = \"6.0.2\",\n\9\9},\n\9\9[\"node_modules/globals\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"type-fest\"] = \"^0.20.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/sindresorhus\",\n\9\9\9},\n\9\9\9integrity = \"sha512-EQ7Q18AJlPwp3vUDL4mKA0KXrXyNIQyWon6T6XQiBQF0XHvRsiCSrWmmeATpUzdJN2HhWZU6Pdl0a9zdep5p6A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/globals/-/globals-13.13.0.tgz\",\n\9\9\9version = \"13.13.0\",\n\9\9},\n\9\9[\"node_modules/globby\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"array-union\"] = \"^2.1.0\",\n\9\9\9\9[\"dir-glob\"] = \"^3.0.1\",\n\9\9\9\9[\"fast-glob\"] = \"^3.2.9\",\n\9\9\9\9ignore = \"^5.2.0\",\n\9\9\9\9merge2 = \"^1.4.1\",\n\9\9\9\9slash = \"^3.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/sindresorhus\",\n\9\9\9},\n\9\9\9integrity = \"sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/globby/-/globby-11.1.0.tgz\",\n\9\9\9version = \"11.1.0\",\n\9\9},\n\9\9[\"node_modules/has-flag\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9[\"node_modules/ignore\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 4\",\n\9\9\9},\n\9\9\9integrity = \"sha512-CmxgYGiEPCLhfLnpPp1MoRmifwEIOgjcHXxOBjv7mY96c+eWScsOP9c112ZyLdWHi0FxHjI+4uVhKYp/gcdRmQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ignore/-/ignore-5.2.0.tgz\",\n\9\9\9version = \"5.2.0\",\n\9\9},\n\9\9[\"node_modules/import-fresh\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"parent-module\"] = \"^1.0.0\",\n\9\9\9\9[\"resolve-from\"] = \"^4.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/sindresorhus\",\n\9\9\9},\n\9\9\9integrity = \"sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz\",\n\9\9\9version = \"3.3.0\",\n\9\9},\n\9\9[\"node_modules/imurmurhash\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.8.19\",\n\9\9\9},\n\9\9\9integrity = \"sha1-khi5srkoojixPcT7a21XbyMUU+o=\",\n\9\9\9resolved = \"https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz\",\n\9\9\9version = \"0.1.4\",\n\9\9},\n\9\9[\"node_modules/inflight\"] = {\n\9\9\9dependencies = {\n\9\9\9\9once = \"^1.3.0\",\n\9\9\9\9wrappy = \"1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\",\n\9\9\9resolved = \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n\9\9\9version = \"1.0.6\",\n\9\9},\n\9\9[\"node_modules/inherits\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n\9\9\9version = \"2.0.4\",\n\9\9},\n\9\9[\"node_modules/is-extglob\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=\",\n\9\9\9resolved = \"https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz\",\n\9\9\9version = \"2.1.1\",\n\9\9},\n\9\9[\"node_modules/is-glob\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"is-extglob\"] = \"^2.1.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz\",\n\9\9\9version = \"4.0.3\",\n\9\9},\n\9\9[\"node_modules/is-number\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.12.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==\",\n\9\9\9resolved = \"https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz\",\n\9\9\9version = \"7.0.0\",\n\9\9},\n\9\9[\"node_modules/isexe\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=\",\n\9\9\9resolved = \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n\9\9\9version = \"2.0.0\",\n\9\9},\n\9\9[\"node_modules/js-yaml\"] = {\n\9\9\9bin = {\n\9\9\9\9[\"js-yaml\"] = \"bin/js-yaml.js\",\n\9\9\9},\n\9\9\9dependencies = {\n\9\9\9\9argparse = \"^2.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz\",\n\9\9\9version = \"4.1.0\",\n\9\9},\n\9\9[\"node_modules/json-schema-traverse\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz\",\n\9\9\9version = \"0.4.1\",\n\9\9},\n\9\9[\"node_modules/json-stable-stringify-without-jsonify\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=\",\n\9\9\9resolved = \"https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9[\"node_modules/levn\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"prelude-ls\"] = \"^1.2.1\",\n\9\9\9\9[\"type-check\"] = \"~0.4.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 0.8.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/levn/-/levn-0.4.1.tgz\",\n\9\9\9version = \"0.4.1\",\n\9\9},\n\9\9[\"node_modules/lodash.merge\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz\",\n\9\9\9version = \"4.6.2\",\n\9\9},\n\9\9[\"node_modules/lru-cache\"] = {\n\9\9\9dependencies = {\n\9\9\9\9yallist = \"^4.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10\",\n\9\9\9},\n\9\9\9integrity = \"sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz\",\n\9\9\9version = \"6.0.0\",\n\9\9},\n\9\9[\"node_modules/merge2\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz\",\n\9\9\9version = \"1.4.1\",\n\9\9},\n\9\9[\"node_modules/micromatch\"] = {\n\9\9\9dependencies = {\n\9\9\9\9braces = \"^3.0.2\",\n\9\9\9\9picomatch = \"^2.3.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8.6\",\n\9\9\9},\n\9\9\9integrity = \"sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz\",\n\9\9\9version = \"4.0.5\",\n\9\9},\n\9\9[\"node_modules/minimatch\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"brace-expansion\"] = \"^1.1.7\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \"*\",\n\9\9\9},\n\9\9\9integrity = \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n\9\9\9version = \"3.1.2\",\n\9\9},\n\9\9[\"node_modules/ms\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\",\n\9\9\9version = \"2.1.2\",\n\9\9},\n\9\9[\"node_modules/natural-compare\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=\",\n\9\9\9resolved = \"https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz\",\n\9\9\9version = \"1.4.0\",\n\9\9},\n\9\9[\"node_modules/once\"] = {\n\9\9\9dependencies = {\n\9\9\9\9wrappy = \"1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\",\n\9\9\9resolved = \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n\9\9\9version = \"1.4.0\",\n\9\9},\n\9\9[\"node_modules/optionator\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"deep-is\"] = \"^0.1.3\",\n\9\9\9\9[\"fast-levenshtein\"] = \"^2.0.6\",\n\9\9\9\9levn = \"^0.4.1\",\n\9\9\9\9[\"prelude-ls\"] = \"^1.2.1\",\n\9\9\9\9[\"type-check\"] = \"^0.4.0\",\n\9\9\9\9[\"word-wrap\"] = \"^1.2.3\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 0.8.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz\",\n\9\9\9version = \"0.9.1\",\n\9\9},\n\9\9[\"node_modules/parent-module\"] = {\n\9\9\9dependencies = {\n\9\9\9\9callsites = \"^3.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6\",\n\9\9\9},\n\9\9\9integrity = \"sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9[\"node_modules/path-is-absolute\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha1-F0uSaHNVNP+8es5r9TpanhtcX18=\",\n\9\9\9resolved = \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n\9\9\9version = \"1.0.1\",\n\9\9},\n\9\9[\"node_modules/path-key\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n\9\9\9version = \"3.1.1\",\n\9\9},\n\9\9[\"node_modules/path-type\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9[\"node_modules/picomatch\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8.6\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/jonschlinkert\",\n\9\9\9},\n\9\9\9integrity = \"sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz\",\n\9\9\9version = \"2.3.1\",\n\9\9},\n\9\9[\"node_modules/prelude-ls\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 0.8.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz\",\n\9\9\9version = \"1.2.1\",\n\9\9},\n\9\9[\"node_modules/prettier\"] = {\n\9\9\9bin = {\n\9\9\9\9prettier = \"bin-prettier.js\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10.13.0\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/prettier/prettier?sponsor=1\",\n\9\9\9},\n\9\9\9integrity = \"sha512-PkUpF+qoXTqhOeWL9fu7As8LXsIUZ1WYaJiY/a7McAQzxjk82OF0tibkFXVCDImZtWxbvojFjerkiLb0/q8mew==\",\n\9\9\9resolved = \"https://registry.npmjs.org/prettier/-/prettier-2.6.2.tgz\",\n\9\9\9version = \"2.6.2\",\n\9\9},\n\9\9[\"node_modules/prettier-linter-helpers\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"fast-diff\"] = \"^1.1.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6.0.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-GbK2cP9nraSSUF9N2XwUwqfzlAFlMNYYl+ShE/V+H8a9uNl/oUqB1w2EL54Jh0OlyRSd8RfWYJ3coVS4TROP2w==\",\n\9\9\9resolved = \"https://registry.npmjs.org/prettier-linter-helpers/-/prettier-linter-helpers-1.0.0.tgz\",\n\9\9\9version = \"1.0.0\",\n\9\9},\n\9\9[\"node_modules/punycode\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=6\",\n\9\9\9},\n\9\9\9integrity = \"sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz\",\n\9\9\9version = \"2.1.1\",\n\9\9},\n\9\9[\"node_modules/queue-microtask\"] = {\n\9\9\9dev = true,\n\9\9\9funding = {{\n\9\9\9\9type = \"github\",\n\9\9\9\9url = \"https://github.com/sponsors/feross\",\n\9\9\9}, {\n\9\9\9\9type = \"patreon\",\n\9\9\9\9url = \"https://www.patreon.com/feross\",\n\9\9\9}, {\n\9\9\9\9type = \"consulting\",\n\9\9\9\9url = \"https://feross.org/support\",\n\9\9\9}},\n\9\9\9integrity = \"sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz\",\n\9\9\9version = \"1.2.3\",\n\9\9},\n\9\9[\"node_modules/regexpp\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/mysticatea\",\n\9\9\9},\n\9\9\9integrity = \"sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz\",\n\9\9\9version = \"3.2.0\",\n\9\9},\n\9\9[\"node_modules/resolve-from\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=4\",\n\9\9\9},\n\9\9\9integrity = \"sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9\9[\"node_modules/reusify\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9iojs = \">=1.0.0\",\n\9\9\9\9node = \">=0.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz\",\n\9\9\9version = \"1.0.4\",\n\9\9},\n\9\9[\"node_modules/rimraf\"] = {\n\9\9\9bin = {\n\9\9\9\9rimraf = \"bin.js\",\n\9\9\9},\n\9\9\9dependencies = {\n\9\9\9\9glob = \"^7.1.3\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/isaacs\",\n\9\9\9},\n\9\9\9integrity = \"sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz\",\n\9\9\9version = \"3.0.2\",\n\9\9},\n\9\9[\"node_modules/run-parallel\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"queue-microtask\"] = \"^1.2.2\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9funding = {{\n\9\9\9\9type = \"github\",\n\9\9\9\9url = \"https://github.com/sponsors/feross\",\n\9\9\9}, {\n\9\9\9\9type = \"patreon\",\n\9\9\9\9url = \"https://www.patreon.com/feross\",\n\9\9\9}, {\n\9\9\9\9type = \"consulting\",\n\9\9\9\9url = \"https://feross.org/support\",\n\9\9\9}},\n\9\9\9integrity = \"sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz\",\n\9\9\9version = \"1.2.0\",\n\9\9},\n\9\9[\"node_modules/semver\"] = {\n\9\9\9bin = {\n\9\9\9\9semver = \"bin/semver.js\",\n\9\9\9},\n\9\9\9dependencies = {\n\9\9\9\9[\"lru-cache\"] = \"^6.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10\",\n\9\9\9},\n\9\9\9integrity = \"sha512-QlYTucUYOews+WeEujDoEGziz4K6c47V/Bd+LjSSYcA94p+DmINdf7ncaUinThfvZyu13lN9OY1XDxt8C0Tw0g==\",\n\9\9\9resolved = \"https://registry.npmjs.org/semver/-/semver-7.3.7.tgz\",\n\9\9\9version = \"7.3.7\",\n\9\9},\n\9\9[\"node_modules/shebang-command\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"shebang-regex\"] = \"^3.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n\9\9\9version = \"2.0.0\",\n\9\9},\n\9\9[\"node_modules/shebang-regex\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9[\"node_modules/slash\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==\",\n\9\9\9resolved = \"https://registry.npmjs.org/slash/-/slash-3.0.0.tgz\",\n\9\9\9version = \"3.0.0\",\n\9\9},\n\9\9[\"node_modules/strip-ansi\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"ansi-regex\"] = \"^5.0.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n\9\9\9version = \"6.0.1\",\n\9\9},\n\9\9[\"node_modules/strip-json-comments\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/sindresorhus\",\n\9\9\9},\n\9\9\9integrity = \"sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==\",\n\9\9\9resolved = \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz\",\n\9\9\9version = \"3.1.1\",\n\9\9},\n\9\9[\"node_modules/supports-color\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"has-flag\"] = \"^4.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\",\n\9\9\9resolved = \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",\n\9\9\9version = \"7.2.0\",\n\9\9},\n\9\9[\"node_modules/text-table\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=\",\n\9\9\9resolved = \"https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz\",\n\9\9\9version = \"0.2.0\",\n\9\9},\n\9\9[\"node_modules/to-regex-range\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"is-number\"] = \"^7.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=8.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz\",\n\9\9\9version = \"5.0.1\",\n\9\9},\n\9\9[\"node_modules/tslib\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz\",\n\9\9\9version = \"1.14.1\",\n\9\9},\n\9\9[\"node_modules/tsutils\"] = {\n\9\9\9dependencies = {\n\9\9\9\9tslib = \"^1.8.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 6\",\n\9\9\9},\n\9\9\9integrity = \"sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==\",\n\9\9\9peerDependencies = {\n\9\9\9\9typescript = \">=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta\",\n\9\9\9},\n\9\9\9resolved = \"https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz\",\n\9\9\9version = \"3.21.0\",\n\9\9},\n\9\9[\"node_modules/type-check\"] = {\n\9\9\9dependencies = {\n\9\9\9\9[\"prelude-ls\"] = \"^1.2.1\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 0.8.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==\",\n\9\9\9resolved = \"https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz\",\n\9\9\9version = \"0.4.0\",\n\9\9},\n\9\9[\"node_modules/type-fest\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=10\",\n\9\9\9},\n\9\9\9funding = {\n\9\9\9\9url = \"https://github.com/sponsors/sindresorhus\",\n\9\9\9},\n\9\9\9integrity = \"sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz\",\n\9\9\9version = \"0.20.2\",\n\9\9},\n\9\9[\"node_modules/typescript\"] = {\n\9\9\9bin = {\n\9\9\9\9tsc = \"bin/tsc\",\n\9\9\9\9tsserver = \"bin/tsserver\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=4.2.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-9ia/jWHIEbo49HfjrLGfKbZSuWo9iTMwXO+Ca3pRsSpbsMbc7/IU8NKdCZVRRBafVPGnoJeFL76ZOAA84I9fEg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/typescript/-/typescript-4.6.4.tgz\",\n\9\9\9version = \"4.6.4\",\n\9\9},\n\9\9[\"node_modules/uri-js\"] = {\n\9\9\9dependencies = {\n\9\9\9\9punycode = \"^2.1.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==\",\n\9\9\9resolved = \"https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz\",\n\9\9\9version = \"4.4.1\",\n\9\9},\n\9\9[\"node_modules/v8-compile-cache\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz\",\n\9\9\9version = \"2.3.0\",\n\9\9},\n\9\9[\"node_modules/which\"] = {\n\9\9\9bin = {\n\9\9\9\9[\"node-which\"] = \"bin/node-which\",\n\9\9\9},\n\9\9\9dependencies = {\n\9\9\9\9isexe = \"^2.0.0\",\n\9\9\9},\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">= 8\",\n\9\9\9},\n\9\9\9integrity = \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n\9\9\9resolved = \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n\9\9\9version = \"2.0.2\",\n\9\9},\n\9\9[\"node_modules/word-wrap\"] = {\n\9\9\9dev = true,\n\9\9\9engines = {\n\9\9\9\9node = \">=0.10.0\",\n\9\9\9},\n\9\9\9integrity = \"sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==\",\n\9\9\9resolved = \"https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz\",\n\9\9\9version = \"1.2.3\",\n\9\9},\n\9\9[\"node_modules/wrappy\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\",\n\9\9\9resolved = \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n\9\9\9version = \"1.0.2\",\n\9\9},\n\9\9[\"node_modules/yallist\"] = {\n\9\9\9dev = true,\n\9\9\9integrity = \"sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==\",\n\9\9\9resolved = \"https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz\",\n\9\9\9version = \"4.0.0\",\n\9\9},\n\9},\n\9requires = true,\n\9version = \"1.1.0\",\n}", "bundle-ex.include.node_modules.@rbxts.hax.package-lock"))(__env)
end)
__rbx("types", "Folder", "bundle-ex.include.node_modules.@rbxts.hax.types", "bundle-ex.include.node_modules.@rbxts.hax")
__rbx("maid", "Folder", "bundle-ex.include.node_modules.@rbxts.maid", "bundle-ex.include.node_modules.@rbxts")
__lua("Maid", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.maid.Maid", "bundle-ex.include.node_modules.@rbxts.maid", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.maid.Maid\")local script,require=_.script,_.require ---\9Manages the cleaning of events and other things.\n-- Useful for encapsulating state and make deconstructors easy\n-- @classmod Maid\n-- @see Signal\n\nlocal Maid = {}\nMaid.ClassName = \"Maid\"\n\n--- Returns a new Maid object\n-- @constructor Maid.new()\n-- @treturn Maid\nfunction Maid.new()\n\9local self = {}\n\n\9self._tasks = {}\n\n\9return setmetatable(self, Maid)\nend\n\n--- Returns Maid[key] if not part of Maid metatable\n-- @return Maid[key] value\nfunction Maid:__index(index)\n\9if Maid[index] then\n\9\9return Maid[index]\n\9else\n\9\9return self._tasks[index]\n\9end\nend\n\n--- Add a task to clean up\n-- @usage\n-- Maid[key] = (function)         Adds a task to perform\n-- Maid[key] = (event connection) Manages an event connection\n-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.\n-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method\n-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,\n--                                it is destroyed.\nfunction Maid:__newindex(index, newTask)\n\9if Maid[index] ~= nil then\n\9\9error((\"'%s' is reserved\"):format(tostring(index)), 2)\n\9end\n\n\9local tasks = self._tasks\n\9local oldTask = tasks[index]\n\9tasks[index] = newTask\n\n\9if oldTask then\n\9\9if type(oldTask) == \"function\" then\n\9\9\9oldTask()\n\9\9elseif typeof(oldTask) == \"RBXScriptConnection\" then\n\9\9\9oldTask:Disconnect()\n\9\9elseif oldTask.Destroy then\n\9\9\9oldTask:Destroy()\n\9\9end\n\9end\nend\n\n--- Same as indexing, but uses an incremented number as a key.\n-- @param task An item to clean\n-- @treturn number taskId\nfunction Maid:GiveTask(task)\n\9assert(task, \"Task cannot be false or nil\")\n\n\9local taskId = #self._tasks+1\n\9self[taskId] = task\n\n\9if type(task) == \"table\" and (not task.Destroy) then\n\9\9warn(\"[Maid.GiveTask] - Gave table task without .Destroy\\n\\n\" .. debug.traceback())\n\9end\n\n\9return taskId\nend\n\nfunction Maid:GivePromise(promise)\n\9if not promise:IsPending() then\n\9\9return promise\n\9end\n\n\9local newPromise = promise.resolved(promise)\n\9local id = self:GiveTask(newPromise)\n\n\9-- Ensure GC\n\9newPromise:Finally(function()\n\9\9self[id] = nil\n\9end)\n\n\9return newPromise\nend\n\n--- Cleans up all tasks.\n-- @alias Destroy\nfunction Maid:DoCleaning()\n\9local tasks = self._tasks\n\n\9-- Disconnect all events first as we know this is safe\n\9for index, task in pairs(tasks) do\n\9\9if typeof(task) == \"RBXScriptConnection\" then\n\9\9\9tasks[index] = nil\n\9\9\9task:Disconnect()\n\9\9end\n\9end\n\n\9-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid\n\9local index, task = next(tasks)\n\9while task ~= nil do\n\9\9tasks[index] = nil\n\9\9if type(task) == \"function\" then\n\9\9\9task()\n\9\9elseif typeof(task) == \"RBXScriptConnection\" then\n\9\9\9task:Disconnect()\n\9\9elseif task.Destroy then\n\9\9\9task:Destroy()\n\9\9end\n\9\9index, task = next(tasks)\n\9end\nend\n\n--- Alias for DoCleaning()\n-- @function Destroy\nMaid.Destroy = Maid.DoCleaning\n\nreturn Maid", "bundle-ex.include.node_modules.@rbxts.maid.Maid"))(__env)
end)
__lua("object-utils", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.object-utils", "bundle-ex.include.node_modules.@rbxts", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.object-utils\")local script,require=_.script,_.require local HttpService = game:GetService(\"HttpService\")\n\nlocal Object = {}\n\nfunction Object.keys(object)\n\9local result = table.create(#object)\n\9for key in pairs(object) do\n\9\9result[#result + 1] = key\n\9end\n\9return result\nend\n\nfunction Object.values(object)\n\9local result = table.create(#object)\n\9for _, value in pairs(object) do\n\9\9result[#result + 1] = value\n\9end\n\9return result\nend\n\nfunction Object.entries(object)\n\9local result = table.create(#object)\n\9for key, value in pairs(object) do\n\9\9result[#result + 1] = { key, value }\n\9end\n\9return result\nend\n\nfunction Object.assign(toObj, ...)\n\9for i = 1, select(\"#\", ...) do\n\9\9local arg = select(i, ...)\n\9\9if type(arg) == \"table\" then\n\9\9\9for key, value in pairs(arg) do\n\9\9\9\9toObj[key] = value\n\9\9\9end\n\9\9end\n\9end\n\9return toObj\nend\n\nfunction Object.copy(object)\n\9local result = table.create(#object)\n\9for k, v in pairs(object) do\n\9\9result[k] = v\n\9end\n\9return result\nend\n\nlocal function deepCopyHelper(object, encountered)\n\9local result = table.create(#object)\n\9encountered[object] = result\n\n\9for k, v in pairs(object) do\n\9\9if type(k) == \"table\" then\n\9\9\9k = encountered[k] or deepCopyHelper(k, encountered)\n\9\9end\n\n\9\9if type(v) == \"table\" then\n\9\9\9v = encountered[v] or deepCopyHelper(v, encountered)\n\9\9end\n\n\9\9result[k] = v\n\9end\n\n\9return result\nend\n\nfunction Object.deepCopy(object)\n\9return deepCopyHelper(object, {})\nend\n\nfunction Object.deepEquals(a, b)\n\9-- a[k] == b[k]\n\9for k in pairs(a) do\n\9\9local av = a[k]\n\9\9local bv = b[k]\n\9\9if type(av) == \"table\" and type(bv) == \"table\" then\n\9\9\9local result = Object.deepEquals(av, bv)\n\9\9\9if not result then\n\9\9\9\9return false\n\9\9\9end\n\9\9elseif av ~= bv then\n\9\9\9return false\n\9\9end\n\9end\n\n\9-- extra keys in b\n\9for k in pairs(b) do\n\9\9if a[k] == nil then\n\9\9\9return false\n\9\9end\n\9end\n\n\9return true\nend\n\nfunction Object.toString(data)\n\9return HttpService:JSONEncode(data)\nend\n\nfunction Object.isEmpty(object)\n\9return next(object) == nil\nend\n\nfunction Object.fromEntries(entries)\n\9local entriesLen = #entries\n\n\9local result = table.create(entriesLen)\n\9if entries then\n\9\9for i = 1, entriesLen do\n\9\9\9local pair = entries[i]\n\9\9\9result[pair[1]] = pair[2]\n\9\9end\n\9end\n\9return result\nend\n\nreturn Object\n", "bundle-ex.include.node_modules.@rbxts.object-utils"))(__env)
end)
__rbx("reflex", "Folder", "bundle-ex.include.node_modules.@rbxts.reflex", "bundle-ex.include.node_modules.@rbxts")
__lua("out", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out", "bundle-ex.include.node_modules.@rbxts.reflex", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal exports = {}\nfor _k, _v in TS.import(script, script, \"combine-producers\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"create-producer\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"create-selector\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"combine-producers\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"apply-middleware\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"types\") or {} do\n\9exports[_k] = _v\nend\nexports.ReflexProvider = TS.import(script, script, \"components\", \"ReflexProvider\").default\nfor _k, _v in TS.import(script, script, \"hooks\", \"use-producer\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"hooks\", \"use-selector\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"hooks\", \"use-selector-creator\") or {} do\n\9exports[_k] = _v\nend\nfor _k, _v in TS.import(script, script, \"middleware\", \"logger-middleware\") or {} do\n\9exports[_k] = _v\nend\nreturn exports\n", "bundle-ex.include.node_modules.@rbxts.reflex.out"))(__env)
end)
__lua("apply-middleware", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.apply-middleware", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.apply-middleware\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal entries = TS.import(script, script.Parent, \"utils\", \"entries\").entries\n--[[\n\9*\n\9* Creates a producer enhancer that applies middleware to every dispatcher\n\9* function in the producer.\n\9* @param middlewares The middleware to apply.\n\9* @returns The producer enhancer.\n]]\nlocal compose\nlocal function applyMiddleware(...)\n\9local middlewares = { ... }\n\9return function(producer)\n\9\9local dispatchers = producer:getDispatchers()\n\9\9local _middlewares = middlewares\n\9\9local _arg0 = function(middleware)\n\9\9\9return middleware(producer)\n\9\9end\n\9\9-- ▼ ReadonlyArray.map ▼\n\9\9local _newValue = table.create(#_middlewares)\n\9\9for _k, _v in _middlewares do\n\9\9\9_newValue[_k] = _arg0(_v, _k - 1, _middlewares)\n\9\9end\n\9\9-- ▲ ReadonlyArray.map ▲\n\9\9local chain = _newValue\n\9\9for name, dispatcher in entries(dispatchers) do\n\9\9\9local dispatcherWithMiddleware = compose(chain)(function(action)\n\9\9\9\9return dispatcher(unpack(action.arguments))\n\9\9\9end)\n\9\9\9-- Make sure that the first parameter is the dispatcher name\n\9\9\9dispatchers[name] = function(...)\n\9\9\9\9local args = { ... }\n\9\9\9\9return dispatcherWithMiddleware({\n\9\9\9\9\9type = name,\n\9\9\9\9\9arguments = args,\n\9\9\9\9})\n\9\9\9end\n\9\9\9producer[name] = dispatchers[name]\n\9\9end\n\9\9return producer\n\9end\nend\nfunction compose(callbacks)\n\9local _callbacks = callbacks\n\9local _arg0 = function(a, b)\n\9\9return function(...)\n\9\9\9local args = { ... }\n\9\9\9return a(b(unpack(args)))\n\9\9end\n\9end\n\9-- ▼ ReadonlyArray.reduce ▼\n\9if #_callbacks == 0 then\n\9\9error(\"Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.\")\n\9end\n\9local _result = _callbacks[1]\n\9local _callback = _arg0\n\9for _i = 2, #_callbacks do\n\9\9_result = _callback(_result, _callbacks[_i], _i - 1, _callbacks)\n\9end\n\9-- ▲ ReadonlyArray.reduce ▲\n\9return _result\nend\nreturn {\n\9applyMiddleware = applyMiddleware,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.apply-middleware"))(__env)
end)
__lua("apply-middleware.spec", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.apply-middleware.spec", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.apply-middleware.spec\")local script,require=_.script,_.require return function()\n\9local createProducer = require(script.Parent[\"create-producer\"]).createProducer\n\9local applyMiddleware = require(script.Parent[\"apply-middleware\"]).applyMiddleware\n\n\9local function copyProducer()\n\9\9return createProducer({ value = 0 }, {\n\9\9\9increment = function(state, amount)\n\9\9\9\9return { value = state.value + amount }\n\9\9\9end,\n\9\9})\n\9end\n\n\9it(\"should call middleware with a key and args\", function()\n\9\9local producer = copyProducer()\n\9\9local contextReceived = {} -- { \"increment\", amount }\n\n\9\9local middleware = function(store)\n\9\9\9return function(done)\n\9\9\9\9return function(context)\n\9\9\9\9\9contextReceived = context\n\9\9\9\9\9return done(context)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9producer:enhance(applyMiddleware(middleware))\n\n\9\9producer.increment(5)\n\n\9\9expect(contextReceived.type).to.equal(\"increment\")\n\9\9expect(contextReceived.arguments[1]).to.equal(5)\n\9\9expect(producer:getState().value).to.equal(5)\n\n\9\9producer:destroy()\n\9end)\n\n\9it(\"should call middleware in order\", function()\n\9\9local producer = copyProducer()\n\9\9local middlewareCalls = {} -- { \"increment\", amount }\n\n\9\9local middleware1 = function(store)\n\9\9\9return function(done)\n\9\9\9\9return function(context)\n\9\9\9\9\9table.insert(middlewareCalls, \"middleware1\")\n\9\9\9\9\9return done(context)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9local middleware2 = function(store)\n\9\9\9return function(done)\n\9\9\9\9return function(context)\n\9\9\9\9\9table.insert(middlewareCalls, \"middleware2\")\n\9\9\9\9\9return done(context)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9producer:enhance(applyMiddleware(middleware1, middleware2))\n\n\9\9producer.increment(5)\n\n\9\9expect(middlewareCalls[1]).to.equal(\"middleware1\")\n\9\9expect(middlewareCalls[2]).to.equal(\"middleware2\")\n\9\9expect(producer:getState().value).to.equal(5)\n\n\9\9producer:destroy()\n\9end)\nend\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.apply-middleware.spec"))(__env)
end)
__lua("combine-producers", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.combine-producers", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.combine-producers\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal entries = TS.import(script, script.Parent, \"utils\", \"entries\").entries\n--[[\n\9*\n\9* Combines multiple producers into a single producer.\n\9*\n\9* Any dispatcher called on the combined producer will call the dispatchers of\n\9* the same name on each producer. The combined state will be updated after all\n\9* dispatchers have been called.\n\9*\n\9* **⚠️ Warning:** Don't call dispatchers on the individual producers. This will\n\9* cause the combined state to be out of sync.\n\9*\n\9* @param producers A map of producers to combine.\n\9* @returns A producer that combines the state of all the given producers.\n]]\nlocal combineState\nlocal function combineProducers(producers)\n\9local combinedState = combineState(producers)\n\9local combinedStateSinceFlush = combinedState\n\9local nextFlush\n\9local nextSubscriptionId = 0\n\9local subscribers = {}\n\9local combinedDispatchers = {}\n\9-- Calls the dispatcher of the same name on each producer.\n\9local combinedProducer\n\9local dispatch = function(key, ...)\n\9\9local args = { ... }\n\9\9local stateChanged = false\n\9\9local newCombinedState = {}\n\9\9-- Call every dispatcher of the same name on each producer\n\9\9for producerName, producer in entries(producers) do\n\9\9\9local dispatchers = producer:getDispatchers()\n\9\9\9local dispatcher = dispatchers[key]\n\9\9\9if not (type(dispatcher) == \"function\") then\n\9\9\9\9newCombinedState[producerName] = producer:getState()\n\9\9\9\9continue\n\9\9\9end\n\9\9\9local currentState = producer:getState()\n\9\9\9local newState = dispatcher(unpack(args))\n\9\9\9newCombinedState[producerName] = newState\n\9\9\9if currentState ~= newState then\n\9\9\9\9stateChanged = true\n\9\9\9end\n\9\9end\n\9\9-- If the state has changed, update the combined state and flush\n\9\9if not stateChanged then\n\9\9\9return nil\n\9\9end\n\9\9combinedState = newCombinedState\n\9\9if not nextFlush then\n\9\9\9nextFlush = task.defer(function()\n\9\9\9\9nextFlush = nil\n\9\9\9\9combinedProducer:flush()\n\9\9\9end)\n\9\9end\n\9end\n\9-- Add each producer's dispatchers to the combined dispatchers, where calling\n\9-- one dispatcher will call the dispatcher on each producer.\n\9for _, producer in entries(producers) do\n\9\9for dispatcherName in entries(producer:getDispatchers()) do\n\9\9\9combinedDispatchers[dispatcherName] = function(...)\n\9\9\9\9local args = { ... }\n\9\9\9\9dispatch(dispatcherName, unpack(args))\n\9\9\9\9return combinedState\n\9\9\9end\n\9\9end\n\9end\n\9local _object = {\n\9\9getState = function(self)\n\9\9\9return combinedState\n\9\9end,\n\9\9select = function(self, selector)\n\9\9\9return selector(combinedState)\n\9\9end,\n\9\9setState = function(self, newState)\n\9\9\9combinedState = table.clone(newState)\n\9\9\9if not nextFlush then\n\9\9\9\9nextFlush = task.defer(function()\n\9\9\9\9\9nextFlush = nil\n\9\9\9\9\9self:flush()\n\9\9\9\9end)\n\9\9\9end\n\9\9\9return combinedState\n\9\9end,\n\9\9getDispatchers = function(self)\n\9\9\9return combinedDispatchers\n\9\9end,\n\9\9flush = function(self)\n\9\9\9if nextFlush then\n\9\9\9\9task.cancel(nextFlush)\n\9\9\9\9nextFlush = nil\n\9\9\9end\n\9\9\9if combinedStateSinceFlush ~= combinedState then\n\9\9\9\9local prevState = combinedStateSinceFlush\n\9\9\9\9combinedStateSinceFlush = combinedState\n\9\9\9\9for _, subscriber in subscribers do\n\9\9\9\9\9subscriber(combinedState, prevState)\n\9\9\9\9end\n\9\9\9end\n\9\9end,\n\9\9subscribe = function(self, callback)\n\9\9\9local _original = nextSubscriptionId\n\9\9\9nextSubscriptionId += 1\n\9\9\9local id = _original\n\9\9\9local _callback = callback\n\9\9\9subscribers[id] = _callback\n\9\9\9return function()\n\9\9\9\9subscribers[id] = nil\n\9\9\9end\n\9\9end,\n\9\9observe = function(self, selector, callback)\n\9\9\9local selection = selector(combinedState)\n\9\9\9return self:subscribe(function()\n\9\9\9\9local newSelection = selector(combinedState)\n\9\9\9\9if selection ~= newSelection then\n\9\9\9\9\9local prevSelection = selection\n\9\9\9\9\9selection = newSelection\n\9\9\9\9\9callback(newSelection, prevSelection)\n\9\9\9\9end\n\9\9\9end)\n\9\9end,\n\9\9once = function(self, selector, callback)\n\9\9\9local unsubscribe\n\9\9\9unsubscribe = self:observe(selector, function(state, prevState)\n\9\9\9\9unsubscribe()\n\9\9\9\9callback(state, prevState)\n\9\9\9end)\n\9\9\9return unsubscribe\n\9\9end,\n\9\9wait = function(self, selector)\n\9\9\9return TS.Promise.new(function(resolve, _, onCancel)\n\9\9\9\9local unsubscribe = self:once(selector, resolve)\n\9\9\9\9onCancel(unsubscribe)\n\9\9\9end)\n\9\9end,\n\9\9destroy = function(self)\n\9\9\9if nextFlush then\n\9\9\9\9task.cancel(nextFlush)\n\9\9\9\9nextFlush = nil\n\9\9\9end\n\9\9\9table.clear(subscribers)\n\9\9end,\n\9\9enhance = function(self, enhancer)\n\9\9\9return enhancer(self)\n\9\9end,\n\9\9Connect = function(self, callback)\n\9\9\9local unsubscribe = self:subscribe(callback)\n\9\9\9return {\n\9\9\9\9Connected = true,\n\9\9\9\9Disconnect = function(self)\n\9\9\9\9\9self.Connected = false\n\9\9\9\9\9unsubscribe()\n\9\9\9\9end,\n\9\9\9}\n\9\9end,\n\9\9Once = function(self, callback)\n\9\9\9local unsubscribe = self:once(function(state)\n\9\9\9\9return state\n\9\9\9end, callback)\n\9\9\9return {\n\9\9\9\9Connected = true,\n\9\9\9\9Disconnect = function(self)\n\9\9\9\9\9self.Connected = false\n\9\9\9\9\9unsubscribe()\n\9\9\9\9end,\n\9\9\9}\n\9\9end,\n\9\9Wait = function(self)\n\9\9\9return self:wait(function(state)\n\9\9\9\9return state\n\9\9\9end):expect()\n\9\9end,\n\9}\n\9for _k, _v in combinedDispatchers do\n\9\9_object[_k] = _v\n\9end\n\9combinedProducer = _object\n\9return combinedProducer\nend\n--[[\n\9*\n\9* Combines the state of multiple producers into a single object.\n\9* @param producers A map of producers to combine.\n\9* @returns An object containing the state of each producer.\n]]\nfunction combineState(producers)\n\9local combinedState = {}\n\9for key, producer in pairs(producers) do\n\9\9combinedState[key] = producer:getState()\n\9end\n\9return combinedState\nend\nreturn {\n\9combineProducers = combineProducers,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.combine-producers"))(__env)
end)
__lua("combine-producers.spec", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.combine-producers.spec", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.combine-producers.spec\")local script,require=_.script,_.require return function()\n\9local createProducer = require(script.Parent[\"create-producer\"]).createProducer\n\9local combineProducers = require(script.Parent[\"combine-producers\"]).combineProducers\n\9local Promise = require(game:GetService(\"ReplicatedStorage\").include.Promise)\n\n\9local producerA = createProducer({ sharedCounter = 0, privateCounter = 0 }, {\n\9\9sharedIncrement = function(state, amount)\n\9\9\9return { sharedCounter = state.sharedCounter + amount, privateCounter = state.privateCounter }\n\9\9end,\n\9\9privateIncrementA = function(state, amount)\n\9\9\9return { privateCounter = state.privateCounter + amount, sharedCounter = state.sharedCounter }\n\9\9end,\n\9})\n\n\9local producerB = createProducer({ sharedCounter = 0, privateCounter = 0 }, {\n\9\9sharedIncrement = function(state, amount)\n\9\9\9return { sharedCounter = state.sharedCounter + amount, privateCounter = state.privateCounter }\n\9\9end,\n\9\9privateIncrementB = function(state, amount)\n\9\9\9return { privateCounter = state.privateCounter + amount, sharedCounter = state.sharedCounter }\n\9\9end,\n\9})\n\n\9local combinedProducer\n\n\9describe(\"combineProducers\", function()\n\9\9combinedProducer = combineProducers({\n\9\9\9producerA = producerA,\n\9\9\9producerB = producerB,\n\9\9})\n\n\9\9it(\"should return a producer table\", function()\n\9\9\9expect(combinedProducer).to.be.a(\"table\")\n\9\9\9expect(combinedProducer.getState).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.getDispatchers).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.flush).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.subscribe).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.observe).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.once).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.wait).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.select).to.be.a(\"function\")\n\9\9end)\n\n\9\9it(\"should merge the action functions\", function()\n\9\9\9expect(combinedProducer.sharedIncrement).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.privateIncrementA).to.be.a(\"function\")\n\9\9\9expect(combinedProducer.privateIncrementB).to.be.a(\"function\")\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.getState\", function()\n\9\9it(\"should return the combined state\", function()\n\9\9\9local state = combinedProducer:getState()\n\9\9\9expect(state).to.be.a(\"table\")\n\9\9\9expect(state.producerA).to.be.a(\"table\")\n\9\9\9expect(state.producerB).to.be.a(\"table\")\n\9\9\9expect(state.producerA.sharedCounter).to.equal(0)\n\9\9\9expect(state.producerA.privateCounter).to.equal(0)\n\9\9\9expect(state.producerB.sharedCounter).to.equal(0)\n\9\9\9expect(state.producerB.privateCounter).to.equal(0)\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.getDispatchers\", function()\n\9\9it(\"should return a table of dispatchers\", function()\n\9\9\9local dispatchers = combinedProducer:getDispatchers()\n\9\9\9expect(dispatchers).to.be.a(\"table\")\n\9\9\9expect(dispatchers.sharedIncrement).to.be.a(\"function\")\n\9\9\9expect(dispatchers.privateIncrementA).to.be.a(\"function\")\n\9\9\9expect(dispatchers.privateIncrementB).to.be.a(\"function\")\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer[action]\", function()\n\9\9it(\"should dispatch the sharedIncrement action globally\", function()\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9local state = combinedProducer:getState()\n\9\9\9expect(state.producerA.sharedCounter).to.equal(1)\n\9\9\9expect(state.producerB.sharedCounter).to.equal(1)\n\9\9end)\n\n\9\9it(\"should dispatch the privateIncrementA action\", function()\n\9\9\9combinedProducer.privateIncrementA(1)\n\9\9\9local state = combinedProducer:getState()\n\9\9\9expect(state.producerA.privateCounter).to.equal(1)\n\9\9\9expect(state.producerB.privateCounter).to.equal(0)\n\9\9end)\n\n\9\9it(\"should dispatch the privateIncrementB action\", function()\n\9\9\9combinedProducer.privateIncrementB(1)\n\9\9\9local state = combinedProducer:getState()\n\9\9\9expect(state.producerA.privateCounter).to.equal(1)\n\9\9\9expect(state.producerB.privateCounter).to.equal(1)\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.subscribe\", function()\n\9\9it(\"should subscribe to the combined producer\", function()\n\9\9\9local unsubscribe = combinedProducer:subscribe(function(state)\n\9\9\9\9expect(state).to.be.a(\"table\")\n\9\9\9\9expect(state.producerA).to.be.a(\"table\")\n\9\9\9\9expect(state.producerB).to.be.a(\"table\")\n\9\9\9\9expect(state.producerA.sharedCounter).to.equal(2)\n\9\9\9\9expect(state.producerA.privateCounter).to.equal(2)\n\9\9\9\9expect(state.producerB.sharedCounter).to.equal(2)\n\9\9\9\9expect(state.producerB.privateCounter).to.equal(2)\n\9\9\9end)\n\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer.privateIncrementA(1)\n\9\9\9combinedProducer.privateIncrementB(1)\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should call the listener when the state changes\", function()\n\9\9\9local called = false\n\9\9\9local unsubscribe = combinedProducer:subscribe(function()\n\9\9\9\9called = true\n\9\9\9end)\n\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9\9expect(called).to.equal(true)\n\9\9end)\n\n\9\9it(\"should not call the listener when the state does not change\", function()\n\9\9\9local called = false\n\9\9\9local unsubscribe = combinedProducer:subscribe(function()\n\9\9\9\9called = true\n\9\9\9end)\n\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9\9expect(called).to.equal(false)\n\9\9end)\n\n\9\9it(\"should pass the current and previous state\", function()\n\9\9\9local previousState = combinedProducer:getState()\n\9\9\9local unsubscribe = combinedProducer:subscribe(function(receivedState, receivedPreviousState)\n\9\9\9\9expect(receivedState).to.be.a(\"table\")\n\9\9\9\9expect(receivedPreviousState).to.be.a(\"table\")\n\9\9\9\9expect(receivedState).to.never.equal(receivedPreviousState)\n\9\9\9\9expect(receivedState).to.equal(combinedProducer:getState())\n\9\9\9\9expect(receivedPreviousState).to.equal(previousState)\n\9\9\9end)\n\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.observe\", function()\n\9\9it(\"should observe a selection of the combined producer\", function()\n\9\9\9local function selectPrivateCounterA(state)\n\9\9\9\9return state.producerA.privateCounter\n\9\9\9end\n\n\9\9\9local unsubscribe = combinedProducer:observe(selectPrivateCounterA, function(privateCounterA)\n\9\9\9\9expect(privateCounterA).to.equal(3)\n\9\9\9end)\n\n\9\9\9combinedProducer.privateIncrementA(1)\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should not update if a different part of the state changes\", function()\n\9\9\9local function selectPrivateCounterA(state)\n\9\9\9\9return state.producerA.privateCounter\n\9\9\9end\n\n\9\9\9local updated = false\n\n\9\9\9local unsubscribe = combinedProducer:observe(selectPrivateCounterA, function(privateCounterA)\n\9\9\9\9updated = true\n\9\9\9end)\n\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\n\9\9\9expect(updated).to.equal(false)\n\9\9end)\n\n\9\9it(\"should pass the current and previous state\", function()\n\9\9\9local function selectPrivateCounterA(state)\n\9\9\9\9return state.producerA.privateCounter\n\9\9\9end\n\n\9\9\9local previousState = selectPrivateCounterA(combinedProducer:getState())\n\n\9\9\9local unsubscribe = combinedProducer:observe(\n\9\9\9\9selectPrivateCounterA,\n\9\9\9\9function(receivedCurrentState, receivedPreviousState)\n\9\9\9\9\9expect(receivedPreviousState).to.equal(previousState)\n\9\9\9\9\9expect(receivedCurrentState).to.equal(selectPrivateCounterA(combinedProducer:getState()))\n\9\9\9\9end\n\9\9\9)\n\n\9\9\9combinedProducer.privateIncrementA(1)\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.setState\", function()\n\9\9it(\"should set the state of the combined producer\", function()\n\9\9\9local newState = {\n\9\9\9\9producerA = {\n\9\9\9\9\9sharedCounter = 1,\n\9\9\9\9\9privateCounter = 1,\n\9\9\9\9},\n\9\9\9\9producerB = {\n\9\9\9\9\9sharedCounter = 1,\n\9\9\9\9\9privateCounter = 1,\n\9\9\9\9},\n\9\9\9}\n\n\9\9\9combinedProducer:setState(newState)\n\9\9\9local state = combinedProducer:getState()\n\n\9\9\9-- Check shallow equality\n\9\9\9for key, value in pairs(newState) do\n\9\9\9\9expect(state[key]).to.equal(value)\n\9\9\9end\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.select\", function()\n\9\9it(\"should select a part of the state\", function()\n\9\9\9local function selectPrivateCounterA(state)\n\9\9\9\9return state.producerA.privateCounter\n\9\9\9end\n\9\9\9local actualState = selectPrivateCounterA(combinedProducer:getState())\n\9\9\9local selectedState = combinedProducer:select(selectPrivateCounterA)\n\9\9\9expect(selectedState).to.equal(actualState)\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.once\", function()\n\9\9it(\"should call the listener once\", function()\n\9\9\9local called = 0\n\9\9\9local unsubscribe = combinedProducer:once(function(state)\n\9\9\9\9return state.producerA.sharedCounter\n\9\9\9end, function()\n\9\9\9\9called = called + 1\n\9\9\9end)\n\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer:flush()\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9\9expect(called).to.equal(1)\n\9\9end)\n\n\9\9it(\"should not call the listener when the state does not change\", function()\n\9\9\9local called = 0\n\9\9\9local unsubscribe = combinedProducer:once(function(state)\n\9\9\9\9return state.producerA.sharedCounter\n\9\9\9end, function()\n\9\9\9\9called = called + 1\n\9\9\9end)\n\n\9\9\9combinedProducer:flush()\n\9\9\9unsubscribe()\n\9\9\9expect(called).to.equal(0)\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer.wait\", function()\n\9\9it(\"should return a Promise\", function()\n\9\9\9local promise = combinedProducer:wait(function()\n\9\9\9\9return true\n\9\9\9end)\n\9\9\9expect(promise).to.be.a(\"table\")\n\9\9\9expect(promise.andThen).to.be.a(\"function\")\n\9\9\9promise:cancel()\n\9\9end)\n\n\9\9it(\"should resolve when the selected state changes\", function()\n\9\9\9local current = combinedProducer:getState()\n\9\9\9local promise = combinedProducer\n\9\9\9\9:wait(function(state)\n\9\9\9\9\9return state == current\n\9\9\9\9end)\n\9\9\9\9:andThen(function(isEqual)\n\9\9\9\9\9expect(isEqual).to.equal(false)\n\9\9\9\9end)\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer:flush()\n\9\9end)\n\9end)\n\n\9describe(\"CombinedProducer\", function()\n\9\9it(\"should support Promise.fromEvent\", function()\n\9\9\9expect(function()\n\9\9\9\9Promise.fromEvent(combinedProducer):cancel()\n\9\9\9end).never.to.throw()\n\9\9end)\n\n\9\9it(\"should resolve Promise.fromEvent when the state changes\", function()\n\9\9\9local promise = Promise.fromEvent(combinedProducer)\n\9\9\9combinedProducer.sharedIncrement(1)\n\9\9\9combinedProducer:flush()\n\9\9\9local resolved, state = promise:await()\n\9\9\9expect(resolved).to.equal(true)\n\9\9\9expect(state).to.equal(combinedProducer:getState())\n\9\9end)\n\9end)\nend\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.combine-producers.spec"))(__env)
end)
__rbx("components", "Folder", "bundle-ex.include.node_modules.@rbxts.reflex.out.components", "bundle-ex.include.node_modules.@rbxts.reflex.out")
__lua("ReflexContext", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.components.ReflexContext", "bundle-ex.include.node_modules.@rbxts.reflex.out.components", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.components.ReflexContext\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal createContext = TS.import(script, TS.getModule(script, \"@rbxts\", \"roact\").src).createContext\nlocal ReflexContext = createContext({})\nlocal default = ReflexContext\nreturn {\n\9default = default,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.components.ReflexContext"))(__env)
end)
__lua("ReflexProvider", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.components.ReflexProvider", "bundle-ex.include.node_modules.@rbxts.reflex.out.components", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.components.ReflexProvider\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal Roact = TS.import(script, TS.getModule(script, \"@rbxts\", \"roact\").src)\nlocal useMemo = TS.import(script, TS.getModule(script, \"@rbxts\", \"roact-hooked\").src).useMemo\nlocal ReflexContext = TS.import(script, script.Parent, \"ReflexContext\").default\nlocal function ReflexProvider(_param)\n\9local producer = _param.producer\n\9local initialState = _param.initialState\n\9local children = _param[Roact.Children]\n\9local contextValue = useMemo(function()\n\9\9local _fn = producer\n\9\9local _object = {}\n\9\9local _spread = producer:getState()\n\9\9if type(_spread) == \"table\" then\n\9\9\9for _k, _v in _spread do\n\9\9\9\9_object[_k] = _v\n\9\9\9end\n\9\9end\n\9\9_object.initialState = initialState\n\9\9_fn:setState(_object)\n\9\9return {\n\9\9\9producer = producer,\n\9\9}\n\9end, { producer })\n\9local _attributes = {\n\9\9value = contextValue,\n\9}\n\9local _children = {}\n\9local _length = #_children\n\9if children then\n\9\9for _k, _v in children do\n\9\9\9if type(_k) == \"number\" then\n\9\9\9\9_children[_length + _k] = _v\n\9\9\9else\n\9\9\9\9_children[_k] = _v\n\9\9\9end\n\9\9end\n\9end\n\9return Roact.createElement(ReflexContext.Provider, _attributes, _children)\nend\nreturn {\n\9default = ReflexProvider,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.components.ReflexProvider"))(__env)
end)
__lua("create-producer", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-producer", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.create-producer\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\n--[[\n\9*\n\9* Creates a producer that can be used to manage state.\n\9*\n\9* A producer is a state container that exposes a set of dispatchers that can\n\9* be used to modify the state. The state is immutable, so the dispatchers\n\9* return a new state object.\n\9*\n\9* The dispatchers are also exposed as callbacks in the producer, and are based\n\9* on the actions parameter, but with the first argument omitted.\n\9*\n\9* @param initialState The initial state of the producer.\n\9* @param actions A set of actions that can be used to modify the state.\n\9* @returns A producer that can be used to manage state.\n]]\nlocal function createProducer(initialState, actions)\n\9local state = initialState\n\9local stateSinceFlush = initialState\n\9local nextFlush\n\9local nextSubscriptionId = 0\n\9local subscribers = {}\n\9local dispatchers = {}\n\9local producer\n\9for actionName, action in pairs(actions) do\n\9\9dispatchers[actionName] = function(...)\n\9\9\9local args = { ... }\n\9\9\9local prevState = state\n\9\9\9state = action(prevState, unpack(args))\n\9\9\9if prevState ~= state and not nextFlush then\n\9\9\9\9nextFlush = task.defer(function()\n\9\9\9\9\9nextFlush = nil\n\9\9\9\9\9producer:flush()\n\9\9\9\9end)\n\9\9\9end\n\9\9\9return state\n\9\9end\n\9end\n\9local _object = {\n\9\9getState = function(self)\n\9\9\9return state\n\9\9end,\n\9\9select = function(self, selector)\n\9\9\9return selector(state)\n\9\9end,\n\9\9setState = function(self, newState)\n\9\9\9local _newState = newState\n\9\9\9state = if type(_newState) == \"table\" then table.clone(newState) else newState\n\9\9\9if not nextFlush then\n\9\9\9\9nextFlush = task.defer(function()\n\9\9\9\9\9nextFlush = nil\n\9\9\9\9\9self:flush()\n\9\9\9\9end)\n\9\9\9end\n\9\9\9return state\n\9\9end,\n\9\9getDispatchers = function(self)\n\9\9\9return dispatchers\n\9\9end,\n\9\9flush = function(self)\n\9\9\9if nextFlush then\n\9\9\9\9task.cancel(nextFlush)\n\9\9\9\9nextFlush = nil\n\9\9\9end\n\9\9\9if stateSinceFlush ~= state then\n\9\9\9\9local prevState = stateSinceFlush\n\9\9\9\9stateSinceFlush = state\n\9\9\9\9for _, subscriber in subscribers do\n\9\9\9\9\9subscriber(state, prevState)\n\9\9\9\9end\n\9\9\9end\n\9\9end,\n\9\9subscribe = function(self, callback)\n\9\9\9local _original = nextSubscriptionId\n\9\9\9nextSubscriptionId += 1\n\9\9\9local id = _original\n\9\9\9local _callback = callback\n\9\9\9subscribers[id] = _callback\n\9\9\9return function()\n\9\9\9\9subscribers[id] = nil\n\9\9\9end\n\9\9end,\n\9\9observe = function(self, selector, callback)\n\9\9\9local selection = selector(state)\n\9\9\9return self:subscribe(function()\n\9\9\9\9local newSelection = selector(state)\n\9\9\9\9if selection ~= newSelection then\n\9\9\9\9\9local prevSelection = selection\n\9\9\9\9\9selection = newSelection\n\9\9\9\9\9callback(newSelection, prevSelection)\n\9\9\9\9end\n\9\9\9end)\n\9\9end,\n\9\9once = function(self, selector, callback)\n\9\9\9local unsubscribe\n\9\9\9unsubscribe = self:observe(selector, function(state, prevState)\n\9\9\9\9unsubscribe()\n\9\9\9\9callback(state, prevState)\n\9\9\9end)\n\9\9\9return unsubscribe\n\9\9end,\n\9\9wait = function(self, selector)\n\9\9\9return TS.Promise.new(function(resolve, _, onCancel)\n\9\9\9\9local unsubscribe = self:once(selector, resolve)\n\9\9\9\9onCancel(unsubscribe)\n\9\9\9end)\n\9\9end,\n\9\9destroy = function(self)\n\9\9\9if nextFlush then\n\9\9\9\9task.cancel(nextFlush)\n\9\9\9\9nextFlush = nil\n\9\9\9end\n\9\9\9table.clear(subscribers)\n\9\9end,\n\9\9enhance = function(self, enhancer)\n\9\9\9return enhancer(self)\n\9\9end,\n\9\9Connect = function(self, callback)\n\9\9\9local unsubscribe = self:subscribe(callback)\n\9\9\9return {\n\9\9\9\9Connected = true,\n\9\9\9\9Disconnect = function(self)\n\9\9\9\9\9self.Connected = false\n\9\9\9\9\9unsubscribe()\n\9\9\9\9end,\n\9\9\9}\n\9\9end,\n\9\9Once = function(self, callback)\n\9\9\9local unsubscribe = self:once(function(state)\n\9\9\9\9return state\n\9\9\9end, callback)\n\9\9\9return {\n\9\9\9\9Connected = true,\n\9\9\9\9Disconnect = function(self)\n\9\9\9\9\9self.Connected = false\n\9\9\9\9\9unsubscribe()\n\9\9\9\9end,\n\9\9\9}\n\9\9end,\n\9\9Wait = function(self)\n\9\9\9return self:wait(function(state)\n\9\9\9\9return state\n\9\9\9end):expect()\n\9\9end,\n\9}\n\9for _k, _v in dispatchers do\n\9\9_object[_k] = _v\n\9end\n\9producer = _object\n\9return producer\nend\nreturn {\n\9createProducer = createProducer,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-producer"))(__env)
end)
__lua("create-producer.spec", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-producer.spec", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.create-producer.spec\")local script,require=_.script,_.require return function()\n\9local createProducer = require(script.Parent[\"create-producer\"]).createProducer\n\9local Promise = require(game:GetService(\"ReplicatedStorage\").include.Promise)\n\n\9local producer\n\n\9local initialState = { counter = 0, setter = 0 }\n\9local actions = {\n\9\9increment = function(state, amount)\n\9\9\9return { counter = state.counter + amount, setter = state.setter }\n\9\9end,\n\9\9decrement = function(state, amount)\n\9\9\9return { counter = state.counter - amount, setter = state.setter }\n\9\9end,\n\9\9setSetter = function(state, value)\n\9\9\9return { counter = state.counter, setter = value }\n\9\9end,\n\9}\n\n\9describe(\"createProducer\", function()\n\9\9it(\"should return a producer table\", function()\n\9\9\9producer = createProducer(initialState, actions)\n\9\9\9expect(producer).to.be.a(\"table\")\n\9\9\9expect(producer.getState).to.be.a(\"function\")\n\9\9\9expect(producer.getDispatchers).to.be.a(\"function\")\n\9\9\9expect(producer.flush).to.be.a(\"function\")\n\9\9\9expect(producer.subscribe).to.be.a(\"function\")\n\9\9\9expect(producer.observe).to.be.a(\"function\")\n\9\9\9expect(producer.once).to.be.a(\"function\")\n\9\9\9expect(producer.wait).to.be.a(\"function\")\n\9\9\9expect(producer.select).to.be.a(\"function\")\n\9\9end)\n\9end)\n\n\9describe(\"Producer.getState\", function()\n\9\9it(\"should return the initial state\", function()\n\9\9\9local state = producer:getState()\n\9\9\9expect(state).to.be.a(\"table\")\n\9\9\9expect(state.counter).to.equal(0)\n\9\9\9expect(state.setter).to.equal(0)\n\9\9end)\n\9end)\n\n\9describe(\"Producer.getDispatchers\", function()\n\9\9it(\"should return a table of dispatchers\", function()\n\9\9\9local dispatchers = producer:getDispatchers()\n\9\9\9expect(dispatchers).to.be.a(\"table\")\n\9\9\9expect(dispatchers.increment).to.be.a(\"function\")\n\9\9\9expect(dispatchers.decrement).to.be.a(\"function\")\n\9\9\9expect(dispatchers.setSetter).to.be.a(\"function\")\n\9\9end)\n\9end)\n\n\9describe(\"Producer[action]\", function()\n\9\9it(\"should dispatch the increment action\", function()\n\9\9\9producer.increment(1)\n\9\9\9local state = producer:getState()\n\9\9\9expect(state.counter).to.equal(1)\n\9\9\9expect(state.setter).to.equal(0)\n\9\9end)\n\n\9\9it(\"should dispatch the decrement action\", function()\n\9\9\9producer.decrement(1)\n\9\9\9local state = producer:getState()\n\9\9\9expect(state.counter).to.equal(0)\n\9\9\9expect(state.setter).to.equal(0)\n\9\9end)\n\9end)\n\n\9describe(\"Producer.subscribe\", function()\n\9\9it(\"should return an unsubscribe function\", function()\n\9\9\9local unsubscribe = producer:subscribe(function() end)\n\9\9\9expect(unsubscribe).to.be.a(\"function\")\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should call the listener when the state changes\", function()\n\9\9\9local called = false\n\9\9\9local unsubscribe = producer:subscribe(function()\n\9\9\9\9called = true\n\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(true)\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should pass the previous state to the listener\", function()\n\9\9\9local prevState = producer:getState()\n\9\9\9local receivedState\n\9\9\9local unsubscribe = producer:subscribe(function(_, state)\n\9\9\9\9receivedState = state\n\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(receivedState).to.equal(prevState)\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should not call the listener when the state does not change\", function()\n\9\9\9local called = false\n\9\9\9local unsubscribe = producer:subscribe(function()\n\9\9\9\9called = true\n\9\9\9end)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(false)\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should not call the listener after it is unsubscribed\", function()\n\9\9\9local called = false\n\9\9\9local unsubscribe = producer:subscribe(function()\n\9\9\9\9called = true\n\9\9\9end)\n\9\9\9unsubscribe()\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(false)\n\9\9end)\n\n\9\9it(\"should call the listener with the new state\", function()\n\9\9\9local prevState = producer:getState()\n\9\9\9local state\n\9\9\9local unsubscribe = producer:subscribe(function(newState)\n\9\9\9\9state = newState\n\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(state).to.be.a(\"table\")\n\9\9\9expect(state.counter).to.equal(prevState.counter + 1)\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should only call the listener once if it flushed multiple times\", function()\n\9\9\9local called = 0\n\9\9\9local unsubscribe = producer:subscribe(function()\n\9\9\9\9called = called + 1\n\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(1)\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should pass the current and previous state\", function()\n\9\9\9local previousState = producer:getState()\n\9\9\9local unsubscribe = producer:subscribe(function(receivedState, receivedPreviousState)\n\9\9\9\9expect(receivedState).to.be.a(\"table\")\n\9\9\9\9expect(receivedPreviousState).to.be.a(\"table\")\n\9\9\9\9expect(receivedState).to.never.equal(receivedPreviousState)\n\9\9\9\9expect(receivedState).to.equal(producer:getState())\n\9\9\9\9expect(receivedPreviousState).to.equal(previousState)\n\9\9\9end)\n\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9unsubscribe()\n\9\9end)\n\9end)\n\n\9describe(\"Producer.observe\", function()\n\9\9local selector = function(state)\n\9\9\9return state.counter\n\9\9end\n\n\9\9it(\"should return an unsubscribe function\", function()\n\9\9\9local unsubscribe = producer:observe(selector, function() end)\n\9\9\9expect(unsubscribe).to.be.a(\"function\")\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should call the listener when the state changes\", function()\n\9\9\9local called = false\n\9\9\9local unsubscribe = producer:observe(selector, function()\n\9\9\9\9called = true\n\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(true)\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should not call the listener when a different part of the state changes\", function()\n\9\9\9local called = false\n\9\9\9local unsubscribe = producer:observe(selector, function()\n\9\9\9\9called = true\n\9\9\9end)\n\9\9\9producer.setSetter(1)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(false)\n\9\9\9unsubscribe()\n\9\9end)\n\n\9\9it(\"should pass the current and previous state\", function()\n\9\9\9local previousState = selector(producer:getState())\n\9\9\9local unsubscribe = producer:observe(selector, function(receivedState, receivedPreviousState)\n\9\9\9\9expect(receivedState).to.be.a(\"number\")\n\9\9\9\9expect(receivedPreviousState).to.be.a(\"number\")\n\9\9\9\9expect(receivedState).to.never.equal(receivedPreviousState)\n\9\9\9\9expect(receivedState).to.equal(selector(producer:getState()))\n\9\9\9\9expect(receivedPreviousState).to.equal(previousState)\n\9\9\9end)\n\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9unsubscribe()\n\9\9end)\n\9end)\n\n\9describe(\"Producer.setState\", function()\n\9\9it(\"should set the state\", function()\n\9\9\9producer:setState({\n\9\9\9\9counter = 1,\n\9\9\9\9setter = 1,\n\9\9\9})\n\9\9\9local state = producer:getState()\n\9\9\9expect(state.counter).to.equal(1)\n\9\9\9expect(state.setter).to.equal(1)\n\9\9end)\n\9end)\n\n\9describe(\"Producer.select\", function()\n\9\9it(\"should return a selection of the state\", function()\n\9\9\9local selection = producer:select(function(state)\n\9\9\9\9return state.counter\n\9\9\9end)\n\9\9\9expect(selection).to.be.a(\"number\")\n\9\9end)\n\9end)\n\n\9describe(\"Producer.once\", function()\n\9\9it(\"should call the listener once\", function()\n\9\9\9local called = 0\n\9\9\9producer:once(function(state)\n\9\9\9\9return state.counter\n\9\9\9end, function()\n\9\9\9\9called = called + 1\n\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(1)\n\9\9end)\n\n\9\9it(\"should not call the listener again\", function()\n\9\9\9local called = 0\n\9\9\9producer:once(function(state)\n\9\9\9\9return state.counter\n\9\9\9end, function()\n\9\9\9\9called = called + 1\n\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9\9expect(called).to.equal(1)\n\9\9end)\n\9end)\n\n\9describe(\"Producer.wait\", function()\n\9\9it(\"should return a Promise\", function()\n\9\9\9local promise = producer:wait(function()\n\9\9\9\9return true\n\9\9\9end)\n\9\9\9expect(promise).to.be.a(\"table\")\n\9\9\9expect(promise.andThen).to.be.a(\"function\")\n\9\9\9promise:cancel()\n\9\9end)\n\n\9\9it(\"should resolve when the selected state changes\", function()\n\9\9\9local current = producer:getState()\n\9\9\9local promise = producer\n\9\9\9\9:wait(function(state)\n\9\9\9\9\9return state.counter == current.counter\n\9\9\9\9end)\n\9\9\9\9:andThen(function(isEqual)\n\9\9\9\9\9expect(isEqual).to.equal(false)\n\9\9\9\9end)\n\9\9\9producer.increment(1)\n\9\9\9producer:flush()\n\9\9end)\n\9end)\n\n\9describe(\"Producer\", function()\n\9\9it(\"should contain action functions\", function()\n\9\9\9expect(producer.increment).to.be.a(\"function\")\n\9\9\9expect(producer.decrement).to.be.a(\"function\")\n\9\9\9expect(producer.setSetter).to.be.a(\"function\")\n\9\9end)\n\n\9\9it(\"should support Promise.fromEvent\", function()\n\9\9\9expect(function()\n\9\9\9\9Promise.fromEvent(producer):cancel()\n\9\9\9end).never.to.throw()\n\9\9end)\n\n\9\9it(\"should resolve Promise.fromEvent when the state changes\", function()\n\9\9\9local promise = Promise.fromEvent(producer, function(state)\n\9\9\9\9return state.setter == 1\n\9\9\9end)\n\9\9\9producer.setSetter(1)\n\9\9\9producer:flush()\n\9\9\9local resolved, state = promise:await()\n\9\9\9expect(resolved).to.equal(true)\n\9\9\9expect(state.setter).to.equal(1)\n\9\9end)\n\9end)\nend\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-producer.spec"))(__env)
end)
__lua("create-selector", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-selector", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.create-selector\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal entries = TS.import(script, script.Parent, \"utils\", \"entries\").entries\n--[[\n\9*\n\9* Creates a memoized selector function. The selector function is only called\n\9* if the outputs of the dependencies have changed.\n\9*\n\9* This function is only necessary if your selector is expensive to compute, or\n\9* derives some state (i.e. mapping an array). This is because selectors are\n\9* called on every state change, and if the selector is expensive, it might\n\9* need to be memoized.\n\9*\n\9* When using more than one dependency, make sure to mark them `as const`!\n\9*\n\9* @param dependencies The selectors that the selector function depends on.\n\9* @param selector The selector function.\n\9* @returns The memoized selector function.\n]]\nlocal function createSelector(dependencies, selector)\n\9local dependencyCache = {}\n\9local argumentCache = {}\n\9local value\n\9local firstCall = true\n\9-- When this memoized selector is called, call the dependencies first. If\n\9-- their outputs are not shallowly equal to the last time the dependencies\n\9-- were called, then call the selector function and return its output.\n\9return function(...)\n\9\9local args = { ... }\n\9\9local argumentsChanged = firstCall\n\9\9local recompute = firstCall\n\9\9for index, argument in entries(args) do\n\9\9\9if argument ~= argumentCache[index] then\n\9\9\9\9argumentsChanged = true\n\9\9\9\9argumentCache[index] = argument\n\9\9\9end\n\9\9end\n\9\9if argumentsChanged then\n\9\9\9for index, dependency in entries(dependencies) do\n\9\9\9\9local result = dependency(unpack(args))\n\9\9\9\9if result ~= dependencyCache[index] then\n\9\9\9\9\9recompute = true\n\9\9\9\9\9dependencyCache[index] = result\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9if recompute then\n\9\9\9firstCall = false\n\9\9\9value = selector(unpack(dependencyCache))\n\9\9end\n\9\9return value\n\9end\nend\nreturn {\n\9createSelector = createSelector,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-selector"))(__env)
end)
__lua("create-selector.spec", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-selector.spec", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.create-selector.spec\")local script,require=_.script,_.require return function()\n\9local createSelector = require(script.Parent[\"create-selector\"]).createSelector\n\n\9local selectorA = function(state)\n\9\9return state.A\n\9end\n\n\9local selectorB = function(state)\n\9\9return state.B\n\9end\n\n\9local selector, result\n\n\9describe(\"createSelector\", function()\n\9\9it(\"should return a function\", function()\n\9\9\9selector = createSelector({ selectorA, selectorB }, function(a, b)\n\9\9\9\9return { a + b }\n\9\9\9end)\n\n\9\9\9expect(selector).to.be.a(\"function\")\n\9\9end)\n\9end)\n\n\9describe(\"selector\", function()\n\9\9it(\"should return the correct value\", function()\n\9\9\9result = selector({ A = 1, B = 2 })\n\n\9\9\9expect(result).to.be.a(\"table\")\n\9\9\9expect(result[1]).to.equal(3)\n\9\9end)\n\n\9\9it(\"should return the same value if the state hasn't changed\", function()\n\9\9\9local newResult = selector({ A = 1, B = 2 })\n\n\9\9\9expect(newResult).to.equal(result)\n\9\9end)\n\n\9\9it(\"should return a new value if the state has changed\", function()\n\9\9\9local newResult = selector({ A = 1, B = 3 })\n\n\9\9\9expect(newResult).never.to.equal(result)\n\9\9\9expect(newResult[1]).to.equal(4)\n\9\9end)\n\n\9\9it(\"should not call the selector if the state hasn't changed\", function()\n\9\9\9local called = false\n\n\9\9\9local selector = createSelector({ selectorA, selectorB }, function(a, b)\n\9\9\9\9called = true\n\9\9\9\9return { a + b }\n\9\9\9end)\n\n\9\9\9selector({ A = 1, B = 123 })\n\9\9\9expect(called).to.equal(true)\n\n\9\9\9called = false\n\9\9\9selector({ A = 1, B = 123 })\n\9\9\9expect(called).to.equal(false)\n\9\9end)\n\9end)\nend\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.create-selector.spec"))(__env)
end)
__rbx("hooks", "Folder", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks", "bundle-ex.include.node_modules.@rbxts.reflex.out")
__lua("use-producer", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-producer", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-producer\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal useContext = TS.import(script, TS.getModule(script, \"@rbxts\", \"roact-hooked\").src).useContext\nlocal ReflexContext = TS.import(script, script.Parent.Parent, \"components\", \"ReflexContext\").default\n--[[\n\9*\n\9* A hook that returns the producer from the ReflexProvider.\n\9*\n\9* @example\n\9* // reflex-hooks.ts\n\9* export const useAppProducer: UseProducerHook<RootProducer> = useProducer;\n\9*\n\9* // MyComponent.tsx\n\9* const producer = useAppProducer();\n\9* producer.incrementCounter();\n\9*\n\9* @returns The producer from the ReflexProvider.\n]]\n--[[\n\9*\n\9* Returns the producer from the ReflexProvider. Accepts a generic type\n\9* parameter that can be used to narrow the type of the producer.\n\9*\n\9* @example\n\9* const producer = useProducer<MyProducer>();\n\9* producer.incrementCounter();\n\9*\n\9* @returns The producer from the ReflexProvider.\n]]\nlocal function useProducer()\n\9local context = useContext(ReflexContext)\n\9assert(context, \"useProducer must be called from within a ReflexProvider\")\n\9return context.producer\nend\nreturn {\n\9useProducer = useProducer,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-producer"))(__env)
end)
__lua("use-selector-creator", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-selector-creator", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-selector-creator\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal useMemo = TS.import(script, TS.getModule(script, \"@rbxts\", \"roact-hooked\").src).useMemo\nlocal useSelector = TS.import(script, script.Parent, \"use-selector\").useSelector\n--[[\n\9*\n\9* A hook that returns the result of a selector function that is called\n\9* with the current state of the producer.\n\9*\n\9* This type is typically not necessary if your selector function is created\n\9* with an explicitly typed `state` parameter.\n\9*\n\9* @example\n\9* // reflex-hooks.ts\n\9* export const useAppSelectorCreator: UseSelectorCreatorHook<RootProducer> = useSelectorCreator;\n\9*\n\9* // selectors.ts\n\9* export const selectUsers = (state: RootState) => state.users;\n\9* export const selectUsername = (id: number) => {\n\9* \9return createSelector([selectUsers], (users) => users[id].name);\n\9* };\n\9*\n\9* // MyComponent.tsx\n\9* const username = useAppSelectorCreator(selectUsername, 1);\n\9*\n\9* @param selectorCreator A function that takes the current state of the producer\n\9* and returns a value to be used in the component.\n\9* @param args Arguments to pass to the selector creator\n\9* @returns The result of the selector function.\n]]\n--[[\n\9*\n\9* Similar to `useSelector`, but accepts a selector creator function that\n\9* returns a selector. The selector creator is only called when the arguments\n\9* change and the selector is memoized.\n\9*\n\9* @example\n\9* // selectors.ts\n\9* export const selectUsers = (state: RootState) => state.users;\n\9* export const selectUsername = (id: number) => {\n\9* \9return createSelector([selectUsers], (users) => users[id].name);\n\9* };\n\9*\n\9* // MyComponent.tsx\n\9* const username = useSelectorCreator(selectUsername, 1);\n\9*\n\9* @param selectorCreator A function that takes the current state of the producer\n\9* and returns a value to be used in the component.\n\9* @param args Arguments to pass to the selector creator function.\n\9* @returns The result of the selector function.\n]]\nlocal function useSelectorCreator(selectorCreator, ...)\n\9local args = { ... }\n\9local selector = useMemo(function()\n\9\9return selectorCreator(unpack(args))\n\9end, args)\n\9return useSelector(selector)\nend\nreturn {\n\9useSelectorCreator = useSelectorCreator,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-selector-creator"))(__env)
end)
__lua("use-selector", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-selector", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-selector\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal _roact_hooked = TS.import(script, TS.getModule(script, \"@rbxts\", \"roact-hooked\").src)\nlocal useEffect = _roact_hooked.useEffect\nlocal useState = _roact_hooked.useState\nlocal useProducer = TS.import(script, script.Parent, \"use-producer\").useProducer\n--[[\n\9*\n\9* A hook that returns the result of a selector function that is called\n\9* with the current state of the producer.\n\9*\n\9* This type is typically not necessary if your selector function is created\n\9* with an explicitly typed `state` parameter.\n\9*\n\9* @example\n\9* // reflex-hooks.ts\n\9* export const useAppSelector: UseSelectorHook<RootProducer> = useSelector;\n\9*\n\9* // MyComponent.tsx\n\9* const counter = useAppSelector((state) => state.counter);\n\9*\n\9* @param selector A function that takes the current state of the producer\n\9* and returns a value to be used in the component.\n\9* @param equalityFn An optional function that takes the previous and new\n\9* values returned by the selector and returns true if the new value should\n\9* be used in the component.\n\9* @returns The result of the selector function.\n]]\n--[[\n\9*\n\9* Returns the result of a selector function that is called with the current\n\9* state of the producer.\n\9*\n\9* Accepts a generic type parameter to narrow the type of the producer, but it\n\9* is typically not necessary if your selector function is created with an\n\9* explicitly typed `state` parameter.\n\9*\n\9* @example\n\9* const selectCounter = (state: RootState) => state.counter;\n\9* const counter = useSelector(selectCounter);\n\9*\n\9* @param selector A function that takes the current state of the producer\n\9* and returns a value to be used in the component.\n\9* @param equalityFn An optional function that takes the previous and new\n\9* values returned by the selector and returns true if the new value should\n\9* be used in the component.\n\9* @returns The result of the selector function.\n]]\nlocal function useSelector(selector, equalityFn)\n\9local producer = useProducer()\n\9local selection, setSelection = useState(function()\n\9\9return selector(producer:getState())\n\9end)\n\9useEffect(function()\n\9\9local prevSelection = selection\n\9\9return producer:subscribe(function(newState)\n\9\9\9local newSelection = selector(newState)\n\9\9\9if if equalityFn then equalityFn(newSelection, prevSelection) else newSelection ~= prevSelection then\n\9\9\9\9prevSelection = newSelection\n\9\9\9\9setSelection(newSelection)\n\9\9\9end\n\9\9end)\n\9end, { producer, selector })\n\9return selection\nend\nreturn {\n\9useSelector = useSelector,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.hooks.use-selector"))(__env)
end)
__rbx("middleware", "Folder", "bundle-ex.include.node_modules.@rbxts.reflex.out.middleware", "bundle-ex.include.node_modules.@rbxts.reflex.out")
__lua("logger-middleware", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.middleware.logger-middleware", "bundle-ex.include.node_modules.@rbxts.reflex.out.middleware", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.middleware.logger-middleware\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = _G[script]\nlocal entries = TS.import(script, script.Parent.Parent, \"utils\", \"entries\").entries\n--[[\n\9*\n\9* A middleware that logs every action that is dispatched, and the new state\n\9* after the action has been dispatched.\n]]\nlocal loggerMiddleware = function(producer)\n\9return function(done)\n\9\9return function(action)\n\9\9\9local params = {}\n\9\9\9for _, value in entries(action.arguments) do\n\9\9\9\9local _arg0 = tostring(value)\n\9\9\9\9table.insert(params, _arg0)\n\9\9\9end\n\9\9\9print(\"[loggerMiddleware]: Dispatching \" .. (action.type .. (\"(\" .. (table.concat(params, \", \") .. \")\"))))\n\9\9\9local newState = done(action)\n\9\9\9print(\"[loggerMiddleware]: New state:\", producer:getState())\n\9\9\9return newState\n\9\9end\n\9end\nend\nreturn {\n\9loggerMiddleware = loggerMiddleware,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.middleware.logger-middleware"))(__env)
end)
__lua("types", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.types", "bundle-ex.include.node_modules.@rbxts.reflex.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.types\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\n--[[\n\9*\n\9* A Producer is a state container that exposes a set of dispatchers that can\n\9* be used to modify the state. The state is immutable, so the dispatchers\n\9* return a new state object.\n]]\n--[[\n\9*\n\9* A set of actions that is passed to the createProducer function.\n]]\n--[[\n\9*\n\9* An action is a function that takes the current state and returns a new\n\9* state.\n]]\n--[[\n\9*\n\9* A dispatcher similar to an aciton, but omits the first `state` argument.\n\9* This is used to infer the dispatchers from the actions.\n]]\n--[[\n\9*\n\9* Infers the state type from a Producer.\n]]\n--[[\n\9*\n\9* Infers the actions type from a Producer.\n]]\n--[[\n\9*\n\9* Infers the dispatchers type from a Producer.\n]]\nreturn nil\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.types"))(__env)
end)
__rbx("utils", "Folder", "bundle-ex.include.node_modules.@rbxts.reflex.out.utils", "bundle-ex.include.node_modules.@rbxts.reflex.out")
__lua("entries", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.reflex.out.utils.entries", "bundle-ex.include.node_modules.@rbxts.reflex.out.utils", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.reflex.out.utils.entries\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\n--[[\n\9*\n\9* Casts an object to a Map type. This is a workaround for challenges with\n\9* iterating over an object or array.\n\9* @param object The object to cast.\n\9* @returns The object as a Map.\n]]\nlocal function entries(object)\n\9return object\nend\nreturn {\n\9entries = entries,\n}\n", "bundle-ex.include.node_modules.@rbxts.reflex.out.utils.entries"))(__env)
end)
__rbx("roact", "Folder", "bundle-ex.include.node_modules.@rbxts.roact", "bundle-ex.include.node_modules.@rbxts")
__lua("src", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src", "bundle-ex.include.node_modules.@rbxts.roact", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src\")local script,require=_.script,_.require --~strict\n--[[\n\9Packages up the internals of Roact and exposes a public API for it.\n]]\n\nlocal GlobalConfig = require(script.GlobalConfig)\nlocal createReconciler = require(script.createReconciler)\nlocal createReconcilerCompat = require(script.createReconcilerCompat)\nlocal RobloxRenderer = require(script.RobloxRenderer)\nlocal strict = require(script.strict)\nlocal Binding = require(script.Binding)\n\nlocal robloxReconciler = createReconciler(RobloxRenderer)\nlocal reconcilerCompat = createReconcilerCompat(robloxReconciler)\n\nlocal Roact = strict({\n\9Component = require(script.Component),\n\9createElement = require(script.createElement),\n\9createFragment = require(script.createFragment),\n\9oneChild = require(script.oneChild),\n\9PureComponent = require(script.PureComponent),\n\9None = require(script.None),\n\9Portal = require(script.Portal),\n\9createRef = require(script.createRef),\n\9forwardRef = require(script.forwardRef),\n\9createBinding = Binding.create,\n\9joinBindings = Binding.join,\n\9createContext = require(script.createContext),\n\n\9Change = require(script.PropMarkers.Change),\n\9Children = require(script.PropMarkers.Children),\n\9Event = require(script.PropMarkers.Event),\n\9Ref = require(script.PropMarkers.Ref),\n\n\9mount = robloxReconciler.mountVirtualTree,\n\9unmount = robloxReconciler.unmountVirtualTree,\n\9update = robloxReconciler.updateVirtualTree,\n\n\9reify = reconcilerCompat.reify,\n\9teardown = reconcilerCompat.teardown,\n\9reconcile = reconcilerCompat.reconcile,\n\n\9setGlobalConfig = GlobalConfig.set,\n\n\9-- APIs that may change in the future without warning\n\9UNSTABLE = {},\n})\n\nreturn Roact\n", "bundle-ex.include.node_modules.@rbxts.roact.src"))(__env)
end)
__lua("Binding", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.Binding", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.Binding\")local script,require=_.script,_.require local createSignal = require(script.Parent.createSignal)\nlocal Symbol = require(script.Parent.Symbol)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal BindingImpl = Symbol.named(\"BindingImpl\")\n\nlocal BindingInternalApi = {}\n\nlocal bindingPrototype = {}\n\nfunction bindingPrototype:getValue()\n\9return BindingInternalApi.getValue(self)\nend\n\nfunction bindingPrototype:map(predicate)\n\9return BindingInternalApi.map(self, predicate)\nend\n\nlocal BindingPublicMeta = {\n\9__index = bindingPrototype,\n\9__tostring = function(self)\n\9\9return string.format(\"RoactBinding(%s)\", tostring(self:getValue()))\n\9end,\n}\n\nfunction BindingInternalApi.update(binding, newValue)\n\9return binding[BindingImpl].update(newValue)\nend\n\nfunction BindingInternalApi.subscribe(binding, callback)\n\9return binding[BindingImpl].subscribe(callback)\nend\n\nfunction BindingInternalApi.getValue(binding)\n\9return binding[BindingImpl].getValue()\nend\n\nfunction BindingInternalApi.create(initialValue)\n\9local impl = {\n\9\9value = initialValue,\n\9\9changeSignal = createSignal(),\n\9}\n\n\9function impl.subscribe(callback)\n\9\9return impl.changeSignal:subscribe(callback)\n\9end\n\n\9function impl.update(newValue)\n\9\9impl.value = newValue\n\9\9impl.changeSignal:fire(newValue)\n\9end\n\n\9function impl.getValue()\n\9\9return impl.value\n\9end\n\n\9return setmetatable({\n\9\9[Type] = Type.Binding,\n\9\9[BindingImpl] = impl,\n\9}, BindingPublicMeta), impl.update\nend\n\nfunction BindingInternalApi.map(upstreamBinding, predicate)\n\9if config.typeChecks then\n\9\9assert(Type.of(upstreamBinding) == Type.Binding, \"Expected arg #1 to be a binding\")\n\9\9assert(typeof(predicate) == \"function\", \"Expected arg #1 to be a function\")\n\9end\n\n\9local impl = {}\n\n\9function impl.subscribe(callback)\n\9\9return BindingInternalApi.subscribe(upstreamBinding, function(newValue)\n\9\9\9callback(predicate(newValue))\n\9\9end)\n\9end\n\n\9function impl.update(_newValue)\n\9\9error(\"Bindings created by Binding:map(fn) cannot be updated directly\", 2)\n\9end\n\n\9function impl.getValue()\n\9\9return predicate(upstreamBinding:getValue())\n\9end\n\n\9return setmetatable({\n\9\9[Type] = Type.Binding,\n\9\9[BindingImpl] = impl,\n\9}, BindingPublicMeta)\nend\n\nfunction BindingInternalApi.join(upstreamBindings)\n\9if config.typeChecks then\n\9\9assert(typeof(upstreamBindings) == \"table\", \"Expected arg #1 to be of type table\")\n\n\9\9for key, value in pairs(upstreamBindings) do\n\9\9\9if Type.of(value) ~= Type.Binding then\n\9\9\9\9local message = (\"Expected arg #1 to contain only bindings, but key %q had a non-binding value\"):format(\n\9\9\9\9\9tostring(key)\n\9\9\9\9)\n\9\9\9\9error(message, 2)\n\9\9\9end\n\9\9end\n\9end\n\n\9local impl = {}\n\n\9local function getValue()\n\9\9local value = {}\n\n\9\9for key, upstream in pairs(upstreamBindings) do\n\9\9\9value[key] = upstream:getValue()\n\9\9end\n\n\9\9return value\n\9end\n\n\9function impl.subscribe(callback)\n\9\9local disconnects = {}\n\n\9\9for key, upstream in pairs(upstreamBindings) do\n\9\9\9disconnects[key] = BindingInternalApi.subscribe(upstream, function(_newValue)\n\9\9\9\9callback(getValue())\n\9\9\9end)\n\9\9end\n\n\9\9return function()\n\9\9\9if disconnects == nil then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9for _, disconnect in pairs(disconnects) do\n\9\9\9\9disconnect()\n\9\9\9end\n\n\9\9\9disconnects = nil :: any\n\9\9end\n\9end\n\n\9function impl.update(_newValue)\n\9\9error(\"Bindings created by joinBindings(...) cannot be updated directly\", 2)\n\9end\n\n\9function impl.getValue()\n\9\9return getValue()\n\9end\n\n\9return setmetatable({\n\9\9[Type] = Type.Binding,\n\9\9[BindingImpl] = impl,\n\9}, BindingPublicMeta)\nend\n\nreturn BindingInternalApi\n", "bundle-ex.include.node_modules.@rbxts.roact.src.Binding"))(__env)
end)
__lua("Component", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.Component", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.Component\")local script,require=_.script,_.require local assign = require(script.Parent.assign)\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\nlocal Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\nlocal invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\n--[[\n\9Calling setState during certain lifecycle allowed methods has the potential\n\9to create an infinitely updating component. Rather than time out, we exit\n\9with an error if an unreasonable number of self-triggering updates occur\n]]\nlocal MAX_PENDING_UPDATES = 100\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\nlocal componentMissingRenderMessage = [[\nThe component %q is missing the `render` method.\n`render` must be defined when creating a Roact component!]]\n\nlocal tooManyUpdatesMessage = [[\nThe component %q has reached the setState update recursion limit.\nWhen using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]\n\nlocal componentClassMetatable = {}\n\nfunction componentClassMetatable:__tostring()\n\9return self.__componentName\nend\n\nlocal Component = {}\nsetmetatable(Component, componentClassMetatable)\n\nComponent[Type] = Type.StatefulComponentClass\nComponent.__index = Component\nComponent.__componentName = \"Component\"\n\n--[[\n\9A method called by consumers of Roact to create a new component class.\n\9Components can not be extended beyond this point, with the exception of\n\9PureComponent.\n]]\nfunction Component:extend(name)\n\9if config.typeChecks then\n\9\9assert(Type.of(self) == Type.StatefulComponentClass, \"Invalid `self` argument to `extend`.\")\n\9\9assert(typeof(name) == \"string\", \"Component class name must be a string\")\n\9end\n\n\9local class = {}\n\n\9for key, value in pairs(self) do\n\9\9-- Roact opts to make consumers use composition over inheritance, which\n\9\9-- lines up with React.\n\9\9-- https://reactjs.org/docs/composition-vs-inheritance.html\n\9\9if key ~= \"extend\" then\n\9\9\9class[key] = value\n\9\9end\n\9end\n\n\9class[Type] = Type.StatefulComponentClass\n\9class.__index = class\n\9class.__componentName = name\n\n\9setmetatable(class, componentClassMetatable)\n\n\9return class\nend\n\nfunction Component:__getDerivedState(incomingProps, incomingState)\n\9if config.internalTypeChecks then\n\9\9internalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getDerivedState`\")\n\9end\n\n\9local internalData = self[InternalData]\n\9local componentClass = internalData.componentClass\n\n\9if componentClass.getDerivedStateFromProps ~= nil then\n\9\9local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)\n\n\9\9if derivedState ~= nil then\n\9\9\9if config.typeChecks then\n\9\9\9\9assert(typeof(derivedState) == \"table\", \"getDerivedStateFromProps must return a table!\")\n\9\9\9end\n\n\9\9\9return derivedState\n\9\9end\n\9end\n\n\9return nil\nend\n\nfunction Component:setState(mapState)\n\9if config.typeChecks then\n\9\9assert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid `self` argument to `extend`.\")\n\9end\n\n\9local internalData = self[InternalData]\n\9local lifecyclePhase = internalData.lifecyclePhase\n\n\9--[[\n\9\9When preparing to update, render, or unmount, it is not safe\n\9\9to call `setState` as it will interfere with in-flight updates. It's\n\9\9also disallowed during unmounting\n\9]]\n\9if\n\9\9lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate\n\9\9or lifecyclePhase == ComponentLifecyclePhase.WillUpdate\n\9\9or lifecyclePhase == ComponentLifecyclePhase.Render\n\9then\n\9\9local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]\n\n\9\9local message = messageTemplate:format(tostring(internalData.componentClass))\n\9\9error(message, 2)\n\9elseif lifecyclePhase == ComponentLifecyclePhase.WillUnmount then\n\9\9-- Should not print error message. See https://github.com/facebook/react/pull/22114\n\9\9return\n\9end\n\n\9local pendingState = internalData.pendingState\n\n\9local partialState\n\9if typeof(mapState) == \"function\" then\n\9\9partialState = mapState(pendingState or self.state, self.props)\n\n\9\9-- Abort the state update if the given state updater function returns nil\n\9\9if partialState == nil then\n\9\9\9return\n\9\9end\n\9elseif typeof(mapState) == \"table\" then\n\9\9partialState = mapState\n\9else\n\9\9error(\"Invalid argument to setState, expected function or table\", 2)\n\9end\n\n\9local newState\n\9if pendingState ~= nil then\n\9\9newState = assign(pendingState, partialState)\n\9else\n\9\9newState = assign({}, self.state, partialState)\n\9end\n\n\9if lifecyclePhase == ComponentLifecyclePhase.Init then\n\9\9-- If `setState` is called in `init`, we can skip triggering an update!\n\9\9local derivedState = self:__getDerivedState(self.props, newState)\n\9\9self.state = assign(newState, derivedState)\n\9elseif\n\9\9lifecyclePhase == ComponentLifecyclePhase.DidMount\n\9\9or lifecyclePhase == ComponentLifecyclePhase.DidUpdate\n\9\9or lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren\n\9then\n\9\9--[[\n\9\9\9During certain phases of the component lifecycle, it's acceptable to\n\9\9\9allow `setState` but defer the update until we're done with ones in flight.\n\9\9\9We do this by collapsing it into any pending updates we have.\n\9\9]]\n\9\9local derivedState = self:__getDerivedState(self.props, newState)\n\9\9internalData.pendingState = assign(newState, derivedState)\n\9elseif lifecyclePhase == ComponentLifecyclePhase.Idle then\n\9\9-- Outside of our lifecycle, the state update is safe to make immediately\n\9\9self:__update(nil, newState)\n\9else\n\9\9local messageTemplate = invalidSetStateMessages.default\n\n\9\9local message = messageTemplate:format(tostring(internalData.componentClass))\n\n\9\9error(message, 2)\n\9end\nend\n\n--[[\n\9Returns the stack trace of where the element was created that this component\n\9instance's properties are based on.\n\n\9Intended to be used primarily by diagnostic tools.\n]]\nfunction Component:getElementTraceback()\n\9return self[InternalData].virtualNode.currentElement.source\nend\n\n--[[\n\9Returns a snapshot of this component given the current props and state. Must\n\9be overridden by consumers of Roact and should be a pure function with\n\9regards to props and state.\n\n\9TODO (#199): Accept props and state as arguments.\n]]\nfunction Component:render()\n\9local internalData = self[InternalData]\n\n\9local message = componentMissingRenderMessage:format(tostring(internalData.componentClass))\n\n\9error(message, 0)\nend\n\n--[[\n\9Retrieves the context value corresponding to the given key. Can return nil\n\9if a requested context key is not present\n]]\nfunction Component:__getContext(key)\n\9if config.internalTypeChecks then\n\9\9internalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getContext`\")\n\9\9internalAssert(key ~= nil, \"Context key cannot be nil\")\n\9end\n\n\9local virtualNode = self[InternalData].virtualNode\n\9local context = virtualNode.context\n\n\9return context[key]\nend\n\n--[[\n\9Adds a new context entry to this component's context table (which will be\n\9passed down to child components).\n]]\nfunction Component:__addContext(key, value)\n\9if config.internalTypeChecks then\n\9\9internalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__addContext`\")\n\9end\n\9local virtualNode = self[InternalData].virtualNode\n\n\9-- Make sure we store a reference to the component's original, unmodified\n\9-- context the virtual node. In the reconciler, we'll restore the original\n\9-- context if we need to replace the node (this happens when a node gets\n\9-- re-rendered as a different component)\n\9if virtualNode.originalContext == nil then\n\9\9virtualNode.originalContext = virtualNode.context\n\9end\n\n\9-- Build a new context table on top of the existing one, then apply it to\n\9-- our virtualNode\n\9local existing = virtualNode.context\n\9virtualNode.context = assign({}, existing, { [key] = value })\nend\n\n--[[\n\9Performs property validation if the static method validateProps is declared.\n\9validateProps should follow assert's expected arguments:\n\9(false, message: string) | true. The function may return a message in the\n\9true case; it will be ignored. If this fails, the function will throw the\n\9error.\n]]\nfunction Component:__validateProps(props)\n\9if not config.propValidation then\n\9\9return\n\9end\n\n\9local validator = self[InternalData].componentClass.validateProps\n\n\9if validator == nil then\n\9\9return\n\9end\n\n\9if typeof(validator) ~= \"function\" then\n\9\9error(\n\9\9\9(\"validateProps must be a function, but it is a %s.\\nCheck the definition of the component %q.\"):format(\n\9\9\9\9typeof(validator),\n\9\9\9\9self.__componentName\n\9\9\9)\n\9\9)\n\9end\n\n\9local success, failureReason = validator(props)\n\n\9if not success then\n\9\9failureReason = failureReason or \"<Validator function did not supply a message>\"\n\9\9error(\n\9\9\9(\"Property validation failed in %s: %s\\n\\n%s\"):format(\n\9\9\9\9self.__componentName,\n\9\9\9\9tostring(failureReason),\n\9\9\9\9self:getElementTraceback() or \"<enable element tracebacks>\"\n\9\9\9),\n\9\9\0090\n\9\9)\n\9end\nend\n\n--[[\n\9An internal method used by the reconciler to construct a new component\n\9instance and attach it to the given virtualNode.\n]]\nfunction Component:__mount(reconciler, virtualNode)\n\9if config.internalTypeChecks then\n\9\9internalAssert(Type.of(self) == Type.StatefulComponentClass, \"Invalid use of `__mount`\")\n\9\9internalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #2 to be of type VirtualNode\")\n\9end\n\n\9local currentElement = virtualNode.currentElement\n\9local hostParent = virtualNode.hostParent\n\n\9-- Contains all the information that we want to keep from consumers of\n\9-- Roact, or even other parts of the codebase like the reconciler.\n\9local internalData = {\n\9\9reconciler = reconciler,\n\9\9virtualNode = virtualNode,\n\9\9componentClass = self,\n\9\9lifecyclePhase = ComponentLifecyclePhase.Init,\n\9\9pendingState = nil,\n\9}\n\n\9local instance = {\n\9\9[Type] = Type.StatefulComponentInstance,\n\9\9[InternalData] = internalData,\n\9}\n\n\9setmetatable(instance, self)\n\n\9virtualNode.instance = instance\n\n\9local props = currentElement.props\n\n\9if self.defaultProps ~= nil then\n\9\9props = assign({}, self.defaultProps, props)\n\9end\n\n\9instance:__validateProps(props)\n\n\9instance.props = props\n\n\9local newContext = assign({}, virtualNode.legacyContext)\n\9instance._context = newContext\n\n\9instance.state = assign({}, instance:__getDerivedState(instance.props, {}))\n\n\9if instance.init ~= nil then\n\9\9instance:init(instance.props)\n\9\9assign(instance.state, instance:__getDerivedState(instance.props, instance.state))\n\9end\n\n\9-- It's possible for init() to redefine _context!\n\9virtualNode.legacyContext = instance._context\n\n\9internalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\9local renderResult = instance:render()\n\n\9internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\9reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\n\9if instance.didMount ~= nil then\n\9\9internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount\n\9\9instance:didMount()\n\9end\n\n\9if internalData.pendingState ~= nil then\n\9\9-- __update will handle pendingState, so we don't pass any new element or state\n\9\9instance:__update(nil, nil)\n\9end\n\n\9internalData.lifecyclePhase = ComponentLifecyclePhase.Idle\nend\n\n--[[\n\9Internal method used by the reconciler to clean up any resources held by\n\9this component instance.\n]]\nfunction Component:__unmount()\n\9if config.internalTypeChecks then\n\9\9internalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__unmount`\")\n\9end\n\n\9local internalData = self[InternalData]\n\9local virtualNode = internalData.virtualNode\n\9local reconciler = internalData.reconciler\n\n\9if self.willUnmount ~= nil then\n\9\9internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount\n\9\9self:willUnmount()\n\9end\n\n\9for _, childNode in pairs(virtualNode.children) do\n\9\9reconciler.unmountVirtualNode(childNode)\n\9end\nend\n\n--[[\n\9Internal method used by setState (to trigger updates based on state) and by\n\9the reconciler (to trigger updates based on props)\n\n\9Returns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__update(updatedElement, updatedState)\n\9if config.internalTypeChecks then\n\9\9internalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__update`\")\n\9\9internalAssert(\n\9\9\9Type.of(updatedElement) == Type.Element or updatedElement == nil,\n\9\9\9\"Expected arg #1 to be of type Element or nil\"\n\9\9)\n\9\9internalAssert(\n\9\9\9typeof(updatedState) == \"table\" or updatedState == nil,\n\9\9\9\"Expected arg #2 to be of type table or nil\"\n\9\9)\n\9end\n\n\9local internalData = self[InternalData]\n\9local componentClass = internalData.componentClass\n\n\9local newProps = self.props\n\9if updatedElement ~= nil then\n\9\9newProps = updatedElement.props\n\n\9\9if componentClass.defaultProps ~= nil then\n\9\9\9newProps = assign({}, componentClass.defaultProps, newProps)\n\9\9end\n\n\9\9self:__validateProps(newProps)\n\9end\n\n\9local updateCount = 0\n\9repeat\n\9\9local finalState\n\9\9local pendingState = nil\n\n\9\9-- Consume any pending state we might have\n\9\9if internalData.pendingState ~= nil then\n\9\9\9pendingState = internalData.pendingState\n\9\9\9internalData.pendingState = nil\n\9\9end\n\n\9\9-- Consume a standard update to state or props\n\9\9if updatedState ~= nil or newProps ~= self.props then\n\9\9\9if pendingState == nil then\n\9\9\9\9finalState = updatedState or self.state\n\9\9\9else\n\9\9\9\9finalState = assign(pendingState, updatedState)\n\9\9\9end\n\n\9\9\9local derivedState = self:__getDerivedState(newProps, finalState)\n\n\9\9\9if derivedState ~= nil then\n\9\9\9\9finalState = assign({}, finalState, derivedState)\n\9\9\9end\n\n\9\9\9updatedState = nil\n\9\9else\n\9\9\9finalState = pendingState\n\9\9end\n\n\9\9if not self:__resolveUpdate(newProps, finalState) then\n\9\9\9-- If the update was short-circuited, bubble the result up to the caller\n\9\9\9return false\n\9\9end\n\n\9\9updateCount = updateCount + 1\n\n\9\9if updateCount > MAX_PENDING_UPDATES then\n\9\9\9error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)\n\9\9end\n\9until internalData.pendingState == nil\n\n\9return true\nend\n\n--[[\n\9Internal method used by __update to apply new props and state\n\n\9Returns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__resolveUpdate(incomingProps, incomingState)\n\9if config.internalTypeChecks then\n\9\9internalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__resolveUpdate`\")\n\9end\n\n\9local internalData = self[InternalData]\n\9local virtualNode = internalData.virtualNode\n\9local reconciler = internalData.reconciler\n\n\9local oldProps = self.props\n\9local oldState = self.state\n\n\9if incomingProps == nil then\n\9\9incomingProps = oldProps\n\9end\n\9if incomingState == nil then\n\9\9incomingState = oldState\n\9end\n\n\9if self.shouldUpdate ~= nil then\n\9\9internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate\n\9\9local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)\n\n\9\9if not continueWithUpdate then\n\9\9\9internalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\9\9\9return false\n\9\9end\n\9end\n\n\9if self.willUpdate ~= nil then\n\9\9internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate\n\9\9self:willUpdate(incomingProps, incomingState)\n\9end\n\n\9internalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\n\9self.props = incomingProps\n\9self.state = incomingState\n\n\9local renderResult = virtualNode.instance:render()\n\n\9internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\9reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)\n\n\9if self.didUpdate ~= nil then\n\9\9internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate\n\9\9self:didUpdate(oldProps, oldState)\n\9end\n\n\9internalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\9return true\nend\n\nreturn Component\n", "bundle-ex.include.node_modules.@rbxts.roact.src.Component"))(__env)
end)
__lua("ComponentLifecyclePhase", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.ComponentLifecyclePhase", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.ComponentLifecyclePhase\")local script,require=_.script,_.require local Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal ComponentLifecyclePhase = strict({\n\9-- Component methods\n\9Init = Symbol.named(\"init\"),\n\9Render = Symbol.named(\"render\"),\n\9ShouldUpdate = Symbol.named(\"shouldUpdate\"),\n\9WillUpdate = Symbol.named(\"willUpdate\"),\n\9DidMount = Symbol.named(\"didMount\"),\n\9DidUpdate = Symbol.named(\"didUpdate\"),\n\9WillUnmount = Symbol.named(\"willUnmount\"),\n\n\9-- Phases describing reconciliation status\n\9ReconcileChildren = Symbol.named(\"reconcileChildren\"),\n\9Idle = Symbol.named(\"idle\"),\n}, \"ComponentLifecyclePhase\")\n\nreturn ComponentLifecyclePhase\n", "bundle-ex.include.node_modules.@rbxts.roact.src.ComponentLifecyclePhase"))(__env)
end)
__lua("Config", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.Config", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.Config\")local script,require=_.script,_.require --[[\n\9Exposes an interface to set global configuration values for Roact.\n\n\9Configuration can only occur once, and should only be done by an application\n\9using Roact, not a library.\n\n\9Any keys that aren't recognized will cause errors. Configuration is only\n\9intended for configuring Roact itself, not extensions or libraries.\n\n\9Configuration is expected to be set immediately after loading Roact. Setting\n\9configuration values after an application starts may produce unpredictable\n\9behavior.\n]]\n\n-- Every valid configuration value should be non-nil in this table.\nlocal defaultConfig = {\n\9-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.\n\9[\"internalTypeChecks\"] = false,\n\9-- Enables stricter type asserts for Roact's public API.\n\9[\"typeChecks\"] = false,\n\9-- Enables storage of `debug.traceback()` values on elements for debugging.\n\9[\"elementTracing\"] = false,\n\9-- Enables validation of component props in stateful components.\n\9[\"propValidation\"] = false,\n}\n\n-- Build a list of valid configuration values up for debug messages.\nlocal defaultConfigKeys = {}\nfor key in pairs(defaultConfig) do\n\9table.insert(defaultConfigKeys, key)\nend\n\nlocal Config = {}\n\nfunction Config.new()\n\9local self = {}\n\n\9self._currentConfig = setmetatable({}, {\n\9\9__index = function(_, key)\n\9\9\9local message = (\"Invalid global configuration key %q. Valid configuration keys are: %s\"):format(\n\9\9\9\9tostring(key),\n\9\9\9\9table.concat(defaultConfigKeys, \", \")\n\9\9\9)\n\n\9\9\9error(message, 3)\n\9\9end,\n\9})\n\n\9-- We manually bind these methods here so that the Config's methods can be\n\9-- used without passing in self, since they eventually get exposed on the\n\9-- root Roact object.\n\9self.set = function(...)\n\9\9return Config.set(self, ...)\n\9end\n\n\9self.get = function(...)\n\9\9return Config.get(self, ...)\n\9end\n\n\9self.scoped = function(...)\n\9\9return Config.scoped(self, ...)\n\9end\n\n\9self.set(defaultConfig)\n\n\9return self\nend\n\nfunction Config:set(configValues)\n\9-- Validate values without changing any configuration.\n\9-- We only want to apply this configuration if it's valid!\n\9for key, value in pairs(configValues) do\n\9\9if defaultConfig[key] == nil then\n\9\9\9local message = (\"Invalid global configuration key %q (type %s). Valid configuration keys are: %s\"):format(\n\9\9\9\9tostring(key),\n\9\9\9\9typeof(key),\n\9\9\9\9table.concat(defaultConfigKeys, \", \")\n\9\9\9)\n\n\9\9\9error(message, 3)\n\9\9end\n\n\9\9-- Right now, all configuration values must be boolean.\n\9\9if typeof(value) ~= \"boolean\" then\n\9\9\9local message = (\n\9\9\9\9\"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false\"\n\9\9\9):format(tostring(value), typeof(value), tostring(key))\n\n\9\9\9error(message, 3)\n\9\9end\n\n\9\9self._currentConfig[key] = value\n\9end\nend\n\nfunction Config:get()\n\9return self._currentConfig\nend\n\nfunction Config:scoped(configValues, callback)\n\9local previousValues = {}\n\9for key, value in pairs(self._currentConfig) do\n\9\9previousValues[key] = value\n\9end\n\n\9self.set(configValues)\n\n\9local success, result = pcall(callback)\n\n\9self.set(previousValues)\n\n\9assert(success, result)\nend\n\nreturn Config\n", "bundle-ex.include.node_modules.@rbxts.roact.src.Config"))(__env)
end)
__lua("ElementKind", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.ElementKind", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.ElementKind\")local script,require=_.script,_.require --[[\n\9Contains markers for annotating the type of an element.\n\n\9Use `ElementKind` as a key, and values from it as the value.\n\n\9\9local element = {\n\9\9\9[ElementKind] = ElementKind.Host,\n\9\9}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\nlocal Portal = require(script.Parent.Portal)\n\nlocal ElementKind = newproxy(true)\n\nlocal ElementKindInternal = {\n\9Portal = Symbol.named(\"Portal\"),\n\9Host = Symbol.named(\"Host\"),\n\9Function = Symbol.named(\"Function\"),\n\9Stateful = Symbol.named(\"Stateful\"),\n\9Fragment = Symbol.named(\"Fragment\"),\n}\n\nfunction ElementKindInternal.of(value)\n\9if typeof(value) ~= \"table\" then\n\9\9return nil\n\9end\n\n\9return value[ElementKind]\nend\n\nlocal componentTypesToKinds = {\n\9[\"string\"] = ElementKindInternal.Host,\n\9[\"function\"] = ElementKindInternal.Function,\n\9[\"table\"] = ElementKindInternal.Stateful,\n}\n\nfunction ElementKindInternal.fromComponent(component)\n\9if component == Portal then\n\9\9return ElementKind.Portal\n\9else\n\9\9return componentTypesToKinds[typeof(component)]\n\9end\nend\n\ngetmetatable(ElementKind).__index = ElementKindInternal\n\nstrict(ElementKindInternal, \"ElementKind\")\n\nreturn ElementKind\n", "bundle-ex.include.node_modules.@rbxts.roact.src.ElementKind"))(__env)
end)
__lua("ElementUtils", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.ElementUtils", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.ElementUtils\")local script,require=_.script,_.require --!strict\nlocal Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal function noop()\n\9return nil\nend\n\nlocal ElementUtils = {}\n\n--[[\n\9A signal value indicating that a child should use its parent's key, because\n\9it has no key of its own.\n\n\9This occurs when you return only one element from a function component or\n\9stateful render function.\n]]\nElementUtils.UseParentKey = Symbol.named(\"UseParentKey\")\n\ntype Iterator<K, V> = ({ [K]: V }, K?) -> (K?, V?)\ntype Element = { [any]: any }\n--[[\n\9Returns an iterator over the children of an element.\n\9`elementOrElements` may be one of:\n\9* a boolean\n\9* nil\n\9* a single element\n\9* a fragment\n\9* a table of elements\n\n\9If `elementOrElements` is a boolean or nil, this will return an iterator with\n\9zero elements.\n\n\9If `elementOrElements` is a single element, this will return an iterator with\n\9one element: a tuple where the first value is ElementUtils.UseParentKey, and\n\9the second is the value of `elementOrElements`.\n\n\9If `elementOrElements` is a fragment or a table, this will return an iterator\n\9over all the elements of the array.\n\n\9If `elementOrElements` is none of the above, this function will throw.\n]]\nfunction ElementUtils.iterateElements<K>(elementOrElements): (Iterator<K, Element>, any, nil)\n\9local richType = Type.of(elementOrElements)\n\n\9-- Single child\n\9if richType == Type.Element then\n\9\9local called = false\n\n\9\9return function(_, _)\n\9\9\9if called then\n\9\9\9\9return nil\n\9\9\9else\n\9\9\9\9called = true\n\9\9\9\9return ElementUtils.UseParentKey, elementOrElements\n\9\9\9end\n\9\9end\n\9end\n\n\9local regularType = typeof(elementOrElements)\n\n\9if elementOrElements == nil or regularType == \"boolean\" then\n\9\9return (noop :: any) :: Iterator<K, Element>\n\9end\n\n\9if regularType == \"table\" then\n\9\9return pairs(elementOrElements)\n\9end\n\n\9error(\"Invalid elements\")\nend\n\n--[[\n\9Gets the child corresponding to a given key, respecting Roact's rules for\n\9children. Specifically:\n\9* If `elements` is nil or a boolean, this will return `nil`, regardless of\n\9\9the key given.\n\9* If `elements` is a single element, this will return `nil`, unless the key\n\9\9is ElementUtils.UseParentKey.\n\9* If `elements` is a table of elements, this will return `elements[key]`.\n]]\nfunction ElementUtils.getElementByKey(elements, hostKey)\n\9if elements == nil or typeof(elements) == \"boolean\" then\n\9\9return nil\n\9end\n\n\9if Type.of(elements) == Type.Element then\n\9\9if hostKey == ElementUtils.UseParentKey then\n\9\9\9return elements\n\9\9end\n\n\9\9return nil\n\9end\n\n\9if typeof(elements) == \"table\" then\n\9\9return elements[hostKey]\n\9end\n\n\9error(\"Invalid elements\")\nend\n\nreturn ElementUtils\n", "bundle-ex.include.node_modules.@rbxts.roact.src.ElementUtils"))(__env)
end)
__lua("GlobalConfig", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.GlobalConfig", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.GlobalConfig\")local script,require=_.script,_.require --[[\n\9Exposes a single instance of a configuration as Roact's GlobalConfig.\n]]\n\nlocal Config = require(script.Parent.Config)\n\nreturn Config.new()\n", "bundle-ex.include.node_modules.@rbxts.roact.src.GlobalConfig"))(__env)
end)
__lua("Logging", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.Logging", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.Logging\")local script,require=_.script,_.require --[[\n\9Centralized place to handle logging. Lets us:\n\9- Unit test log output via `Logging.capture`\n\9- Disable verbose log messages when not debugging Roact\n\n\9This should be broken out into a separate library with the addition of\n\9scoping and logging configuration.\n]]\n\n-- Determines whether log messages will go to stdout/stderr\nlocal outputEnabled = true\n\n-- A set of LogInfo objects that should have messages inserted into them.\n-- This is a set so that nested calls to Logging.capture will behave.\nlocal collectors = {}\n\n-- A set of all stack traces that have called warnOnce.\nlocal onceUsedLocations = {}\n\n--[[\n\9Indent a potentially multi-line string with the given number of tabs, in\n\9addition to any indentation the string already has.\n]]\nlocal function indent(source, indentLevel)\n\9local indentString = (\"\\t\"):rep(indentLevel)\n\n\9return indentString .. source:gsub(\"\\n\", \"\\n\" .. indentString)\nend\n\n--[[\n\9Indents a list of strings and then concatenates them together with newlines\n\9into a single string.\n]]\nlocal function indentLines(lines, indentLevel)\n\9local outputBuffer = {}\n\n\9for _, line in ipairs(lines) do\n\9\9table.insert(outputBuffer, indent(line, indentLevel))\n\9end\n\n\9return table.concat(outputBuffer, \"\\n\")\nend\n\nlocal logInfoMetatable = {}\n\n--[[\n\9Automatic coercion to strings for LogInfo objects to enable debugging them\n\9more easily.\n]]\nfunction logInfoMetatable:__tostring()\n\9local outputBuffer = { \"LogInfo {\" }\n\n\9local errorCount = #self.errors\n\9local warningCount = #self.warnings\n\9local infosCount = #self.infos\n\n\9if errorCount + warningCount + infosCount == 0 then\n\9\9table.insert(outputBuffer, \"\\t(no messages)\")\n\9end\n\n\9if errorCount > 0 then\n\9\9table.insert(outputBuffer, (\"\\tErrors (%d) {\"):format(errorCount))\n\9\9table.insert(outputBuffer, indentLines(self.errors, 2))\n\9\9table.insert(outputBuffer, \"\\t}\")\n\9end\n\n\9if warningCount > 0 then\n\9\9table.insert(outputBuffer, (\"\\tWarnings (%d) {\"):format(warningCount))\n\9\9table.insert(outputBuffer, indentLines(self.warnings, 2))\n\9\9table.insert(outputBuffer, \"\\t}\")\n\9end\n\n\9if infosCount > 0 then\n\9\9table.insert(outputBuffer, (\"\\tInfos (%d) {\"):format(infosCount))\n\9\9table.insert(outputBuffer, indentLines(self.infos, 2))\n\9\9table.insert(outputBuffer, \"\\t}\")\n\9end\n\n\9table.insert(outputBuffer, \"}\")\n\n\9return table.concat(outputBuffer, \"\\n\")\nend\n\nlocal function createLogInfo()\n\9local logInfo = {\n\9\9errors = {},\n\9\9warnings = {},\n\9\9infos = {},\n\9}\n\n\9setmetatable(logInfo, logInfoMetatable)\n\n\9return logInfo\nend\n\nlocal Logging = {}\n\n--[[\n\9Invokes `callback`, capturing all output that happens during its execution.\n\n\9Output will not go to stdout or stderr and will instead be put into a\n\9LogInfo object that is returned. If `callback` throws, the error will be\n\9bubbled up to the caller of `Logging.capture`.\n]]\nfunction Logging.capture(callback)\n\9local collector = createLogInfo()\n\n\9local wasOutputEnabled = outputEnabled\n\9outputEnabled = false\n\9collectors[collector] = true\n\n\9local success, result = pcall(callback)\n\n\9collectors[collector] = nil\n\9outputEnabled = wasOutputEnabled\n\n\9assert(success, result)\n\n\9return collector\nend\n\n--[[\n\9Issues a warning with an automatically attached stack trace.\n]]\nfunction Logging.warn(messageTemplate, ...)\n\9local message = messageTemplate:format(...)\n\n\9for collector in pairs(collectors) do\n\9\9table.insert(collector.warnings, message)\n\9end\n\n\9-- debug.traceback inserts a leading newline, so we trim it here\n\9local trace = debug.traceback(\"\", 2):sub(2)\n\9local fullMessage = (\"%s\\n%s\"):format(message, indent(trace, 1))\n\n\9if outputEnabled then\n\9\9warn(fullMessage)\n\9end\nend\n\n--[[\n\9Issues a warning like `Logging.warn`, but only outputs once per call site.\n\n\9This is useful for marking deprecated functions that might be called a lot;\n\9using `warnOnce` instead of `warn` will reduce output noise while still\n\9correctly marking all call sites.\n]]\nfunction Logging.warnOnce(messageTemplate, ...)\n\9local trace = debug.traceback()\n\n\9if onceUsedLocations[trace] then\n\9\9return\n\9end\n\n\9onceUsedLocations[trace] = true\n\9Logging.warn(messageTemplate, ...)\nend\n\nreturn Logging\n", "bundle-ex.include.node_modules.@rbxts.roact.src.Logging"))(__env)
end)
__lua("None", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.None", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.None\")local script,require=_.script,_.require local Symbol = require(script.Parent.Symbol)\n\n-- Marker used to specify that the value is nothing, because nil cannot be\n-- stored in tables.\nlocal None = Symbol.named(\"None\")\n\nreturn None\n", "bundle-ex.include.node_modules.@rbxts.roact.src.None"))(__env)
end)
__lua("NoopRenderer", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.NoopRenderer", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.NoopRenderer\")local script,require=_.script,_.require --[[\n\9Reference renderer intended for use in tests as well as for documenting the\n\9minimum required interface for a Roact renderer.\n]]\n\nlocal NoopRenderer = {}\n\nfunction NoopRenderer.isHostObject(target)\n\9-- Attempting to use NoopRenderer to target a Roblox instance is almost\n\9-- certainly a mistake.\n\9return target == nil\nend\n\nfunction NoopRenderer.mountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.unmountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.updateHostNode(_reconciler, node, _newElement)\n\9return node\nend\n\nreturn NoopRenderer\n", "bundle-ex.include.node_modules.@rbxts.roact.src.NoopRenderer"))(__env)
end)
__lua("Portal", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.Portal", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.Portal\")local script,require=_.script,_.require local Symbol = require(script.Parent.Symbol)\n\nlocal Portal = Symbol.named(\"Portal\")\n\nreturn Portal\n", "bundle-ex.include.node_modules.@rbxts.roact.src.Portal"))(__env)
end)
__rbx("PropMarkers", "Folder", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers", "bundle-ex.include.node_modules.@rbxts.roact.src")
__lua("Change", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Change", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Change\")local script,require=_.script,_.require --[[\n\9Change is used to generate special prop keys that can be used to connect to\n\9GetPropertyChangedSignal.\n\n\9Generally, Change is indexed by a Roblox property name:\n\n\9\9Roact.createElement(\"TextBox\", {\n\9\9\9[Roact.Change.Text] = function(rbx)\n\9\9\9\9print(\"The TextBox\", rbx, \"changed text to\", rbx.Text)\n\9\9\9end,\n\9\9})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Change = {}\n\nlocal changeMetatable = {\n\9__tostring = function(self)\n\9\9return (\"RoactHostChangeEvent(%s)\"):format(self.name)\n\9end,\n}\n\nsetmetatable(Change, {\n\9__index = function(_self, propertyName)\n\9\9local changeListener = {\n\9\9\9[Type] = Type.HostChangeEvent,\n\9\9\9name = propertyName,\n\9\9}\n\n\9\9setmetatable(changeListener, changeMetatable)\n\9\9Change[propertyName] = changeListener\n\n\9\9return changeListener\n\9end,\n})\n\nreturn Change\n", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Change"))(__env)
end)
__lua("Children", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Children", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Children\")local script,require=_.script,_.require local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Children = Symbol.named(\"Children\")\n\nreturn Children\n", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Children"))(__env)
end)
__lua("Event", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Event", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Event\")local script,require=_.script,_.require --[[\n\9Index into `Event` to get a prop key for attaching to an event on a Roblox\n\9Instance.\n\n\9Example:\n\n\9\9Roact.createElement(\"TextButton\", {\n\9\9\9Text = \"Hello, world!\",\n\n\9\9\9[Roact.Event.MouseButton1Click] = function(rbx)\n\9\9\9\9print(\"Clicked\", rbx)\n\9\9\9end\n\9\9})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Event = {}\n\nlocal eventMetatable = {\n\9__tostring = function(self)\n\9\9return (\"RoactHostEvent(%s)\"):format(self.name)\n\9end,\n}\n\nsetmetatable(Event, {\n\9__index = function(_self, eventName)\n\9\9local event = {\n\9\9\9[Type] = Type.HostEvent,\n\9\9\9name = eventName,\n\9\9}\n\n\9\9setmetatable(event, eventMetatable)\n\n\9\9Event[eventName] = event\n\n\9\9return event\n\9end,\n})\n\nreturn Event\n", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Event"))(__env)
end)
__lua("Ref", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Ref", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Ref\")local script,require=_.script,_.require local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Ref = Symbol.named(\"Ref\")\n\nreturn Ref\n", "bundle-ex.include.node_modules.@rbxts.roact.src.PropMarkers.Ref"))(__env)
end)
__lua("PureComponent", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.PureComponent", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.PureComponent\")local script,require=_.script,_.require --[[\n\9A version of Component with a `shouldUpdate` method that forces the\n\9resulting component to be pure.\n]]\n\nlocal Component = require(script.Parent.Component)\n\nlocal PureComponent = Component:extend(\"PureComponent\")\n\n-- When extend()ing a component, you don't get an extend method.\n-- This is to promote composition over inheritance.\n-- PureComponent is an exception to this rule.\nPureComponent.extend = Component.extend\n\nfunction PureComponent:shouldUpdate(newProps, newState)\n\9-- In a vast majority of cases, if state updated, something has updated.\n\9-- We don't bother checking in this case.\n\9if newState ~= self.state then\n\9\9return true\n\9end\n\n\9if newProps == self.props then\n\9\9return false\n\9end\n\n\9for key, value in pairs(newProps) do\n\9\9if self.props[key] ~= value then\n\9\9\9return true\n\9\9end\n\9end\n\n\9for key, value in pairs(self.props) do\n\9\9if newProps[key] ~= value then\n\9\9\9return true\n\9\9end\n\9end\n\n\9return false\nend\n\nreturn PureComponent\n", "bundle-ex.include.node_modules.@rbxts.roact.src.PureComponent"))(__env)
end)
__lua("RobloxRenderer", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.RobloxRenderer", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.RobloxRenderer\")local script,require=_.script,_.require --[[\n\9Renderer that deals in terms of Roblox Instances. This is the most\n\9well-supported renderer after NoopRenderer and is currently the only\n\9renderer that does anything.\n]]\n\nlocal Binding = require(script.Parent.Binding)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal SingleEventManager = require(script.Parent.SingleEventManager)\nlocal getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\nlocal Type = require(script.Parent.Type)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal applyPropsError = [[\nError applying props:\n\9%s\nIn element:\n%s\n]]\n\nlocal updatePropsError = [[\nError updating props:\n\9%s\nIn element:\n%s\n]]\n\nlocal function identity(...)\n\9return ...\nend\n\nlocal function applyRef(ref, newHostObject)\n\9if ref == nil then\n\9\9return\n\9end\n\n\9if typeof(ref) == \"function\" then\n\9\9ref(newHostObject)\n\9elseif Type.of(ref) == Type.Binding then\n\9\9Binding.update(ref, newHostObject)\n\9else\n\9\9-- TODO (#197): Better error message\n\9\9error((\"Invalid ref: Expected type Binding but got %s\"):format(typeof(ref)))\n\9end\nend\n\nlocal function setRobloxInstanceProperty(hostObject, key, newValue)\n\9if newValue == nil then\n\9\9local hostClass = hostObject.ClassName\n\9\9local _, defaultValue = getDefaultInstanceProperty(hostClass, key)\n\9\9newValue = defaultValue\n\9end\n\n\9-- Assign the new value to the object\n\9hostObject[key] = newValue\n\n\9return\nend\n\nlocal function removeBinding(virtualNode, key)\n\9local disconnect = virtualNode.bindings[key]\n\9disconnect()\n\9virtualNode.bindings[key] = nil\nend\n\nlocal function attachBinding(virtualNode, key, newBinding)\n\9local function updateBoundProperty(newValue)\n\9\9local success, errorMessage = xpcall(function()\n\9\9\9setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\9\9end, identity)\n\n\9\9if not success then\n\9\9\9local source = virtualNode.currentElement.source\n\n\9\9\9if source == nil then\n\9\9\9\9source = \"<enable element tracebacks>\"\n\9\9\9end\n\n\9\9\9local fullMessage = updatePropsError:format(errorMessage, source)\n\9\9\9error(fullMessage, 0)\n\9\9end\n\9end\n\n\9if virtualNode.bindings == nil then\n\9\9virtualNode.bindings = {}\n\9end\n\n\9virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)\n\n\9updateBoundProperty(newBinding:getValue())\nend\n\nlocal function detachAllBindings(virtualNode)\n\9if virtualNode.bindings ~= nil then\n\9\9for _, disconnect in pairs(virtualNode.bindings) do\n\9\9\9disconnect()\n\9\9end\n\9\9virtualNode.bindings = nil\n\9end\nend\n\nlocal function applyProp(virtualNode, key, newValue, oldValue)\n\9if newValue == oldValue then\n\9\9return\n\9end\n\n\9if key == Ref or key == Children then\n\9\9-- Refs and children are handled in a separate pass\n\9\9return\n\9end\n\n\9local internalKeyType = Type.of(key)\n\n\9if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then\n\9\9if virtualNode.eventManager == nil then\n\9\9\9virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)\n\9\9end\n\n\9\9local eventName = key.name\n\n\9\9if internalKeyType == Type.HostChangeEvent then\n\9\9\9virtualNode.eventManager:connectPropertyChange(eventName, newValue)\n\9\9else\n\9\9\9virtualNode.eventManager:connectEvent(eventName, newValue)\n\9\9end\n\n\9\9return\n\9end\n\n\9local newIsBinding = Type.of(newValue) == Type.Binding\n\9local oldIsBinding = Type.of(oldValue) == Type.Binding\n\n\9if oldIsBinding then\n\9\9removeBinding(virtualNode, key)\n\9end\n\n\9if newIsBinding then\n\9\9attachBinding(virtualNode, key, newValue)\n\9else\n\9\9setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\9end\nend\n\nlocal function applyProps(virtualNode, props)\n\9for propKey, value in pairs(props) do\n\9\9applyProp(virtualNode, propKey, value, nil)\n\9end\nend\n\nlocal function updateProps(virtualNode, oldProps, newProps)\n\9-- Apply props that were added or updated\n\9for propKey, newValue in pairs(newProps) do\n\9\9local oldValue = oldProps[propKey]\n\n\9\9applyProp(virtualNode, propKey, newValue, oldValue)\n\9end\n\n\9-- Clean up props that were removed\n\9for propKey, oldValue in pairs(oldProps) do\n\9\9local newValue = newProps[propKey]\n\n\9\9if newValue == nil then\n\9\9\9applyProp(virtualNode, propKey, nil, oldValue)\n\9\9end\n\9end\nend\n\nlocal RobloxRenderer = {}\n\nfunction RobloxRenderer.isHostObject(target)\n\9return typeof(target) == \"Instance\"\nend\n\nfunction RobloxRenderer.mountHostNode(reconciler, virtualNode)\n\9local element = virtualNode.currentElement\n\9local hostParent = virtualNode.hostParent\n\9local hostKey = virtualNode.hostKey\n\n\9if config.internalTypeChecks then\n\9\9internalAssert(ElementKind.of(element) == ElementKind.Host, \"Element at given node is not a host Element\")\n\9end\n\9if config.typeChecks then\n\9\9assert(element.props.Name == nil, \"Name can not be specified as a prop to a host component in Roact.\")\n\9\9assert(element.props.Parent == nil, \"Parent can not be specified as a prop to a host component in Roact.\")\n\9end\n\n\9local instance = Instance.new(element.component)\n\9virtualNode.hostObject = instance\n\n\9local success, errorMessage = xpcall(function()\n\9\9applyProps(virtualNode, element.props)\n\9end, identity)\n\n\9if not success then\n\9\9local source = element.source\n\n\9\9if source == nil then\n\9\9\9source = \"<enable element tracebacks>\"\n\9\9end\n\n\9\9local fullMessage = applyPropsError:format(errorMessage, source)\n\9\9error(fullMessage, 0)\n\9end\n\n\9instance.Name = tostring(hostKey)\n\n\9local children = element.props[Children]\n\n\9if children ~= nil then\n\9\9reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\9end\n\n\9instance.Parent = hostParent\n\9virtualNode.hostObject = instance\n\n\9applyRef(element.props[Ref], instance)\n\n\9if virtualNode.eventManager ~= nil then\n\9\9virtualNode.eventManager:resume()\n\9end\nend\n\nfunction RobloxRenderer.unmountHostNode(reconciler, virtualNode)\n\9local element = virtualNode.currentElement\n\n\9applyRef(element.props[Ref], nil)\n\n\9for _, childNode in pairs(virtualNode.children) do\n\9\9reconciler.unmountVirtualNode(childNode)\n\9end\n\n\9detachAllBindings(virtualNode)\n\n\9virtualNode.hostObject:Destroy()\nend\n\nfunction RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)\n\9local oldProps = virtualNode.currentElement.props\n\9local newProps = newElement.props\n\n\9if virtualNode.eventManager ~= nil then\n\9\9virtualNode.eventManager:suspend()\n\9end\n\n\9-- If refs changed, detach the old ref and attach the new one\n\9if oldProps[Ref] ~= newProps[Ref] then\n\9\9applyRef(oldProps[Ref], nil)\n\9\9applyRef(newProps[Ref], virtualNode.hostObject)\n\9end\n\n\9local success, errorMessage = xpcall(function()\n\9\9updateProps(virtualNode, oldProps, newProps)\n\9end, identity)\n\n\9if not success then\n\9\9local source = newElement.source\n\n\9\9if source == nil then\n\9\9\9source = \"<enable element tracebacks>\"\n\9\9end\n\n\9\9local fullMessage = updatePropsError:format(errorMessage, source)\n\9\9error(fullMessage, 0)\n\9end\n\n\9local children = newElement.props[Children]\n\9if children ~= nil or oldProps[Children] ~= nil then\n\9\9reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\9end\n\n\9if virtualNode.eventManager ~= nil then\n\9\9virtualNode.eventManager:resume()\n\9end\n\n\9return virtualNode\nend\n\nreturn RobloxRenderer\n", "bundle-ex.include.node_modules.@rbxts.roact.src.RobloxRenderer"))(__env)
end)
__lua("SingleEventManager", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.SingleEventManager", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.SingleEventManager\")local script,require=_.script,_.require --[[\n\9A manager for a single host virtual node's connected events.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal CHANGE_PREFIX = \"Change.\"\n\nlocal EventStatus = {\n\9-- No events are processed at all; they're silently discarded\n\9Disabled = \"Disabled\",\n\n\9-- Events are stored in a queue; listeners are invoked when the manager is resumed\n\9Suspended = \"Suspended\",\n\n\9-- Event listeners are invoked as the events fire\n\9Enabled = \"Enabled\",\n}\n\nlocal SingleEventManager = {}\nSingleEventManager.__index = SingleEventManager\n\nfunction SingleEventManager.new(instance)\n\9local self = setmetatable({\n\9\9-- The queue of suspended events\n\9\9_suspendedEventQueue = {},\n\n\9\9-- All the event connections being managed\n\9\9-- Events are indexed by a string key\n\9\9_connections = {},\n\n\9\9-- All the listeners being managed\n\9\9-- These are stored distinctly from the connections\n\9\9-- Connections can have their listeners replaced at runtime\n\9\9_listeners = {},\n\n\9\9-- The suspension status of the manager\n\9\9-- Managers start disabled and are \"resumed\" after the initial render\n\9\9_status = EventStatus.Disabled,\n\n\9\9-- If true, the manager is processing queued events right now.\n\9\9_isResuming = false,\n\n\9\9-- The Roblox instance the manager is managing\n\9\9_instance = instance,\n\9}, SingleEventManager)\n\n\9return self\nend\n\nfunction SingleEventManager:connectEvent(key, listener)\n\9self:_connect(key, self._instance[key], listener)\nend\n\nfunction SingleEventManager:connectPropertyChange(key, listener)\n\9local success, event = pcall(function()\n\9\9return self._instance:GetPropertyChangedSignal(key)\n\9end)\n\n\9if not success then\n\9\9error((\"Cannot get changed signal on property %q: %s\"):format(tostring(key), event), 0)\n\9end\n\n\9self:_connect(CHANGE_PREFIX .. key, event, listener)\nend\n\nfunction SingleEventManager:_connect(eventKey, event, listener)\n\9-- If the listener doesn't exist we can just disconnect the existing connection\n\9if listener == nil then\n\9\9if self._connections[eventKey] ~= nil then\n\9\9\9self._connections[eventKey]:Disconnect()\n\9\9\9self._connections[eventKey] = nil\n\9\9end\n\n\9\9self._listeners[eventKey] = nil\n\9else\n\9\9if self._connections[eventKey] == nil then\n\9\9\9self._connections[eventKey] = event:Connect(function(...)\n\9\9\9\9if self._status == EventStatus.Enabled then\n\9\9\9\9\9self._listeners[eventKey](self._instance, ...)\n\9\9\9\9elseif self._status == EventStatus.Suspended then\n\9\9\9\9\9-- Store this event invocation to be fired when resume is\n\9\9\9\9\9-- called.\n\n\9\9\9\9\9local argumentCount = select(\"#\", ...)\n\9\9\9\9\9table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })\n\9\9\9\9end\n\9\9\9end)\n\9\9end\n\n\9\9self._listeners[eventKey] = listener\n\9end\nend\n\nfunction SingleEventManager:suspend()\n\9self._status = EventStatus.Suspended\nend\n\nfunction SingleEventManager:resume()\n\9-- If we're already resuming events for this instance, trying to resume\n\9-- again would cause a disaster.\n\9if self._isResuming then\n\9\9return\n\9end\n\n\9self._isResuming = true\n\n\9local index = 1\n\n\9-- More events might be added to the queue when evaluating events, so we\n\9-- need to be careful in order to preserve correct evaluation order.\n\9while index <= #self._suspendedEventQueue do\n\9\9local eventInvocation = self._suspendedEventQueue[index]\n\9\9local listener = self._listeners[eventInvocation[1]]\n\9\9local argumentCount = eventInvocation[2]\n\n\9\9-- The event might have been disconnected since suspension started; in\n\9\9-- this case, we drop the event.\n\9\9if listener ~= nil then\n\9\9\9-- Wrap the listener in a coroutine to catch errors and handle\n\9\9\9-- yielding correctly.\n\9\9\9local listenerCo = coroutine.create(listener)\n\9\9\9local success, result = coroutine.resume(\n\9\9\9\9listenerCo,\n\9\9\9\9self._instance,\n\9\9\9\9unpack(eventInvocation, 3, 2 + argumentCount)\n\9\9\9)\n\n\9\9\9-- If the listener threw an error, we log it as a warning, since\n\9\9\9-- there's no way to write error text in Roblox Lua without killing\n\9\9\9-- our thread!\n\9\9\9if not success then\n\9\9\9\9Logging.warn(\"%s\", result)\n\9\9\9end\n\9\9end\n\n\9\9index = index + 1\n\9end\n\n\9self._isResuming = false\n\9self._status = EventStatus.Enabled\n\9self._suspendedEventQueue = {}\nend\n\nreturn SingleEventManager\n", "bundle-ex.include.node_modules.@rbxts.roact.src.SingleEventManager"))(__env)
end)
__lua("Symbol", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.Symbol", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.Symbol\")local script,require=_.script,_.require --!strict\n--[[\n\9A 'Symbol' is an opaque marker type.\n\n\9Symbols have the type 'userdata', but when printed to the console, the name\n\9of the symbol is shown.\n]]\n\nlocal Symbol = {}\n\n--[[\n\9Creates a Symbol with the given name.\n\n\9When printed or coerced to a string, the symbol will turn into the string\n\9given as its name.\n]]\nfunction Symbol.named(name)\n\9assert(type(name) == \"string\", \"Symbols must be created using a string name!\")\n\n\9local self = newproxy(true)\n\n\9local wrappedName = (\"Symbol(%s)\"):format(name)\n\n\9getmetatable(self).__tostring = function()\n\9\9return wrappedName\n\9end\n\n\9return self\nend\n\nreturn Symbol\n", "bundle-ex.include.node_modules.@rbxts.roact.src.Symbol"))(__env)
end)
__lua("Type", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.Type", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.Type\")local script,require=_.script,_.require --[[\n\9Contains markers for annotating objects with types.\n\n\9To set the type of an object, use `Type` as a key and the actual marker as\n\9the value:\n\n\9\9local foo = {\n\9\9\9[Type] = Type.Foo,\n\9\9}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal Type = newproxy(true)\n\nlocal TypeInternal = {}\n\nlocal function addType(name)\n\9TypeInternal[name] = Symbol.named(\"Roact\" .. name)\nend\n\naddType(\"Binding\")\naddType(\"Element\")\naddType(\"HostChangeEvent\")\naddType(\"HostEvent\")\naddType(\"StatefulComponentClass\")\naddType(\"StatefulComponentInstance\")\naddType(\"VirtualNode\")\naddType(\"VirtualTree\")\n\nfunction TypeInternal.of(value)\n\9if typeof(value) ~= \"table\" then\n\9\9return nil\n\9end\n\n\9return value[Type]\nend\n\ngetmetatable(Type).__index = TypeInternal\n\ngetmetatable(Type).__tostring = function()\n\9return \"RoactType\"\nend\n\nstrict(TypeInternal, \"Type\")\n\nreturn Type\n", "bundle-ex.include.node_modules.@rbxts.roact.src.Type"))(__env)
end)
__lua("assertDeepEqual", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.assertDeepEqual", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.assertDeepEqual\")local script,require=_.script,_.require --!strict\n--[[\n\9A utility used to assert that two objects are value-equal recursively. It\n\9outputs fairly nicely formatted messages to help diagnose why two objects\n\9would be different.\n\n\9This should only be used in tests.\n]]\n\nlocal function deepEqual(a: any, b: any): (boolean, string?)\n\9if typeof(a) ~= typeof(b) then\n\9\9local message = (\"{1} is of type %s, but {2} is of type %s\"):format(typeof(a), typeof(b))\n\9\9return false, message\n\9end\n\n\9if typeof(a) == \"table\" then\n\9\9local visitedKeys = {}\n\n\9\9for key, value in pairs(a) do\n\9\9\9visitedKeys[key] = true\n\n\9\9\9local success, innerMessage = deepEqual(value, b[key])\n\9\9\9if not success and innerMessage then\n\9\9\9\9local message = innerMessage\n\9\9\9\9\9:gsub(\"{1}\", (\"{1}[%s]\"):format(tostring(key)))\n\9\9\9\9\9:gsub(\"{2}\", (\"{2}[%s]\"):format(tostring(key)))\n\n\9\9\9\9return false, message\n\9\9\9end\n\9\9end\n\n\9\9for key, value in pairs(b) do\n\9\9\9if not visitedKeys[key] then\n\9\9\9\9local success, innerMessage = deepEqual(value, a[key])\n\n\9\9\9\9if not success and innerMessage then\n\9\9\9\9\9local message = innerMessage\n\9\9\9\9\9\9:gsub(\"{1}\", (\"{1}[%s]\"):format(tostring(key)))\n\9\9\9\9\9\9:gsub(\"{2}\", (\"{2}[%s]\"):format(tostring(key)))\n\n\9\9\9\9\9return false, message\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9return true, nil\n\9end\n\n\9if a == b then\n\9\9return true, nil\n\9end\n\n\9local message = \"{1} ~= {2}\"\n\9return false, message\nend\n\nlocal function assertDeepEqual(a, b)\n\9local success, innerMessageTemplate = deepEqual(a, b)\n\n\9if not success and innerMessageTemplate then\n\9\9local innerMessage = innerMessageTemplate:gsub(\"{1}\", \"first\"):gsub(\"{2}\", \"second\")\n\n\9\9local message = (\"Values were not deep-equal.\\n%s\"):format(innerMessage)\n\n\9\9error(message, 2)\n\9end\nend\n\nreturn assertDeepEqual\n", "bundle-ex.include.node_modules.@rbxts.roact.src.assertDeepEqual"))(__env)
end)
__lua("assign", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.assign", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.assign\")local script,require=_.script,_.require local None = require(script.Parent.None)\n\n--[[\n\9Merges values from zero or more tables onto a target table. If a value is\n\9set to None, it will instead be removed from the table.\n\n\9This function is identical in functionality to JavaScript's Object.assign.\n]]\nlocal function assign(target, ...)\n\9for index = 1, select(\"#\", ...) do\n\9\9local source = select(index, ...)\n\n\9\9if source ~= nil then\n\9\9\9for key, value in pairs(source) do\n\9\9\9\9if value == None then\n\9\9\9\9\9target[key] = nil\n\9\9\9\9else\n\9\9\9\9\9target[key] = value\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\n\n\9return target\nend\n\nreturn assign\n", "bundle-ex.include.node_modules.@rbxts.roact.src.assign"))(__env)
end)
__lua("createContext", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createContext", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createContext\")local script,require=_.script,_.require local Symbol = require(script.Parent.Symbol)\nlocal createFragment = require(script.Parent.createFragment)\nlocal createSignal = require(script.Parent.createSignal)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Component = require(script.Parent.Component)\n\n--[[\n\9Construct the value that is assigned to Roact's context storage.\n]]\nlocal function createContextEntry(currentValue)\n\9return {\n\9\9value = currentValue,\n\9\9onUpdate = createSignal(),\n\9}\nend\n\nlocal function createProvider(context)\n\9local Provider = Component:extend(\"Provider\")\n\n\9function Provider:init(props)\n\9\9self.contextEntry = createContextEntry(props.value)\n\9\9self:__addContext(context.key, self.contextEntry)\n\9end\n\n\9function Provider:willUpdate(nextProps)\n\9\9-- If the provided value changed, immediately update the context entry.\n\9\9--\n\9\9-- During this update, any components that are reachable will receive\n\9\9-- this updated value at the same time as any props and state updates\n\9\9-- that are being applied.\n\9\9if nextProps.value ~= self.props.value then\n\9\9\9self.contextEntry.value = nextProps.value\n\9\9end\n\9end\n\n\9function Provider:didUpdate(prevProps)\n\9\9-- If the provided value changed, after we've updated every reachable\n\9\9-- component, fire a signal to update the rest.\n\9\9--\n\9\9-- This signal will notify all context consumers. It's expected that\n\9\9-- they will compare the last context value they updated with and only\n\9\9-- trigger an update on themselves if this value is different.\n\9\9--\n\9\9-- This codepath will generally only update consumer components that has\n\9\9-- a component implementing shouldUpdate between them and the provider.\n\9\9if prevProps.value ~= self.props.value then\n\9\9\9self.contextEntry.onUpdate:fire(self.props.value)\n\9\9end\n\9end\n\n\9function Provider:render()\n\9\9return createFragment(self.props[Children])\n\9end\n\n\9return Provider\nend\n\nlocal function createConsumer(context)\n\9local Consumer = Component:extend(\"Consumer\")\n\n\9function Consumer.validateProps(props)\n\9\9if type(props.render) ~= \"function\" then\n\9\9\9return false, \"Consumer expects a `render` function\"\n\9\9else\n\9\9\9return true\n\9\9end\n\9end\n\n\9function Consumer:init(_props)\n\9\9-- This value may be nil, which indicates that our consumer is not a\n\9\9-- descendant of a provider for this context item.\n\9\9self.contextEntry = self:__getContext(context.key)\n\9end\n\n\9function Consumer:render()\n\9\9-- Render using the latest available for this context item.\n\9\9--\n\9\9-- We don't store this value in state in order to have more fine-grained\n\9\9-- control over our update behavior.\n\9\9local value\n\9\9if self.contextEntry ~= nil then\n\9\9\9value = self.contextEntry.value\n\9\9else\n\9\9\9value = context.defaultValue\n\9\9end\n\n\9\9return self.props.render(value)\n\9end\n\n\9function Consumer:didUpdate()\n\9\9-- Store the value that we most recently updated with.\n\9\9--\n\9\9-- This value is compared in the contextEntry onUpdate hook below.\n\9\9if self.contextEntry ~= nil then\n\9\9\9self.lastValue = self.contextEntry.value\n\9\9end\n\9end\n\n\9function Consumer:didMount()\n\9\9if self.contextEntry ~= nil then\n\9\9\9-- When onUpdate is fired, a new value has been made available in\n\9\9\9-- this context entry, but we may have already updated in the same\n\9\9\9-- update cycle.\n\9\9\9--\n\9\9\9-- To avoid sending a redundant update, we compare the new value\n\9\9\9-- with the last value that we updated with (set in didUpdate) and\n\9\9\9-- only update if they differ. This may happen when an update from a\n\9\9\9-- provider was blocked by an intermediate component that returned\n\9\9\9-- false from shouldUpdate.\n\9\9\9self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)\n\9\9\9\9if newValue ~= self.lastValue then\n\9\9\9\9\9-- Trigger a dummy state update.\n\9\9\9\9\9self:setState({})\n\9\9\9\9end\n\9\9\9end)\n\9\9end\n\9end\n\n\9function Consumer:willUnmount()\n\9\9if self.disconnect ~= nil then\n\9\9\9self.disconnect()\n\9\9\9self.disconnect = nil\n\9\9end\n\9end\n\n\9return Consumer\nend\n\nlocal Context = {}\nContext.__index = Context\n\nfunction Context.new(defaultValue)\n\9return setmetatable({\n\9\9defaultValue = defaultValue,\n\9\9key = Symbol.named(\"ContextKey\"),\n\9}, Context)\nend\n\nfunction Context:__tostring()\n\9return \"RoactContext\"\nend\n\nlocal function createContext(defaultValue)\n\9local context = Context.new(defaultValue)\n\n\9return {\n\9\9Provider = createProvider(context),\n\9\9Consumer = createConsumer(context),\n\9}\nend\n\nreturn createContext\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createContext"))(__env)
end)
__lua("createElement", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createElement", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createElement\")local script,require=_.script,_.require local Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal Logging = require(script.Parent.Logging)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal multipleChildrenMessage = [[\nThe prop `Roact.Children` was defined but was overridden by the third parameter to createElement!\nThis can happen when a component passes props through to a child element but also uses the `children` argument:\n\n\9Roact.createElement(\"Frame\", passedProps, {\n\9\9child = ...\n\9})\n\nInstead, consider using a utility function to merge tables of children together:\n\n\9local children = mergeTables(passedProps[Roact.Children], {\n\9\9child = ...\n\9})\n\n\9local fullProps = mergeTables(passedProps, {\n\9\9[Roact.Children] = children\n\9})\n\n\9Roact.createElement(\"Frame\", fullProps)]]\n\n--[[\n\9Creates a new element representing the given component.\n\n\9Elements are lightweight representations of what a component instance should\n\9look like.\n\n\9Children is a shorthand for specifying `Roact.Children` as a key inside\n\9props. If specified, the passed `props` table is mutated!\n]]\nlocal function createElement(component, props, children)\n\9if config.typeChecks then\n\9\9assert(component ~= nil, \"`component` is required\")\n\9\9assert(typeof(props) == \"table\" or props == nil, \"`props` must be a table or nil\")\n\9\9assert(typeof(children) == \"table\" or children == nil, \"`children` must be a table or nil\")\n\9end\n\n\9if props == nil then\n\9\9props = {}\n\9end\n\n\9if children ~= nil then\n\9\9if props[Children] ~= nil then\n\9\9\9Logging.warnOnce(multipleChildrenMessage)\n\9\9end\n\n\9\9props[Children] = children\n\9end\n\n\9local elementKind = ElementKind.fromComponent(component)\n\n\9local element = {\n\9\9[Type] = Type.Element,\n\9\9[ElementKind] = elementKind,\n\9\9component = component,\n\9\9props = props,\n\9}\n\n\9if config.elementTracing then\n\9\9-- We trim out the leading newline since there's no way to specify the\n\9\9-- trace level without also specifying a message.\n\9\9element.source = debug.traceback(\"\", 2):sub(2)\n\9end\n\n\9return element\nend\n\nreturn createElement\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createElement"))(__env)
end)
__lua("createFragment", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createFragment", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createFragment\")local script,require=_.script,_.require local ElementKind = require(script.Parent.ElementKind)\nlocal Type = require(script.Parent.Type)\n\nlocal function createFragment(elements)\n\9return {\n\9\9[Type] = Type.Element,\n\9\9[ElementKind] = ElementKind.Fragment,\n\9\9elements = elements,\n\9}\nend\n\nreturn createFragment\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createFragment"))(__env)
end)
__lua("createReconciler", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createReconciler", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createReconciler\")local script,require=_.script,_.require --!nonstrict\nlocal Type = require(script.Parent.Type)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal ElementUtils = require(script.Parent.ElementUtils)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Symbol = require(script.Parent.Symbol)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\n--[[\n\9The reconciler is the mechanism in Roact that constructs the virtual tree\n\9that later gets turned into concrete objects by the renderer.\n\n\9Roact's reconciler is constructed with the renderer as an argument, which\n\9enables switching to different renderers for different platforms or\n\9scenarios.\n\n\9When testing the reconciler itself, it's common to use `NoopRenderer` with\n\9spies replacing some methods. The default (and only) reconciler interface\n\9exposed by Roact right now uses `RobloxRenderer`.\n]]\nlocal function createReconciler(renderer)\n\9local reconciler\n\9local mountVirtualNode\n\9local updateVirtualNode\n\9local unmountVirtualNode\n\n\9--[[\n\9\9Unmount the given virtualNode, replacing it with a new node described by\n\9\9the given element.\n\n\9\9Preserves host properties, depth, and legacyContext from parent.\n\9]]\n\9local function replaceVirtualNode(virtualNode, newElement)\n\9\9local hostParent = virtualNode.hostParent\n\9\9local hostKey = virtualNode.hostKey\n\9\9local depth = virtualNode.depth\n\9\9local parent = virtualNode.parent\n\n\9\9-- If the node that is being replaced has modified context, we need to\n\9\9-- use the original *unmodified* context for the new node\n\9\9-- The `originalContext` field will be nil if the context was unchanged\n\9\9local context = virtualNode.originalContext or virtualNode.context\n\9\9local parentLegacyContext = virtualNode.parentLegacyContext\n\n\9\9-- If updating this node has caused a component higher up the tree to re-render\n\9\9-- and updateChildren to be re-entered then this node could already have been\n\9\9-- unmounted in the previous updateChildren pass.\n\9\9if not virtualNode.wasUnmounted then\n\9\9\9unmountVirtualNode(virtualNode)\n\9\9end\n\9\9local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)\n\n\9\9-- mountVirtualNode can return nil if the element is a boolean\n\9\9if newNode ~= nil then\n\9\9\9newNode.depth = depth\n\9\9\9newNode.parent = parent\n\9\9end\n\n\9\9return newNode\n\9end\n\n\9--[[\n\9\9Utility to update the children of a virtual node based on zero or more\n\9\9updated children given as elements.\n\9]]\n\9local function updateChildren(virtualNode, hostParent, newChildElements)\n\9\9if config.internalTypeChecks then\n\9\9\9internalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\9\9end\n\n\9\9virtualNode.updateChildrenCount = virtualNode.updateChildrenCount + 1\n\n\9\9local currentUpdateChildrenCount = virtualNode.updateChildrenCount\n\n\9\9local removeKeys = {}\n\n\9\9-- Changed or removed children\n\9\9for childKey, childNode in pairs(virtualNode.children) do\n\9\9\9local newElement = ElementUtils.getElementByKey(newChildElements, childKey)\n\9\9\9local newNode = updateVirtualNode(childNode, newElement)\n\n\9\9\9-- If updating this node has caused a component higher up the tree to re-render\n\9\9\9-- and updateChildren to be re-entered for this virtualNode then\n\9\9\9-- this result is invalid and needs to be disgarded.\n\9\9\9if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\9\9\9\9if newNode and newNode ~= virtualNode.children[childKey] then\n\9\9\9\9\9unmountVirtualNode(newNode)\n\9\9\9\9end\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9if newNode ~= nil then\n\9\9\9\9virtualNode.children[childKey] = newNode\n\9\9\9else\n\9\9\9\9removeKeys[childKey] = true\n\9\9\9end\n\9\9end\n\n\9\9for childKey in pairs(removeKeys) do\n\9\9\9virtualNode.children[childKey] = nil\n\9\9end\n\n\9\9-- Added children\n\9\9for childKey, newElement in ElementUtils.iterateElements(newChildElements) do\n\9\9\9local concreteKey = childKey\n\9\9\9if childKey == ElementUtils.UseParentKey then\n\9\9\9\9concreteKey = virtualNode.hostKey\n\9\9\9end\n\n\9\9\9if virtualNode.children[childKey] == nil then\n\9\9\9\9local childNode = mountVirtualNode(\n\9\9\9\9\9newElement,\n\9\9\9\9\9hostParent,\n\9\9\9\9\9concreteKey,\n\9\9\9\9\9virtualNode.context,\n\9\9\9\9\9virtualNode.legacyContext\n\9\9\9\9)\n\n\9\9\9\9-- If updating this node has caused a component higher up the tree to re-render\n\9\9\9\9-- and updateChildren to be re-entered for this virtualNode then\n\9\9\9\9-- this result is invalid and needs to be discarded.\n\9\9\9\9if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\9\9\9\9\9if childNode then\n\9\9\9\9\9\9unmountVirtualNode(childNode)\n\9\9\9\9\9end\n\9\9\9\9\9return\n\9\9\9\9end\n\n\9\9\9\9-- mountVirtualNode can return nil if the element is a boolean\n\9\9\9\9if childNode ~= nil then\n\9\9\9\9\9childNode.depth = virtualNode.depth + 1\n\9\9\9\9\9childNode.parent = virtualNode\n\9\9\9\9\9virtualNode.children[childKey] = childNode\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\n\n\9local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)\n\9\9updateChildren(virtualNode, hostParent, newChildElements)\n\9end\n\n\9local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\9\9if Type.of(renderResult) == Type.Element or renderResult == nil or typeof(renderResult) == \"boolean\" then\n\9\9\9updateChildren(virtualNode, hostParent, renderResult)\n\9\9else\n\9\9\9error(\n\9\9\9\9(\"%s\\n%s\"):format(\n\9\9\9\9\9\"Component returned invalid children:\",\n\9\9\9\9\9virtualNode.currentElement.source or \"<enable element tracebacks>\"\n\9\9\9\9),\n\9\9\9\0090\n\9\9\9)\n\9\9end\n\9end\n\n\9--[[\n\9\9Unmounts the given virtual node and releases any held resources.\n\9]]\n\9function unmountVirtualNode(virtualNode)\n\9\9if config.internalTypeChecks then\n\9\9\9internalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\9\9end\n\n\9\9virtualNode.wasUnmounted = true\n\n\9\9local kind = ElementKind.of(virtualNode.currentElement)\n\n\9\9-- selene: allow(if_same_then_else)\n\9\9if kind == ElementKind.Host then\n\9\9\9renderer.unmountHostNode(reconciler, virtualNode)\n\9\9elseif kind == ElementKind.Function then\n\9\9\9for _, childNode in pairs(virtualNode.children) do\n\9\9\9\9unmountVirtualNode(childNode)\n\9\9\9end\n\9\9elseif kind == ElementKind.Stateful then\n\9\9\9virtualNode.instance:__unmount()\n\9\9elseif kind == ElementKind.Portal then\n\9\9\9for _, childNode in pairs(virtualNode.children) do\n\9\9\9\9unmountVirtualNode(childNode)\n\9\9\9end\n\9\9elseif kind == ElementKind.Fragment then\n\9\9\9for _, childNode in pairs(virtualNode.children) do\n\9\9\9\9unmountVirtualNode(childNode)\n\9\9\9end\n\9\9else\n\9\9\9error((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\9\9end\n\9end\n\n\9local function updateFunctionVirtualNode(virtualNode, newElement)\n\9\9local children = newElement.component(newElement.props)\n\n\9\9updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\n\9\9return virtualNode\n\9end\n\n\9local function updatePortalVirtualNode(virtualNode, newElement)\n\9\9local oldElement = virtualNode.currentElement\n\9\9local oldTargetHostParent = oldElement.props.target\n\n\9\9local targetHostParent = newElement.props.target\n\n\9\9assert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\9\9if targetHostParent ~= oldTargetHostParent then\n\9\9\9return replaceVirtualNode(virtualNode, newElement)\n\9\9end\n\n\9\9local children = newElement.props[Children]\n\n\9\9updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\n\9\9return virtualNode\n\9end\n\n\9local function updateFragmentVirtualNode(virtualNode, newElement)\n\9\9updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)\n\n\9\9return virtualNode\n\9end\n\n\9--[[\n\9\9Update the given virtual node using a new element describing what it\n\9\9should transform into.\n\n\9\9`updateVirtualNode` will return a new virtual node that should replace\n\9\9the passed in virtual node. This is because a virtual node can be\n\9\9updated with an element referencing a different component!\n\n\9\9In that case, `updateVirtualNode` will unmount the input virtual node,\n\9\9mount a new virtual node, and return it in this case, while also issuing\n\9\9a warning to the user.\n\9]]\n\9function updateVirtualNode(virtualNode, newElement, newState: { [any]: any }?): { [any]: any }?\n\9\9if config.internalTypeChecks then\n\9\9\9internalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\9\9end\n\9\9if config.typeChecks then\n\9\9\9assert(\n\9\9\9\9Type.of(newElement) == Type.Element or typeof(newElement) == \"boolean\" or newElement == nil,\n\9\9\9\9\"Expected arg #2 to be of type Element, boolean, or nil\"\n\9\9\9)\n\9\9end\n\n\9\9-- If nothing changed, we can skip this update\n\9\9if virtualNode.currentElement == newElement and newState == nil then\n\9\9\9return virtualNode\n\9\9end\n\n\9\9if typeof(newElement) == \"boolean\" or newElement == nil then\n\9\9\9unmountVirtualNode(virtualNode)\n\9\9\9return nil\n\9\9end\n\n\9\9if virtualNode.currentElement.component ~= newElement.component then\n\9\9\9return replaceVirtualNode(virtualNode, newElement)\n\9\9end\n\n\9\9local kind = ElementKind.of(newElement)\n\n\9\9local shouldContinueUpdate = true\n\n\9\9if kind == ElementKind.Host then\n\9\9\9virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)\n\9\9elseif kind == ElementKind.Function then\n\9\9\9virtualNode = updateFunctionVirtualNode(virtualNode, newElement)\n\9\9elseif kind == ElementKind.Stateful then\n\9\9\9shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)\n\9\9elseif kind == ElementKind.Portal then\n\9\9\9virtualNode = updatePortalVirtualNode(virtualNode, newElement)\n\9\9elseif kind == ElementKind.Fragment then\n\9\9\9virtualNode = updateFragmentVirtualNode(virtualNode, newElement)\n\9\9else\n\9\9\9error((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\9\9end\n\n\9\9-- Stateful components can abort updates via shouldUpdate. If that\n\9\9-- happens, we should stop doing stuff at this point.\n\9\9if not shouldContinueUpdate then\n\9\9\9return virtualNode\n\9\9end\n\n\9\9virtualNode.currentElement = newElement\n\n\9\9return virtualNode\n\9end\n\n\9--[[\n\9\9Constructs a new virtual node but not does mount it.\n\9]]\n\9local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\9\9if config.internalTypeChecks then\n\9\9\9internalAssert(\n\9\9\9\9renderer.isHostObject(hostParent) or hostParent == nil,\n\9\9\9\9\"Expected arg #2 to be a host object\"\n\9\9\9)\n\9\9\9internalAssert(typeof(context) == \"table\" or context == nil, \"Expected arg #4 to be of type table or nil\")\n\9\9\9internalAssert(\n\9\9\9\9typeof(legacyContext) == \"table\" or legacyContext == nil,\n\9\9\9\9\"Expected arg #5 to be of type table or nil\"\n\9\9\9)\n\9\9end\n\9\9if config.typeChecks then\n\9\9\9assert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\9\9\9assert(\n\9\9\9\9Type.of(element) == Type.Element or typeof(element) == \"boolean\",\n\9\9\9\9\"Expected arg #1 to be of type Element or boolean\"\n\9\9\9)\n\9\9end\n\n\9\9return {\n\9\9\9[Type] = Type.VirtualNode,\n\9\9\9currentElement = element,\n\9\9\9depth = 1,\n\9\9\9parent = nil,\n\9\9\9children = {},\n\9\9\9hostParent = hostParent,\n\9\9\9hostKey = hostKey,\n\9\9\9updateChildrenCount = 0,\n\9\9\9wasUnmounted = false,\n\n\9\9\9-- Legacy Context API\n\9\9\9-- A table of context values inherited from the parent node\n\9\9\9legacyContext = legacyContext,\n\n\9\9\9-- A saved copy of the parent context, used when replacing a node\n\9\9\9parentLegacyContext = legacyContext,\n\n\9\9\9-- Context API\n\9\9\9-- A table of context values inherited from the parent node\n\9\9\9context = context or {},\n\n\9\9\9-- A saved copy of the unmodified context; this will be updated when\n\9\9\9-- a component adds new context and used when a node is replaced\n\9\9\9originalContext = nil,\n\9\9}\n\9end\n\n\9local function mountFunctionVirtualNode(virtualNode)\n\9\9local element = virtualNode.currentElement\n\n\9\9local children = element.component(element.props)\n\n\9\9updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\9end\n\n\9local function mountPortalVirtualNode(virtualNode)\n\9\9local element = virtualNode.currentElement\n\n\9\9local targetHostParent = element.props.target\n\9\9local children = element.props[Children]\n\n\9\9assert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\9\9updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\9end\n\n\9local function mountFragmentVirtualNode(virtualNode)\n\9\9local element = virtualNode.currentElement\n\9\9local children = element.elements\n\n\9\9updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)\n\9end\n\n\9--[[\n\9\9Constructs a new virtual node and mounts it, but does not place it into\n\9\9the tree.\n\9]]\n\9function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\9\9if config.internalTypeChecks then\n\9\9\9internalAssert(\n\9\9\9\9renderer.isHostObject(hostParent) or hostParent == nil,\n\9\9\9\9\"Expected arg #2 to be a host object\"\n\9\9\9)\n\9\9\9internalAssert(\n\9\9\9\9typeof(legacyContext) == \"table\" or legacyContext == nil,\n\9\9\9\9\"Expected arg #5 to be of type table or nil\"\n\9\9\9)\n\9\9end\n\9\9if config.typeChecks then\n\9\9\9assert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\9\9\9assert(\n\9\9\9\9Type.of(element) == Type.Element or typeof(element) == \"boolean\",\n\9\9\9\9\"Expected arg #1 to be of type Element or boolean\"\n\9\9\9)\n\9\9end\n\n\9\9-- Boolean values render as nil to enable terse conditional rendering.\n\9\9if typeof(element) == \"boolean\" then\n\9\9\9return nil\n\9\9end\n\n\9\9local kind = ElementKind.of(element)\n\n\9\9local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\n\9\9if kind == ElementKind.Host then\n\9\9\9renderer.mountHostNode(reconciler, virtualNode)\n\9\9elseif kind == ElementKind.Function then\n\9\9\9mountFunctionVirtualNode(virtualNode)\n\9\9elseif kind == ElementKind.Stateful then\n\9\9\9element.component:__mount(reconciler, virtualNode)\n\9\9elseif kind == ElementKind.Portal then\n\9\9\9mountPortalVirtualNode(virtualNode)\n\9\9elseif kind == ElementKind.Fragment then\n\9\9\9mountFragmentVirtualNode(virtualNode)\n\9\9else\n\9\9\9error((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\9\9end\n\n\9\9return virtualNode\n\9end\n\n\9--[[\n\9\9Constructs a new Roact virtual tree, constructs a root node for\n\9\9it, and mounts it.\n\9]]\n\9local function mountVirtualTree(element, hostParent, hostKey)\n\9\9if config.typeChecks then\n\9\9\9assert(Type.of(element) == Type.Element, \"Expected arg #1 to be of type Element\")\n\9\9\9assert(renderer.isHostObject(hostParent) or hostParent == nil, \"Expected arg #2 to be a host object\")\n\9\9end\n\n\9\9if hostKey == nil then\n\9\9\9hostKey = \"RoactTree\"\n\9\9end\n\n\9\9local tree = {\n\9\9\9[Type] = Type.VirtualTree,\n\9\9\9[InternalData] = {\n\9\9\9\9-- The root node of the tree, which starts into the hierarchy of\n\9\9\9\9-- Roact component instances.\n\9\9\9\9rootNode = nil,\n\9\9\9\9mounted = true,\n\9\9\9},\n\9\9}\n\n\9\9tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)\n\n\9\9return tree\n\9end\n\n\9--[[\n\9\9Unmounts the virtual tree, freeing all of its resources.\n\n\9\9No further operations should be done on the tree after it's been\n\9\9unmounted, as indicated by its the `mounted` field.\n\9]]\n\9local function unmountVirtualTree(tree)\n\9\9local internalData = tree[InternalData]\n\9\9if config.typeChecks then\n\9\9\9assert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\9\9\9assert(internalData.mounted, \"Cannot unmounted a Roact tree that has already been unmounted\")\n\9\9end\n\n\9\9internalData.mounted = false\n\n\9\9if internalData.rootNode ~= nil then\n\9\9\9unmountVirtualNode(internalData.rootNode)\n\9\9end\n\9end\n\n\9--[[\n\9\9Utility method for updating the root node of a virtual tree given a new\n\9\9element.\n\9]]\n\9local function updateVirtualTree(tree, newElement)\n\9\9local internalData = tree[InternalData]\n\9\9if config.typeChecks then\n\9\9\9assert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\9\9\9assert(Type.of(newElement) == Type.Element, \"Expected arg #2 to be a Roact Element\")\n\9\9end\n\n\9\9internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)\n\n\9\9return tree\n\9end\n\n\9reconciler = {\n\9\9mountVirtualTree = mountVirtualTree,\n\9\9unmountVirtualTree = unmountVirtualTree,\n\9\9updateVirtualTree = updateVirtualTree,\n\n\9\9createVirtualNode = createVirtualNode,\n\9\9mountVirtualNode = mountVirtualNode,\n\9\9unmountVirtualNode = unmountVirtualNode,\n\9\9updateVirtualNode = updateVirtualNode,\n\9\9updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,\n\9\9updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,\n\9}\n\n\9return reconciler\nend\n\nreturn createReconciler\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createReconciler"))(__env)
end)
__lua("createReconcilerCompat", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createReconcilerCompat", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createReconcilerCompat\")local script,require=_.script,_.require --[[\n\9Contains deprecated methods from Reconciler. Broken out so that removing\n\9this shim is easy -- just delete this file and remove it from init.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal reifyMessage = [[\nRoact.reify has been renamed to Roact.mount and will be removed in a future release.\nCheck the call to Roact.reify at:\n]]\n\nlocal teardownMessage = [[\nRoact.teardown has been renamed to Roact.unmount and will be removed in a future release.\nCheck the call to Roact.teardown at:\n]]\n\nlocal reconcileMessage = [[\nRoact.reconcile has been renamed to Roact.update and will be removed in a future release.\nCheck the call to Roact.reconcile at:\n]]\n\nlocal function createReconcilerCompat(reconciler)\n\9local compat = {}\n\n\9function compat.reify(...)\n\9\9Logging.warnOnce(reifyMessage)\n\n\9\9return reconciler.mountVirtualTree(...)\n\9end\n\n\9function compat.teardown(...)\n\9\9Logging.warnOnce(teardownMessage)\n\n\9\9return reconciler.unmountVirtualTree(...)\n\9end\n\n\9function compat.reconcile(...)\n\9\9Logging.warnOnce(reconcileMessage)\n\n\9\9return reconciler.updateVirtualTree(...)\n\9end\n\n\9return compat\nend\n\nreturn createReconcilerCompat\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createReconcilerCompat"))(__env)
end)
__lua("createRef", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createRef", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createRef\")local script,require=_.script,_.require --[[\n\9A ref is nothing more than a binding with a special field 'current'\n\9that maps to the getValue method of the binding\n]]\nlocal Binding = require(script.Parent.Binding)\n\nlocal function createRef()\n\9local binding, _ = Binding.create(nil)\n\n\9local ref = {}\n\n\9--[[\n\9\9A ref is just redirected to a binding via its metatable\n\9]]\n\9setmetatable(ref, {\n\9\9__index = function(_self, key)\n\9\9\9if key == \"current\" then\n\9\9\9\9return binding:getValue()\n\9\9\9else\n\9\9\9\9return binding[key]\n\9\9\9end\n\9\9end,\n\9\9__newindex = function(_self, key, value)\n\9\9\9if key == \"current\" then\n\9\9\9\9error(\"Cannot assign to the 'current' property of refs\", 2)\n\9\9\9end\n\n\9\9\9binding[key] = value\n\9\9end,\n\9\9__tostring = function(_self)\n\9\9\9return (\"RoactRef(%s)\"):format(tostring(binding:getValue()))\n\9\9end,\n\9})\n\n\9return ref\nend\n\nreturn createRef\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createRef"))(__env)
end)
__lua("createSignal", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createSignal", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createSignal\")local script,require=_.script,_.require --[[\n\9This is a simple signal implementation that has a dead-simple API.\n\n\9\9local signal = createSignal()\n\n\9\9local disconnect = signal:subscribe(function(foo)\n\9\9\9print(\"Cool foo:\", foo)\n\9\9end)\n\n\9\9signal:fire(\"something\")\n\n\9\9disconnect()\n]]\n\nlocal function createSignal()\n\9local connections = {}\n\9local suspendedConnections = {}\n\9local firing = false\n\n\9local function subscribe(_self, callback)\n\9\9assert(typeof(callback) == \"function\", \"Can only subscribe to signals with a function.\")\n\n\9\9local connection = {\n\9\9\9callback = callback,\n\9\9\9disconnected = false,\n\9\9}\n\n\9\9-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable\n\9\9-- the existing one.\n\9\9if firing and not connections[callback] then\n\9\9\9suspendedConnections[callback] = connection\n\9\9end\n\n\9\9connections[callback] = connection\n\n\9\9local function disconnect()\n\9\9\9assert(not connection.disconnected, \"Listeners can only be disconnected once.\")\n\n\9\9\9connection.disconnected = true\n\9\9\9connections[callback] = nil\n\9\9\9suspendedConnections[callback] = nil\n\9\9end\n\n\9\9return disconnect\n\9end\n\n\9local function fire(_self, ...)\n\9\9firing = true\n\9\9for callback, connection in pairs(connections) do\n\9\9\9if not connection.disconnected and not suspendedConnections[callback] then\n\9\9\9\9callback(...)\n\9\9\9end\n\9\9end\n\n\9\9firing = false\n\n\9\9for callback, _ in pairs(suspendedConnections) do\n\9\9\9suspendedConnections[callback] = nil\n\9\9end\n\9end\n\n\9return {\n\9\9subscribe = subscribe,\n\9\9fire = fire,\n\9}\nend\n\nreturn createSignal\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createSignal"))(__env)
end)
__lua("createSpy", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.createSpy", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.createSpy\")local script,require=_.script,_.require --[[\n\9A utility used to create a function spy that can be used to robustly test\n\9that functions are invoked the correct number of times and with the correct\n\9number of arguments.\n\n\9This should only be used in tests.\n]]\n\nlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\nlocal function createSpy(inner)\n\9local self = {}\n\9self.callCount = 0\n\9self.values = {}\n\9self.valuesLength = 0\n\9self.value = function(...)\n\9\9self.callCount = self.callCount + 1\n\9\9self.values = { ... }\n\9\9self.valuesLength = select(\"#\", ...)\n\n\9\9if inner ~= nil then\n\9\9\9return inner(...)\n\9\9end\n\9\9return nil\n\9end\n\n\9self.assertCalledWith = function(_, ...)\n\9\9local len = select(\"#\", ...)\n\n\9\9if self.valuesLength ~= len then\n\9\9\9error((\"Expected %d arguments, but was called with %d arguments\"):format(self.valuesLength, len), 2)\n\9\9end\n\n\9\9for i = 1, len do\n\9\9\9local expected = select(i, ...)\n\n\9\9\9assert(self.values[i] == expected, \"value differs\")\n\9\9end\n\9end\n\n\9self.assertCalledWithDeepEqual = function(_, ...)\n\9\9local len = select(\"#\", ...)\n\n\9\9if self.valuesLength ~= len then\n\9\9\9error((\"Expected %d arguments, but was called with %d arguments\"):format(self.valuesLength, len), 2)\n\9\9end\n\n\9\9for i = 1, len do\n\9\9\9local expected = select(i, ...)\n\n\9\9\9assertDeepEqual(self.values[i], expected)\n\9\9end\n\9end\n\n\9self.captureValues = function(_, ...)\n\9\9local len = select(\"#\", ...)\n\9\9local result = {}\n\n\9\9assert(self.valuesLength == len, \"length of expected values differs from stored values\")\n\n\9\9for i = 1, len do\n\9\9\9local key = select(i, ...)\n\9\9\9result[key] = self.values[i]\n\9\9end\n\n\9\9return result\n\9end\n\n\9setmetatable(self, {\n\9\9__index = function(_, key)\n\9\9\9error((\"%q is not a valid member of spy\"):format(key))\n\9\9end,\n\9})\n\n\9return self\nend\n\nreturn createSpy\n", "bundle-ex.include.node_modules.@rbxts.roact.src.createSpy"))(__env)
end)
__lua("forwardRef", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.forwardRef", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.forwardRef\")local script,require=_.script,_.require local assign = require(script.Parent.assign)\nlocal None = require(script.Parent.None)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal excludeRef = {\n\9[Ref] = None,\n}\n\n--[[\n\9Allows forwarding of refs to underlying host components. Accepts a render\n\9callback which accepts props and a ref, and returns an element.\n]]\nlocal function forwardRef(render)\n\9if config.typeChecks then\n\9\9assert(typeof(render) == \"function\", \"Expected arg #1 to be a function\")\n\9end\n\n\9return function(props)\n\9\9local ref = props[Ref]\n\9\9local propsWithoutRef = assign({}, props, excludeRef)\n\n\9\9return render(propsWithoutRef, ref)\n\9end\nend\n\nreturn forwardRef\n", "bundle-ex.include.node_modules.@rbxts.roact.src.forwardRef"))(__env)
end)
__lua("getDefaultInstanceProperty", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.getDefaultInstanceProperty", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.getDefaultInstanceProperty\")local script,require=_.script,_.require --[[\n\9Attempts to get the default value of a given property on a Roblox instance.\n\n\9This is used by the reconciler in cases where a prop was previously set on a\n\9primitive component, but is no longer present in a component's new props.\n\n\9Eventually, Roblox might provide a nicer API to query the default property\n\9of an object without constructing an instance of it.\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal Nil = Symbol.named(\"Nil\")\nlocal _cachedPropertyValues = {}\n\nlocal function getDefaultInstanceProperty(className, propertyName)\n\9local classCache = _cachedPropertyValues[className]\n\n\9if classCache then\n\9\9local propValue = classCache[propertyName]\n\n\9\9-- We have to use a marker here, because Lua doesn't distinguish\n\9\9-- between 'nil' and 'not in a table'\n\9\9if propValue == Nil then\n\9\9\9return true, nil\n\9\9end\n\n\9\9if propValue ~= nil then\n\9\9\9return true, propValue\n\9\9end\n\9else\n\9\9classCache = {}\n\9\9_cachedPropertyValues[className] = classCache\n\9end\n\n\9local created = Instance.new(className)\n\9local ok, defaultValue = pcall(function()\n\9\9return created[propertyName]\n\9end)\n\n\9created:Destroy()\n\n\9if ok then\n\9\9if defaultValue == nil then\n\9\9\9classCache[propertyName] = Nil\n\9\9else\n\9\9\9classCache[propertyName] = defaultValue\n\9\9end\n\9end\n\n\9return ok, defaultValue\nend\n\nreturn getDefaultInstanceProperty\n", "bundle-ex.include.node_modules.@rbxts.roact.src.getDefaultInstanceProperty"))(__env)
end)
__lua("internalAssert", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.internalAssert", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.internalAssert\")local script,require=_.script,_.require local function internalAssert(condition, message)\n\9if not condition then\n\9\9error(message .. \" (This is probably a bug in Roact!)\", 3)\n\9end\nend\n\nreturn internalAssert\n", "bundle-ex.include.node_modules.@rbxts.roact.src.internalAssert"))(__env)
end)
__lua("invalidSetStateMessages", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.invalidSetStateMessages", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.invalidSetStateMessages\")local script,require=_.script,_.require --[[\n\9These messages are used by Component to help users diagnose when they're\n\9calling setState in inappropriate places.\n\n\9The indentation may seem odd, but it's necessary to avoid introducing extra\n\9whitespace into the error messages themselves.\n]]\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\n\nlocal invalidSetStateMessages = {}\n\ninvalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[\nsetState cannot be used in the willUpdate lifecycle method.\nConsider using the didUpdate method instead, or using getDerivedStateFromProps.\n\nCheck the definition of willUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[\nsetState cannot be used in the shouldUpdate lifecycle method.\nshouldUpdate must be a pure function that only depends on props and state.\n\nCheck the definition of shouldUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.Render] = [[\nsetState cannot be used in the render method.\nrender must be a pure function that only depends on props and state.\n\nCheck the definition of render in the component %q.]]\n\ninvalidSetStateMessages[\"default\"] = [[\nsetState can not be used in the current situation, because Roact doesn't know\nwhich part of the lifecycle this component is in.\n\nThis is a bug in Roact.\nIt was triggered by the component %q.\n]]\n\nreturn invalidSetStateMessages\n", "bundle-ex.include.node_modules.@rbxts.roact.src.invalidSetStateMessages"))(__env)
end)
__lua("oneChild", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.oneChild", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.oneChild\")local script,require=_.script,_.require --[[\n\9Retrieves at most one child from the children passed to a component.\n\n\9If passed nil or an empty table, will return nil.\n\n\9Throws an error if passed more than one child.\n]]\nlocal function oneChild(children)\n\9if not children then\n\9\9return nil\n\9end\n\n\9local key, child = next(children)\n\n\9if not child then\n\9\9return nil\n\9end\n\n\9local after = next(children, key)\n\n\9if after then\n\9\9error(\"Expected at most child, had more than one child.\", 2)\n\9end\n\n\9return child\nend\n\nreturn oneChild\n", "bundle-ex.include.node_modules.@rbxts.roact.src.oneChild"))(__env)
end)
__lua("strict", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact.src.strict", "bundle-ex.include.node_modules.@rbxts.roact.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact.src.strict\")local script,require=_.script,_.require --!strict\nlocal function strict(t: { [any]: any }, name: string?)\n\9-- FIXME Luau: Need to define a new variable since reassigning `name = ...`\n\9-- doesn't narrow the type\n\9local newName = name or tostring(t)\n\n\9return setmetatable(t, {\n\9\9__index = function(_self, key)\n\9\9\9local message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), newName)\n\n\9\9\9error(message, 2)\n\9\9end,\n\n\9\9__newindex = function(_self, key, _value)\n\9\9\9local message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), newName)\n\n\9\9\9error(message, 2)\n\9\9end,\n\9})\nend\n\nreturn strict\n", "bundle-ex.include.node_modules.@rbxts.roact.src.strict"))(__env)
end)
__rbx("roact-hooked", "Folder", "bundle-ex.include.node_modules.@rbxts.roact-hooked", "bundle-ex.include.node_modules.@rbxts")
__lua("src", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src", "bundle-ex.include.node_modules.@rbxts.roact-hooked", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact-hooked.src\")local script,require=_.script,_.require local hoc = require(script.hoc)\nlocal hooks = require(script.hooks)\nlocal withHookDetection = require(script.withHookDetection)\nlocal pureComponent = require(script.pureComponent)\n\nreturn {\n\9-- HOC\n\9withHooks = hoc.withHooks,\n\9withHooksPure = hoc.withHooksPure,\n\9withHookDetection = withHookDetection,\n\9markPureComponent = pureComponent.markPureComponent,\n\n\9-- Hooks\n\9useBinding = hooks.useBinding,\n\9useCallback = hooks.useCallback,\n\9useContext = hooks.useContext,\n\9useEffect = hooks.useEffect,\n\9useMemo = hooks.useMemo,\n\9useMutable = hooks.useMutable,\n\9useReducer = hooks.useReducer,\n\9useRef = hooks.useRef,\n\9useState = hooks.useState,\n}\n", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src"))(__env)
end)
__lua("NoYield", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.NoYield", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact-hooked.src.NoYield\")local script,require=_.script,_.require --[[\n\9Calls a function and throws an error if it attempts to yield.\n\9Pass any number of arguments to the function after the callback.\n\9This function supports multiple return; all results returned from the\n\9given function will be returned.\n\9https://github.com/Roblox/rodux/blob/master/src/NoYield.lua\n]]\n\nlocal function resultHandler(co: thread, ok: boolean, ...)\n\9if not ok then\n\9\9local err = (...)\n\9\9if typeof(err) == \"string\" then\n\9\9\9error(debug.traceback(co, err), 2)\n\9\9else\n\9\9\9-- If the error is not of type string, just assume it has some\n\9\9\9-- meaningful information and rethrow it with a `tostring` so that\n\9\9\9-- top-level error handlers can process it\n\9\9\9error(tostring(err), 2)\n\9\9end\n\9end\n\n\9if coroutine.status(co) ~= \"dead\" then\n\9\9error(debug.traceback(co, \"Attempted to yield inside useEffect!\"), 2)\n\9end\n\n\9return ...\nend\n\nlocal function NoYield(callback, ...)\n\9local co = coroutine.create(callback)\n\n\9return resultHandler(co, coroutine.resume(co, ...))\nend\n\nreturn NoYield\n", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.NoYield"))(__env)
end)
__lua("Roact", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.Roact", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact-hooked.src.Roact\")local script,require=_.script,_.require local modules = script:FindFirstAncestor(\"node_modules\")\n\nif modules:FindFirstChild(\"roact\") then\n\9return require(modules.roact.src)\nelseif modules:FindFirstChild(\"@rbxts\") then\n\9return require(modules[\"@rbxts\"].roact.src)\nelseif script.Parent.Parent:FindFirstChild(\"Roact\") then\n\9return require(script.Parent.Parent.Roact)\nelse\n\9error(\"Could not find Roact or @rbxts/roact in the parent hierarchy.\")\nend\n", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.Roact"))(__env)
end)
__lua("hoc", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.hoc", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact-hooked.src.hoc\")local script,require=_.script,_.require local Roact = require(script.Parent.Roact)\nlocal hooks = require(script.Parent.hooks)\nlocal prepareToUseHooks = hooks.prepareToUseHooks\nlocal finishHooks = hooks.finishHooks\nlocal commitHookEffectListUpdate = hooks.commitHookEffectListUpdate\nlocal commitHookEffectListUnmount = hooks.commitHookEffectListUnmount\n\nlocal function withHooksImpl(Component, Class, api)\n\9local componentName = debug.info(Component, \"n\") or \"Component\"\n\9if componentName == \"\" then\n\9\9componentName = \"Component\"\n\9end\n\n\9local Proxy = Class:extend(componentName .. \" (roact-hooked)\")\n\n\9Proxy._name = componentName\n\n\9function Proxy:render()\n\9\9prepareToUseHooks(self)\n\9\9local children = Component(self.props)\n\9\9finishHooks()\n\9\9return children\n\9end\n\n\9function Proxy:didMount()\n\9\9commitHookEffectListUpdate(self)\n\9end\n\n\9function Proxy:didUpdate()\n\9\9commitHookEffectListUpdate(self)\n\9end\n\n\9function Proxy:willUnmount()\n\9\9commitHookEffectListUnmount(self)\n\9end\n\n\9if api and type(api) == \"table\" then\n\9\9for k, v in pairs(api) do\n\9\9\9Proxy[k] = v\n\9\9end\n\9end\n\n\9return Proxy\nend\n\nlocal function withHooks(Component, api)\n\9return withHooksImpl(Component, Roact.Component, api)\nend\n\nlocal function withHooksPure(Component, api)\n\9return withHooksImpl(Component, Roact.PureComponent, api)\nend\n\nreturn {\n\9withHooks = withHooks,\n\9withHooksPure = withHooksPure,\n}\n", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.hoc"))(__env)
end)
__lua("hooks", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.hooks", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact-hooked.src.hooks\")local script,require=_.script,_.require -- https://github.com/facebook/react/blob/main/packages/react-dom/src/server/ReactPartialRendererHooks.js\n-- https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js\n\nlocal Roact = require(script.Parent.Roact)\nlocal NoYield = require(script.Parent.NoYield)\n\nlocal currentlyRenderingComponent\nlocal hookCount = 0\nlocal workInProgressHook\n\nlocal isReRender\n\n-- Used in wrapCreateElement to determine whether this component will use hooks\nlocal didUseHooks = false\nlocal forceEarlyExit = false\n\nlocal function finishHookTest()\n\9forceEarlyExit = false\n\9return didUseHooks\nend\n\nlocal function prepareHookTest()\n\9didUseHooks = false\n\9forceEarlyExit = true\nend\n\nlocal function finishHooks()\n\9currentlyRenderingComponent = nil\n\9hookCount = 0\n\9workInProgressHook = nil\nend\n\nlocal function prepareToUseHooks(componentIdentity)\n\9if workInProgressHook ~= nil then\n\9\9local prev = currentlyRenderingComponent._name\n\9\9local current = componentIdentity._name\n\9\9warn(\"The component '\" .. prev .. \"' did not finish rendering before '\" .. current .. \"' started rendering. Did the former yield or fail to run?\")\n\9\9finishHooks()\n\9end\n\n\9currentlyRenderingComponent = componentIdentity\nend\n\nlocal function resolveCurrentlyRenderingComponent()\n\9didUseHooks = true\n\n\9if forceEarlyExit or not currentlyRenderingComponent then\n\9\9error(\n\9\9\9'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n' ..\n\9\9\9'1. You might be using hooks outside of the withHooks() HOC\\n' ..\n\9\9\9'2. You might be breaking the Rules of Hooks\\n' ..\n\9\9\9'3. A hooked component may have yielded or thrown an error\\n'\n\9\9)\n\9end\n\n\9return currentlyRenderingComponent\nend\n\nlocal function areHookInputsEqual(nextDeps, prevDeps)\n\9if not prevDeps then\n\9\9return false\n\9end\n\n\9if type(nextDeps) ~= type(prevDeps) then\n\9\9return false\n\9end\n\n\9if type(nextDeps) == \"table\" then\n\9\9for key, value in pairs(nextDeps) do\n\9\9\9if prevDeps[key] ~= value then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9for key, value in pairs(prevDeps) do\n\9\9\9if nextDeps[key] ~= value then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\n\n\9return nextDeps == prevDeps\nend\n\nlocal function createHook()\n\9return {\n\9\9memoizedState = nil,\n\9\9next = nil,\n\9\9index = hookCount,\n\9}\nend\n\nlocal function createWorkInProgressHook()\n\9hookCount += 1\n\n\9if not workInProgressHook then\n\9\9-- This is the first hook in the list\n\9\9if not currentlyRenderingComponent.firstHook then\n\9\9\9-- The component is being mounted. Create a new hook.\n\9\9\9isReRender = false\n\n\9\9\9local hook = createHook()\n\9\9\9currentlyRenderingComponent.firstHook = hook\n\9\9\9workInProgressHook = hook\n\9\9else\n\9\9\9-- The component is being re-rendered. Reuse the first hook.\n\9\9\9isReRender = true\n\9\9\9workInProgressHook = currentlyRenderingComponent.firstHook\n\9\9end\n\9else\n\9\9if not workInProgressHook.next then\n\9\9\9isReRender = false\n\n\9\9\9-- Append to the end of the list\n\9\9\9local hook = createHook()\n\9\9\9workInProgressHook.next = hook\n\9\9\9workInProgressHook = hook\n\9\9else\n\9\9\9isReRender = true\n\9\9\9workInProgressHook = workInProgressHook.next\n\9\9end\n\9end\n\n\9return workInProgressHook\nend\n\nlocal function commitHookEffectListUpdate(componentIdentity)\n\9local lastEffect = componentIdentity.lastEffect\n\n\9if not lastEffect then\n\9\9return\n\9end\n\n\9local firstEffect = lastEffect.next\n\9local effect = firstEffect\n\n\9repeat\n\9\9if effect.prevDeps and areHookInputsEqual(effect.deps, effect.prevDeps) then\n\9\9\9-- Nothing changed\n\9\9\9effect = effect.next\n\9\9\9continue\n\9\9end\n\n\9\9-- Clear\n\9\9local destroy = effect.destroy\n\9\9effect.destroy = nil\n\n\9\9if destroy then\n\9\9\9NoYield(destroy)\n\9\9end\n\n\9\9-- Update\n\9\9NoYield(function()\n\9\9\9effect.destroy = effect.create()\n\9\9end)\n\n\9\9effect = effect.next\n\9until effect == firstEffect\nend\n\nlocal function commitHookEffectListUnmount(componentIdentity)\n\9local lastEffect = componentIdentity.lastEffect\n\n\9if not lastEffect then\n\9\9return\n\9end\n\n\9local firstEffect = lastEffect.next\n\9local effect = firstEffect\n\n\9repeat\n\9\9-- Clear\n\9\9local destroy = effect.destroy\n\9\9effect.destroy = nil\n\n\9\9if destroy then\n\9\9\9NoYield(destroy)\n\9\9end\n\n\9\9effect = effect.next\n\9until effect == firstEffect\nend\n\nlocal function pushEffect(create, destroy, deps)\n\9resolveCurrentlyRenderingComponent()\n\n\9local effect = {\n\9\9create = create,\n\9\9destroy = destroy,\n\9\9deps = deps,\n\9\9prevDeps = nil,\n\9\9next = nil,\n\9}\n\n\9local lastEffect = currentlyRenderingComponent.lastEffect\n\n\9if lastEffect then\n\9\9local firstEffect = lastEffect.next\n\9\9lastEffect.next = effect\n\9\9effect.next = firstEffect\n\9\9currentlyRenderingComponent.lastEffect = effect\n\9else\n\9\9effect.next = effect\n\9\9currentlyRenderingComponent.lastEffect = effect\n\9end\n\n\9return effect\nend\n\nlocal function useEffect(create, deps)\n\9resolveCurrentlyRenderingComponent()\n\n\9local hook = createWorkInProgressHook()\n\9\n\9if not isReRender then\n\9\9hook.memoizedState = pushEffect(create, nil, deps)\n\9else\n\9\9hook.memoizedState.prevDeps = hook.memoizedState.deps\n\9\9hook.memoizedState.deps = deps\n\9\9hook.memoizedState.create = create\n\9end\nend\n\nlocal function basicStateReducer(state, action)\n\9if type(action) == \"function\" then\n\9\9return action(state)\n\9else\n\9\9return action\n\9end\nend\n\nlocal function useReducer(reducer, initialArg, init)\n\9local component = resolveCurrentlyRenderingComponent()\n\9local hook = createWorkInProgressHook()\n\n\9-- Mount\n\9if not isReRender then\n\9\9local initialState\n\n\9\9if reducer == basicStateReducer then\n\9\9\9-- Special case for `useState`.\n\9\9\9if type(initialArg) == \"function\" then\n\9\9\9\9initialState = initialArg()\n\9\9\9else\n\9\9\9\9initialState = initialArg\n\9\9\9end\n\9\9else\n\9\9\9if init then\n\9\9\9\9initialState = init(initialArg)\n\9\9\9else\n\9\9\9\9initialState = initialArg\n\9\9\9end\n\9\9end\n\n\9\9local function dispatch(action)\n\9\9\9local nextState = reducer(hook.memoizedState.state, action)\n\n\9\9\9if nextState == hook.memoizedState.state then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9hook.memoizedState.state = nextState\n\n\9\9\9component:setState({\n\9\9\9\9[hook.index] = nextState,\n\9\9\9})\n\n\9\9\9return nextState\n\9\9end\n\n\9\9hook.memoizedState = {\n\9\9\9dispatch = dispatch,\n\9\9\9state = initialState,\n\9\9}\n\9end\n\n\9return hook.memoizedState.state, hook.memoizedState.dispatch\nend\n\nlocal function useState(initialState)\n\9-- Use useReducer's special case for `useState`.\n\9return useReducer(basicStateReducer, initialState)\nend\n\nlocal function useMemo(create, deps)\n\9resolveCurrentlyRenderingComponent()\n\n\9local hook = createWorkInProgressHook()\n\9local prevState = hook.memoizedState\n\n\9if prevState ~= nil and deps ~= nil and areHookInputsEqual(deps, prevState.deps) then\n\9\9return prevState.value\n\9end\n\n\9local value = create()\n\9hook.memoizedState = { value = value, deps = deps }\n\n\9return value\nend\n\nlocal function useCallback(callback, deps)\n\9return useMemo(function()\n\9\9return callback\n\9end, deps)\nend\n\nlocal function useMutable(initialValue)\n\9resolveCurrentlyRenderingComponent()\n\n\9local hook = createWorkInProgressHook()\n\n\9if not isReRender then\n\9\9hook.memoizedState = { current = initialValue }\n\9end\n\n\9return hook.memoizedState\nend\n\nlocal function useRef()\n\9resolveCurrentlyRenderingComponent()\n\n\9local hook = createWorkInProgressHook()\n\n\9if not isReRender then\n\9\9hook.memoizedState = Roact.createRef()\n\9end\n\n\9return hook.memoizedState\nend\n\nlocal function useBinding(initialValue)\n\9resolveCurrentlyRenderingComponent()\n\9\n\9local hook = createWorkInProgressHook()\n\n\9if not isReRender then\n\9\9local binding, setValue = Roact.createBinding(initialValue)\n\9\9hook.memoizedState = { binding = binding, setValue = setValue }\n\9end\n\n\9return hook.memoizedState.binding, hook.memoizedState.setValue\nend\n\nlocal function useContext(context)\n\9resolveCurrentlyRenderingComponent()\n\n\9local hook = createWorkInProgressHook()\n\n\9if not isReRender then\n\9\9-- Using https://github.com/Kampfkarren/roact-hooks/pull/38\n\9\9local memoizedState = {\n\9\9\9fakeConsumer = setmetatable({}, {\n\9\9\9\9__index = currentlyRenderingComponent\n\9\9\9}),\n\9\9\9initialValue = nil,\n\9\9}\n\n\9\9local initialValue\n\n\9\9memoizedState.fakeConsumer.props = {\n\9\9\9render = function(value)\n\9\9\9\9initialValue = value\n\9\9\9end,\n\9\9}\n\n\9\9-- contextEntry is always nil here, so it will pass initialValue to render\n\9\9context.Consumer.render(memoizedState.fakeConsumer)\n\n\9\9memoizedState.initialValue = initialValue\n\9\9hook.memoizedState = memoizedState\n\9end\n\n\9-- Sets the context entry internally\n\9context.Consumer.init(hook.memoizedState.fakeConsumer)\n\n\9local contextEntry = hook.memoizedState.fakeConsumer.contextEntry\n\9local initialValue = hook.memoizedState.initialValue\n\n\9local value, setValue = useState(if contextEntry == nil then initialValue else contextEntry.value)\n\n\9useEffect(function()\n\9\9if contextEntry == nil then\n\9\9\9if value ~= initialValue then\n\9\9\9\9setValue(initialValue)\n\9\9\9end\n\9\9\9return\n\9\9end\n\n\9\9if value ~= contextEntry.value then\n\9\9\9setValue(contextEntry.value)\n\9\9end\n\n\9\9return contextEntry.onUpdate:subscribe(setValue)\n\9end, { contextEntry })\n\n\9return value\nend\n\nreturn {\n\9-- Hooks\n\9useBinding = useBinding,\n\9useCallback = useCallback,\n\9useContext = useContext,\n\9useEffect = useEffect,\n\9useMemo = useMemo,\n\9useMutable = useMutable,\n\9useReducer = useReducer,\n\9useRef = useRef,\n\9useState = useState,\n\n\9-- Internal API\n\9prepareHookTest = prepareHookTest,\n\9finishHookTest = finishHookTest,\n\9commitHookEffectListUpdate = commitHookEffectListUpdate,\n\9commitHookEffectListUnmount = commitHookEffectListUnmount,\n\9prepareToUseHooks = prepareToUseHooks,\n\9finishHooks = finishHooks,\n}\n", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.hooks"))(__env)
end)
__lua("pureComponent", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.pureComponent", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact-hooked.src.pureComponent\")local script,require=_.script,_.require local pureComponents = {}\n\nlocal function markPureComponent(functionComponent)\n\9pureComponents[functionComponent] = true\n\9return functionComponent\nend\n\nlocal function isPureComponent(functionComponent)\n\9return pureComponents[functionComponent]\nend\n\nreturn {\n\9markPureComponent = markPureComponent,\n\9isPureComponent = isPureComponent,\n}\n", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.pureComponent"))(__env)
end)
__lua("withHookDetection", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.withHookDetection", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.roact-hooked.src.withHookDetection\")local script,require=_.script,_.require local hoc = require(script.Parent.hoc)\nlocal hooks = require(script.Parent.hooks)\nlocal pureComponent = require(script.Parent.pureComponent)\n\nlocal proxyComponents = {}\nlocal statelessComponents = {}\nlocal modulesWithHookDetection = {}\n\nlocal function withHookDetection(Roact)\n\9local moduleId = tostring(Roact)\n\9local createElement = Roact.createElement\n\n\9if modulesWithHookDetection[moduleId] then\n\9\9return\n\9end\n\n\9modulesWithHookDetection[moduleId] = true\n\n\9function Roact.createElement(component, props, children)\n\9\9if type(component) ~= \"function\" or statelessComponents[component] then\n\9\9\9return createElement(component, props, children)\n\9\9end\n\n\9\9if proxyComponents[component] then\n\9\9\9-- The proxy for this component has already been created\n\9\9\9return createElement(proxyComponents[component], props, children)\n\9\9end\n\n\9\9if props == nil then\n\9\9\9props = {}\n\9\9end\n\n\9\9hooks.prepareHookTest()\n\n\9\9pcall(component, props)\n\n\9\9local didUseHooks = hooks.finishHookTest()\n\n\9\9if didUseHooks then\n\9\9\9-- If the component tried to use hooks, create a proxy component\n\9\9\9local proxyComponent\n\n\9\9\9if pureComponent.isPureComponent(component) then\n\9\9\9\9proxyComponent = hoc.withHooksPure(component)\n\9\9\9else\n\9\9\9\9proxyComponent = hoc.withHooks(component)\n\9\9\9end\n\n\9\9\9proxyComponents[component] = proxyComponent\n\n\9\9\9return createElement(proxyComponent, props, children)\n\9\9else\n\9\9\9-- Mark this component as stateless so we don't have to check it again\n\9\9\9statelessComponents[component] = true\n\9\9\9return createElement(component, props, children)\n\9\9end\n\9end\nend\n\nreturn withHookDetection\n", "bundle-ex.include.node_modules.@rbxts.roact-hooked.src.withHookDetection"))(__env)
end)
__lua("services", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.services", "bundle-ex.include.node_modules.@rbxts", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.services\")local script,require=_.script,_.require return setmetatable({}, {\n\9__index = function(self, serviceName)\n\9\9local service = game:GetService(serviceName)\n\9\9self[serviceName] = service\n\9\9return service\n\9end,\n})\n", "bundle-ex.include.node_modules.@rbxts.services"))(__env)
end)
__lua("signal", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.signal", "bundle-ex.include.node_modules.@rbxts", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.signal\")local script,require=_.script,_.require local Signal = {}\nSignal.__index = Signal\n\nfunction Signal.new()\n\9return setmetatable({ Bindable = Instance.new(\"BindableEvent\") }, Signal)\nend\n\nfunction Signal:Connect(Callback)\n\9return self.Bindable.Event:Connect(function(GetArguments)\n\9\9Callback(GetArguments())\n\9end)\nend\n\nfunction Signal:Once(Callback)\n\9return self.Bindable.Event:Once(function(GetArguments)\n\9\9Callback(GetArguments())\n\9end)\nend\n\nfunction Signal:ConnectParallel(Callback)\n\9return self.Bindable.Event:ConnectParallel(function(GetArguments)\n\9\9Callback(GetArguments())\n\9end)\nend\n\nfunction Signal:Fire(...)\n\9local Arguments = { ... }\n\9local n = select(\"#\", ...)\n\n\9self.Bindable:Fire(function()\n\9\9return table.unpack(Arguments, 1, n)\n\9end)\nend\n\nfunction Signal:Wait()\n\9return self.Bindable.Event:Wait()()\nend\n\nfunction Signal:Destroy()\n\9self.Bindable:Destroy()\nend\n\nreturn Signal\n", "bundle-ex.include.node_modules.@rbxts.signal"))(__env)
end)
__rbx("t", "Folder", "bundle-ex.include.node_modules.@rbxts.t", "bundle-ex.include.node_modules.@rbxts")
__rbx("lib", "Folder", "bundle-ex.include.node_modules.@rbxts.t.lib", "bundle-ex.include.node_modules.@rbxts.t")
__lua("ts", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.t.lib.ts", "bundle-ex.include.node_modules.@rbxts.t.lib", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.t.lib.ts\")local script,require=_.script,_.require -- t: a runtime typechecker for Roblox\n\nlocal t = {}\n\nfunction t.type(typeName)\n\9return function(value)\n\9\9local valueType = type(value)\n\9\9if valueType == typeName then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\nfunction t.typeof(typeName)\n\9return function(value)\n\9\9local valueType = typeof(value)\n\9\9if valueType == typeName then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9matches any type except nil\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.any(value)\n\9if value ~= nil then\n\9\9return true\n\9else\n\9\9return false\n\9end\nend\n\n--Lua primitives\n\n--[[**\n\9ensures Lua primitive boolean type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.boolean = t.typeof(\"boolean\")\n\n--[[**\n\9ensures Lua primitive thread type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.thread = t.typeof(\"thread\")\n\n--[[**\n\9ensures Lua primitive callback type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.callback = t.typeof(\"function\")\nt[\"function\"] = t.callback\n\n--[[**\n\9ensures Lua primitive none type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.none = t.typeof(\"nil\")\nt[\"nil\"] = t.none\n\n--[[**\n\9ensures Lua primitive string type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.string = t.typeof(\"string\")\n\n--[[**\n\9ensures Lua primitive table type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.table = t.typeof(\"table\")\n\n--[[**\n\9ensures Lua primitive userdata type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.userdata = t.type(\"userdata\")\n\n--[[**\n\9ensures value is a number and non-NaN\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.number(value)\n\9local valueType = typeof(value)\n\9if valueType == \"number\" then\n\9\9if value == value then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9else\n\9\9return false\n\9end\nend\n\n--[[**\n\9ensures value is NaN\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.nan(value)\n\9local valueType = typeof(value)\n\9if valueType == \"number\" then\n\9\9if value ~= value then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9else\n\9\9return false\n\9end\nend\n\n-- roblox types\n\n--[[**\n\9ensures Roblox Axes type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Axes = t.typeof(\"Axes\")\n\n--[[**\n\9ensures Roblox BrickColor type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.BrickColor = t.typeof(\"BrickColor\")\n\n--[[**\n\9ensures Roblox CatalogSearchParams type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.CatalogSearchParams = t.typeof(\"CatalogSearchParams\")\n\n--[[**\n\9ensures Roblox CFrame type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.CFrame = t.typeof(\"CFrame\")\n\n--[[**\n\9ensures Roblox Color3 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Color3 = t.typeof(\"Color3\")\n\n--[[**\n\9ensures Roblox ColorSequence type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.ColorSequence = t.typeof(\"ColorSequence\")\n\n--[[**\n\9ensures Roblox ColorSequenceKeypoint type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.ColorSequenceKeypoint = t.typeof(\"ColorSequenceKeypoint\")\n\n--[[**\n\9ensures Roblox DateTime type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.DateTime = t.typeof(\"DateTime\")\n\n--[[**\n\9ensures Roblox DockWidgetPluginGuiInfo type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.DockWidgetPluginGuiInfo = t.typeof(\"DockWidgetPluginGuiInfo\")\n\n--[[**\n\9ensures Roblox Enum type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Enum = t.typeof(\"Enum\")\n\n--[[**\n\9ensures Roblox EnumItem type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.EnumItem = t.typeof(\"EnumItem\")\n\n--[[**\n\9ensures Roblox Enums type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Enums = t.typeof(\"Enums\")\n\n--[[**\n\9ensures Roblox Faces type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Faces = t.typeof(\"Faces\")\n\n--[[**\n\9ensures Roblox Instance type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Instance = t.typeof(\"Instance\")\n\n--[[**\n\9ensures Roblox NumberRange type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.NumberRange = t.typeof(\"NumberRange\")\n\n--[[**\n\9ensures Roblox NumberSequence type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.NumberSequence = t.typeof(\"NumberSequence\")\n\n--[[**\n\9ensures Roblox NumberSequenceKeypoint type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.NumberSequenceKeypoint = t.typeof(\"NumberSequenceKeypoint\")\n\n--[[**\n\9ensures Roblox PathWaypoint type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.PathWaypoint = t.typeof(\"PathWaypoint\")\n\n--[[**\n\9ensures Roblox PhysicalProperties type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.PhysicalProperties = t.typeof(\"PhysicalProperties\")\n\n--[[**\n\9ensures Roblox Random type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Random = t.typeof(\"Random\")\n\n--[[**\n\9ensures Roblox Ray type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Ray = t.typeof(\"Ray\")\n\n--[[**\n\9ensures Roblox RaycastParams type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RaycastParams = t.typeof(\"RaycastParams\")\n\n--[[**\n\9ensures Roblox RaycastResult type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RaycastResult = t.typeof(\"RaycastResult\")\n\n--[[**\n\9ensures Roblox RBXScriptConnection type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RBXScriptConnection = t.typeof(\"RBXScriptConnection\")\n\n--[[**\n\9ensures Roblox RBXScriptSignal type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RBXScriptSignal = t.typeof(\"RBXScriptSignal\")\n\n--[[**\n\9ensures Roblox Rect type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Rect = t.typeof(\"Rect\")\n\n--[[**\n\9ensures Roblox Region3 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Region3 = t.typeof(\"Region3\")\n\n--[[**\n\9ensures Roblox Region3int16 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Region3int16 = t.typeof(\"Region3int16\")\n\n--[[**\n\9ensures Roblox TweenInfo type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.TweenInfo = t.typeof(\"TweenInfo\")\n\n--[[**\n\9ensures Roblox UDim type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.UDim = t.typeof(\"UDim\")\n\n--[[**\n\9ensures Roblox UDim2 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.UDim2 = t.typeof(\"UDim2\")\n\n--[[**\n\9ensures Roblox Vector2 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector2 = t.typeof(\"Vector2\")\n\n--[[**\n\9ensures Roblox Vector2int16 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector2int16 = t.typeof(\"Vector2int16\")\n\n--[[**\n\9ensures Roblox Vector3 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector3 = t.typeof(\"Vector3\")\n\n--[[**\n\9ensures Roblox Vector3int16 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector3int16 = t.typeof(\"Vector3int16\")\n\n--[[**\n\9ensures value is a given literal value\n\n\9@param literal The literal to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.literal(...)\n\9local size = select(\"#\", ...)\n\9if size == 1 then\n\9\9local literal = ...\n\9\9return function(value)\n\9\9\9if value ~= literal then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9else\n\9\9local literals = {}\n\9\9for i = 1, size do\n\9\9\9local value = select(i, ...)\n\9\9\9literals[i] = t.literal(value)\n\9\9end\n\n\9\9return t.union(table.unpack(literals, 1, size))\n\9end\nend\n\n--[[**\n\9DEPRECATED\n\9Please use t.literal\n**--]]\nt.exactly = t.literal\n\n--[[**\n\9Returns a t.union of each key in the table as a t.literal\n\n\9@param keyTable The table to get keys from\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.keyOf(keyTable)\n\9local keys = {}\n\9local length = 0\n\9for key in pairs(keyTable) do\n\9\9length = length + 1\n\9\9keys[length] = key\n\9end\n\n\9return t.literal(table.unpack(keys, 1, length))\nend\n\n--[[**\n\9Returns a t.union of each value in the table as a t.literal\n\n\9@param valueTable The table to get values from\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.valueOf(valueTable)\n\9local values = {}\n\9local length = 0\n\9for _, value in pairs(valueTable) do\n\9\9length = length + 1\n\9\9values[length] = value\n\9end\n\n\9return t.literal(table.unpack(values, 1, length))\nend\n\n--[[**\n\9ensures value is an integer\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.integer(value)\n\9local success = t.number(value)\n\9if not success then\n\9\9return false\n\9end\n\n\9if value % 1 == 0 then\n\9\9return true\n\9else\n\9\9return false\n\9end\nend\n\n--[[**\n\9ensures value is a number where min <= value\n\n\9@param min The minimum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMin(min)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if value >= min then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where value <= max\n\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMax(max)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if value <= max then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where min < value\n\n\9@param min The minimum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMinExclusive(min)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if min < value then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where value < max\n\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMaxExclusive(max)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if value < max then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where value > 0\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nt.numberPositive = t.numberMinExclusive(0)\n\n--[[**\n\9ensures value is a number where value < 0\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nt.numberNegative = t.numberMaxExclusive(0)\n\n--[[**\n\9ensures value is a number where min <= value <= max\n\n\9@param min The minimum to use\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberConstrained(min, max)\n\9assert(t.number(min))\n\9assert(t.number(max))\n\9local minCheck = t.numberMin(min)\n\9local maxCheck = t.numberMax(max)\n\n\9return function(value)\n\9\9local minSuccess = minCheck(value)\n\9\9if not minSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9local maxSuccess = maxCheck(value)\n\9\9if not maxSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is a number where min < value < max\n\n\9@param min The minimum to use\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberConstrainedExclusive(min, max)\n\9assert(t.number(min))\n\9assert(t.number(max))\n\9local minCheck = t.numberMinExclusive(min)\n\9local maxCheck = t.numberMaxExclusive(max)\n\n\9return function(value)\n\9\9local minSuccess = minCheck(value)\n\9\9if not minSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9local maxSuccess = maxCheck(value)\n\9\9if not maxSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value matches string pattern\n\n\9@param string pattern to check against\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.match(pattern)\n\9assert(t.string(pattern))\n\9return function(value)\n\9\9local stringSuccess = t.string(value)\n\9\9if not stringSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if string.match(value, pattern) == nil then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is either nil or passes check\n\n\9@param check The check to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.optional(check)\n\9assert(t.callback(check))\n\9return function(value)\n\9\9if value == nil then\n\9\9\9return true\n\9\9end\n\n\9\9local success = check(value)\n\9\9if success then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9matches given tuple against tuple type definition\n\n\9@param ... The type definition for the tuples\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.tuple(...)\n\9local checks = { ... }\n\9return function(...)\n\9\9local args = { ... }\n\9\9for i, check in ipairs(checks) do\n\9\9\9local success = check(args[i])\n\9\9\9if success == false then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures all keys in given table pass check\n\n\9@param check The function to use to check the keys\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.keys(check)\n\9assert(t.callback(check))\n\9return function(value)\n\9\9local tableSuccess = t.table(value)\n\9\9if tableSuccess == false then\n\9\9\9return false\n\9\9end\n\n\9\9for key in pairs(value) do\n\9\9\9local success = check(key)\n\9\9\9if success == false then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures all values in given table pass check\n\n\9@param check The function to use to check the values\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.values(check)\n\9assert(t.callback(check))\n\9return function(value)\n\9\9local tableSuccess = t.table(value)\n\9\9if tableSuccess == false then\n\9\9\9return false\n\9\9end\n\n\9\9for _, val in pairs(value) do\n\9\9\9local success = check(val)\n\9\9\9if success == false then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is a table and all keys pass keyCheck and all values pass valueCheck\n\n\9@param keyCheck The function to use to check the keys\n\9@param valueCheck The function to use to check the values\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.map(keyCheck, valueCheck)\n\9assert(t.callback(keyCheck))\n\9assert(t.callback(valueCheck))\n\9local keyChecker = t.keys(keyCheck)\n\9local valueChecker = t.values(valueCheck)\n\n\9return function(value)\n\9\9local keySuccess = keyChecker(value)\n\9\9if not keySuccess then\n\9\9\9return false\n\9\9end\n\n\9\9local valueSuccess = valueChecker(value)\n\9\9if not valueSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is a table and all keys pass valueCheck and all values are true\n\n\9@param valueCheck The function to use to check the values\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.set(valueCheck)\n\9return t.map(valueCheck, t.literal(true))\nend\n\ndo\n\9local arrayKeysCheck = t.keys(t.integer)\n--[[**\n\9\9ensures value is an array and all values of the array match check\n\n\9\9@param check The check to compare all values with\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.array(check)\n\9\9assert(t.callback(check))\n\9\9local valuesCheck = t.values(check)\n\n\9\9return function(value)\n\9\9\9local keySuccess = arrayKeysCheck(value)\n\9\9\9if keySuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9-- # is unreliable for sparse arrays\n\9\9\9-- Count upwards using ipairs to avoid false positives from the behavior of #\n\9\9\9local arraySize = 0\n\n\9\9\9for _ in ipairs(value) do\n\9\9\9\9arraySize = arraySize + 1\n\9\9\9end\n\n\9\9\9for key in pairs(value) do\n\9\9\9\9if key < 1 or key > arraySize then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9local valueSuccess = valuesCheck(value)\n\9\9\9if not valueSuccess then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\n\n--[[**\n\9\9ensures value is an array of a strict makeup and size\n\n\9\9@param check The check to compare all values with\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.strictArray(...)\n\9\9local valueTypes = { ... }\n\9\9assert(t.array(t.callback)(valueTypes))\n\n\9\9return function(value)\n\9\9\9local keySuccess = arrayKeysCheck(value)\n\9\9\9if keySuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9-- If there's more than the set array size, disallow\n\9\9\9if #valueTypes < #value then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9for idx, typeFn in pairs(valueTypes) do\n\9\9\9\9local typeSuccess = typeFn(value[idx])\n\9\9\9\9if not typeSuccess then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\nend\n\ndo\n\9local callbackArray = t.array(t.callback)\n--[[**\n\9\9creates a union type\n\n\9\9@param ... The checks to union\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.union(...)\n\9\9local checks = { ... }\n\9\9assert(callbackArray(checks))\n\n\9\9return function(value)\n\9\9\9for _, check in ipairs(checks) do\n\9\9\9\9if check(value) then\n\9\9\9\9\9return true\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return false\n\9\9end\n\9end\n\n--[[**\n\9\9Alias for t.union\n\9**--]]\n\9t.some = t.union\n\n--[[**\n\9\9creates an intersection type\n\n\9\9@param ... The checks to intersect\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.intersection(...)\n\9\9local checks = { ... }\n\9\9assert(callbackArray(checks))\n\n\9\9return function(value)\n\9\9\9for _, check in ipairs(checks) do\n\9\9\9\9local success = check(value)\n\9\9\9\9if not success then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\n\n--[[**\n\9\9Alias for t.intersection\n\9**--]]\n\9t.every = t.intersection\nend\n\ndo\n\9local checkInterface = t.map(t.any, t.callback)\n--[[**\n\9\9ensures value matches given interface definition\n\n\9\9@param checkTable The interface definition\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.interface(checkTable)\n\9\9assert(checkInterface(checkTable))\n\9\9return function(value)\n\9\9\9local tableSuccess = t.table(value)\n\9\9\9if tableSuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9for key, check in pairs(checkTable) do\n\9\9\9\9local success = check(value[key])\n\9\9\9\9if success == false then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\n\n--[[**\n\9\9ensures value matches given interface definition strictly\n\n\9\9@param checkTable The interface definition\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.strictInterface(checkTable)\n\9\9assert(checkInterface(checkTable))\n\9\9return function(value)\n\9\9\9local tableSuccess = t.table(value)\n\9\9\9if tableSuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9for key, check in pairs(checkTable) do\n\9\9\9\9local success = check(value[key])\n\9\9\9\9if success == false then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9for key in pairs(value) do\n\9\9\9\9if not checkTable[key] then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\nend\n\n--[[**\n\9ensure value is an Instance and it's ClassName matches the given ClassName\n\n\9@param className The class name to check for\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.instanceOf(className, childTable)\n\9assert(t.string(className))\n\n\9local childrenCheck\n\9if childTable ~= nil then\n\9\9childrenCheck = t.children(childTable)\n\9end\n\n\9return function(value)\n\9\9local instanceSuccess = t.Instance(value)\n\9\9if not instanceSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if value.ClassName ~= className then\n\9\9\9return false\n\9\9end\n\n\9\9if childrenCheck then\n\9\9\9local childrenSuccess = childrenCheck(value)\n\9\9\9if not childrenSuccess then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\nt.instance = t.instanceOf\n\n--[[**\n\9ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison\n\n\9@param className The class name to check for\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.instanceIsA(className, childTable)\n\9assert(t.string(className))\n\n\9local childrenCheck\n\9if childTable ~= nil then\n\9\9childrenCheck = t.children(childTable)\n\9end\n\n\9return function(value)\n\9\9local instanceSuccess = t.Instance(value)\n\9\9if not instanceSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if not value:IsA(className) then\n\9\9\9return false\n\9\9end\n\n\9\9if childrenCheck then\n\9\9\9local childrenSuccess = childrenCheck(value)\n\9\9\9if not childrenSuccess then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is an enum of the correct type\n\n\9@param enum The enum to check\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.enum(enum)\n\9assert(t.Enum(enum))\n\9return function(value)\n\9\9local enumItemSuccess = t.EnumItem(value)\n\9\9if not enumItemSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if value.EnumType == enum then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\ndo\n\9local checkWrap = t.tuple(t.callback, t.callback)\n\n--[[**\n\9\9wraps a callback in an assert with checkArgs\n\n\9\9@param callback The function to wrap\n\9\9@param checkArgs The function to use to check arguments in the assert\n\n\9\9@returns A function that first asserts using checkArgs and then calls callback\n\9**--]]\n\9function t.wrap(callback, checkArgs)\n\9\9assert(checkWrap(callback, checkArgs))\n\9\9return function(...)\n\9\9\9assert(checkArgs(...))\n\9\9\9return callback(...)\n\9\9end\n\9end\nend\n\n--[[**\n\9asserts a given check\n\n\9@param check The function to wrap with an assert\n\n\9@returns A function that simply wraps the given check in an assert\n**--]]\nfunction t.strict(check)\n\9return function(...)\n\9\9assert(check(...))\n\9end\nend\n\ndo\n\9local checkChildren = t.map(t.string, t.callback)\n\n--[[**\n\9\9Takes a table where keys are child names and values are functions to check the children against.\n\9\9Pass an instance tree into the function.\n\9\9If at least one child passes each check, the overall check passes.\n\n\9\9Warning! If you pass in a tree with more than one child of the same name, this function will always return false\n\n\9\9@param checkTable The table to check against\n\n\9\9@returns A function that checks an instance tree\n\9**--]]\n\9function t.children(checkTable)\n\9\9assert(checkChildren(checkTable))\n\n\9\9return function(value)\n\9\9\9local instanceSuccess = t.Instance(value)\n\9\9\9if not instanceSuccess then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9local childrenByName = {}\n\9\9\9for _, child in ipairs(value:GetChildren()) do\n\9\9\9\9local name = child.Name\n\9\9\9\9if checkTable[name] then\n\9\9\9\9\9if childrenByName[name] then\n\9\9\9\9\9\9return false\n\9\9\9\9\9end\n\n\9\9\9\9\9childrenByName[name] = child\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9for name, check in pairs(checkTable) do\n\9\9\9\9local success = check(childrenByName[name])\n\9\9\9\9if not success then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\nend\n\nreturn { t = t }\n", "bundle-ex.include.node_modules.@rbxts.t.lib.ts"))(__env)
end)
__rbx("task-event-emitter", "Folder", "bundle-ex.include.node_modules.@rbxts.task-event-emitter", "bundle-ex.include.node_modules.@rbxts")
__lua("out", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.task-event-emitter.out", "bundle-ex.include.node_modules.@rbxts.task-event-emitter", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.task-event-emitter.out\")local script,require=_.script,_.require --------------------------------------------------------------------------------\13\n--               Batched Yield-Safe Signal Implementation                     --\13\n-- This is a Signal class which has effectively identical behavior to a       --\13\n-- normal RBXScriptSignal, with the only difference being a couple extra      --\13\n-- stack frames at the bottom of the stack trace when an error is thrown.     --\13\n-- This implementation caches runner coroutines, so the ability to yield in   --\13\n-- the signal handlers comes at minimal extra cost over a naive signal        --\13\n-- implementation that either always or never spawns a thread.                --\13\n--                                                                            --\13\n-- API:                                                                       --\13\n--   local Signal = require(THIS MODULE)                                      --\13\n--   local sig = Signal.new()                                                 --\13\n--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --\13\n--   sig:Fire(arg1, arg2, ...)                                                --\13\n--   connection:Disconnect()                                                  --\13\n--   sig:DisconnectAll()                                                      --\13\n--   local arg1, arg2, ... = sig:Wait()                                       --\13\n--                                                                            --\13\n-- Licence:                                                                   --\13\n--   Licenced under the MIT licence.                                          --\13\n--                                                                            --\13\n-- Authors:                                                                   --\13\n--   stravant - July 31st, 2021 - Created the file.                           --\13\n--   littensy - August 2nd, 2021 - Literally only renamed it                  --\13\n--------------------------------------------------------------------------------\13\n\13\n-- The currently idle thread to run the next handler on\13\nlocal freeRunnerThread = nil\13\n\13\n-- Promise library\13\nlocal Promise = _G[script].Promise\13\n\13\n-- Function which acquires the currently idle handler runner thread, runs the\13\n-- function fn on it, and then releases the thread, returning it to being the\13\n-- currently idle one.\13\n-- If there was a currently idle runner thread already, that's okay, that old\13\n-- one will just get thrown and eventually GCed.\13\nlocal function acquireRunnerThreadAndCallEventHandler(fn, ...)\13\n\9local acquiredRunnerThread = freeRunnerThread\13\n\9freeRunnerThread = nil\13\n\9fn(...)\13\n\9-- The handler finished running, this runner thread is free again.\13\n\9freeRunnerThread = acquiredRunnerThread\13\nend\13\n\13\n-- Coroutine runner that we create coroutines of. The coroutine can be \13\n-- repeatedly resumed with functions to run followed by the argument to run\13\n-- them with.\13\nlocal function runEventHandlerInFreeThread(...)\13\n\9acquireRunnerThreadAndCallEventHandler(...)\13\n\9while true do\13\n\9\9acquireRunnerThreadAndCallEventHandler(coroutine.yield())\13\n\9end\13\nend\13\n\13\n-- Connection class\13\nlocal Subscription = {}\13\nSubscription.__index = Subscription\13\n\13\nfunction Subscription.new(signal, fn)\13\n\9return setmetatable({\13\n\9\9closed = false,\13\n\9\9Connected = true, -- alias for trove compatibility\13\n\9\9_signal = signal,\13\n\9\9_fn = fn,\13\n\9\9_next = false,\13\n\9}, Subscription)\13\nend\13\n\13\nfunction Subscription:unsubscribe()\13\n\9if self.closed then\13\n\9\9return\13\n\9end\13\n\13\n\9self.closed = true\13\n\9self.Connected = false\13\n\13\n\9-- Unhook the node, but DON'T clear it. That way any fire calls that are\13\n\9-- currently sitting on this node will be able to iterate forwards off of\13\n\9-- it, but any subsequent fire calls will not hit it, and it will be GCed\13\n\9-- when no more fire calls are sitting on it.\13\n\9if self._signal._handlerListHead == self then\13\n\9\9self._signal._handlerListHead = self._next\13\n\9else\13\n\9\9local prev = self._signal._handlerListHead\13\n\9\9while prev and prev._next ~= self do\13\n\9\9\9prev = prev._next\13\n\9\9end\13\n\9\9if prev then\13\n\9\9\9prev._next = self._next\13\n\9\9end\13\n\9end\13\nend\13\n\13\nSubscription.Disconnect = Subscription.unsubscribe\13\nSubscription.Destroy = Subscription.unsubscribe\13\n\13\n-- Make Connection strict\13\nsetmetatable(Subscription, {\13\n\9__index = function(tb, key)\13\n\9\9error((\"Attempt to get Connection::%s (not a valid member)\"):format(tostring(key)), 2)\13\n\9end,\13\n\9__newindex = function(tb, key, value)\13\n\9\9error((\"Attempt to set Connection::%s (not a valid member)\"):format(tostring(key)), 2)\13\n\9end\13\n})\13\n\13\n-- Signal class\13\nlocal EventEmitter = {}\13\nEventEmitter.__index = EventEmitter\13\n\13\nfunction EventEmitter.new(janitor)\13\n\9local self = setmetatable({\13\n\9\9_handlerListHead = false,\13\n\9\9_proxyHandler = nil,\13\n\9}, EventEmitter)\13\n\9if janitor then\13\n\9\9if janitor.Add then\13\n\9\9\9janitor:Add(self)\13\n\9\9elseif janitor.add then\13\n\9\9\9janitor:add(self)\13\n\9\9end\13\n\9end\13\n\9return self\13\nend\13\n\13\nfunction EventEmitter.wrap(rbxScriptSignal, janitor)\13\n\9assert(typeof(rbxScriptSignal) == \"RBXScriptSignal\", \"Argument #1 to EventEmitter.wrap must be a RBXScriptSignal; got \" .. typeof(rbxScriptSignal))\13\n\9local emitter = EventEmitter.new(janitor)\13\n\9emitter._proxyHandler = rbxScriptSignal:Connect(function(...)\13\n\9\9emitter:emit(...)\13\n\9end)\13\n\9return emitter\13\nend\13\n\13\nfunction EventEmitter:subscribe(fn)\13\n\9local subscription = Subscription.new(self, fn)\13\n\9if self._handlerListHead then\13\n\9\9subscription._next = self._handlerListHead\13\n\9\9self._handlerListHead = subscription\13\n\9else\13\n\9\9self._handlerListHead = subscription\13\n\9end\13\n\9return subscription\13\nend\13\n\13\nfunction EventEmitter:subscribeOnce(fn)\13\n\9local cn;\13\n\9cn = self:subscribe(function (...)\13\n\9\9cn:unsubscribe()\13\n\9\9fn(...)\13\n\9end)\13\n\9return cn\13\nend\13\n\13\nfunction EventEmitter:promisify(predicate)\13\n\9return Promise.fromEvent(self, predicate)\13\nend\13\n\13\nfunction EventEmitter:once()\13\n\9return Promise.new(function (resolve)\13\n\9\9local cn;\13\n\9\9cn = self:subscribe(function (...)\13\n\9\9\9cn:unsubscribe()\13\n\9\9\9resolve(...)\13\n\9\9end)\13\n\9end)\13\nend\13\n\13\n-- Disconnect all handlers. Since we use a linked list it suffices to clear the\13\n-- reference to the head handler.\13\nfunction EventEmitter:unsubscribeAll()\13\n\9self._handlerListHead = false\13\nend\13\n\13\nfunction EventEmitter:destroy()\13\n\9self:unsubscribeAll();\13\n\9local proxyHandler = rawget(self, \"_proxyHandler\")\13\n\9if proxyHandler then\13\n\9\9proxyHandler:Disconnect()\13\n\9end\13\nend\13\n\13\n-- Signal:Fire(...) implemented by running the handler functions on the\13\n-- coRunnerThread, and any time the resulting thread yielded without returning\13\n-- to us, that means that it yielded to the Roblox scheduler and has been taken\13\n-- over by Roblox scheduling, meaning we have to make a new coroutine runner.\13\nfunction EventEmitter:emit(...)\13\n\9local item = self._handlerListHead\13\n\9while item do\13\n\9\9if not item.closed then\13\n\9\9\9if not freeRunnerThread then\13\n\9\9\9\9freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)\13\n\9\9\9end\13\n\9\9\9task.spawn(freeRunnerThread, item._fn, ...)\13\n\9\9end\13\n\9\9item = item._next\13\n\9end\13\nend\13\n\13\n-- Implement Signal:Wait() in terms of a temporary connection using\13\n-- a Signal:Connect() which disconnects itself.\13\nfunction EventEmitter:wait()\13\n\9local waitingCoroutine = coroutine.running()\13\n\9local cn;\13\n\9cn = self:subscribe(function(...)\13\n\9\9cn:unsubscribe()\13\n\9\9task.spawn(waitingCoroutine, ...)\13\n\9end)\13\n\9return coroutine.yield()\13\nend\13\n\13\nEventEmitter.Connect = EventEmitter.subscribe\13\nEventEmitter.Destroy = EventEmitter.destroy\13\nEventEmitter.Wait = EventEmitter.wait\13\n\13\n-- Make signal strict\13\nsetmetatable(EventEmitter, {\13\n\9__index = function(tb, key)\13\n\9\9error((\"Attempt to get EventEmitter::%s (not a valid member)\"):format(tostring(key)), 2)\13\n\9end,\13\n\9__newindex = function(tb, key, value)\13\n\9\9error((\"Attempt to set EventEmitter::%s (not a valid member)\"):format(tostring(key)), 2)\13\n\9end\13\n})\13\n\13\nreturn EventEmitter\13\n", "bundle-ex.include.node_modules.@rbxts.task-event-emitter.out"))(__env)
end)
__rbx("types", "Folder", "bundle-ex.include.node_modules.@rbxts.types", "bundle-ex.include.node_modules.@rbxts")
__rbx("include", "Folder", "bundle-ex.include.node_modules.@rbxts.types.include", "bundle-ex.include.node_modules.@rbxts.types")
__rbx("generated", "Folder", "bundle-ex.include.node_modules.@rbxts.types.include.generated", "bundle-ex.include.node_modules.@rbxts.types.include")
__start()
