--[[
-- Hello! This is an example project that bundles the Roblox-TS source into a
-- single file and uploads it to a GitHub release.
--
-- This script was generated by ci/bundle.lua, and should not be modified by hand.
-- To regenerate the code, run 'pnpm bundle' in the root directory.
--
-- Author: 0866
-- Source: https://github.com/richie0866/rbxts-bundle-example
--]]

-- Runtime library
local instances = {}
local modules = {}
local currentlyLoading = {}

local function runModule(object, context)
	currentlyLoading[context] = object

	local currentObject = object
	local depth = 0

	while currentObject do
		depth = depth + 1
		currentObject = currentlyLoading[currentObject]

		if currentObject == object then
			local str = currentObject.Name -- Get the string traceback

			for _ = 1, depth do
				currentObject = currentlyLoading[currentObject]
				str = str .. "  â‡’ " .. currentObject.Name
			end

			error("Failed to load '" .. object.Name .. "'; Detected a circular dependency chain: " .. str, 2)
		end
	end

	local module = modules[object]
	local data = module.callback()

	if currentlyLoading[context] == object then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

local function requireModule(object, context)
	local module = modules[object]

	if module.loaded then
		return module.result
	else
		module.result = runModule(object, context)
		module.loaded = true
		return module.result
	end
end

local function __rbx(name, className, path, parentPath)
	local rbx = Instance.new(className)
	rbx.Name = name
	rbx.Parent = instances[parentPath]
	instances[path] = rbx
	return rbx
end

local function __lua(name, className, path, parentPath, callback)
	local rbx = __rbx(name, className, path, parentPath)

	modules[rbx] = {
		callback = callback,
		result = nil,
		loaded = false,
		globals = {
			script = rbx,
			require = function(object)
				if modules[object] then
					return requireModule(object, rbx)
				else
					return require(object)
				end
			end,
		},
	}
end

local function __env(path)
	return modules[instances[path]].globals
end

local function __start()
	for rbx, module in pairs(modules) do
		if rbx.ClassName == "LocalScript" and not rbx.Disabled then
			task.spawn(module.callback)
		end
	end
end

-- Generated by ci/bundle.lua
__rbx("bundle-ex", "Folder", "bundle-ex", nil)
__rbx("game", "Folder", "bundle-ex.game", "bundle-ex")
__rbx("src", "Folder", "bundle-ex.game.src", "bundle-ex.game")
__lua("main", "LocalScript", "bundle-ex.game.src.main", "bundle-ex.game.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.game.src.main\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal TS = require(script.Parent.Parent.Parent.include.RuntimeLib)\nlocal Reflect = TS.import(script, script.Parent.Parent.Parent, \"include\", \"node_modules\", \"@flamework\", \"core\", \"out\").Reflect\nlocal makeHello = TS.import(script, script.Parent.Parent.Parent, \"shared\", \"src\", \"module\").makeHello\nlocal _core = TS.import(script, script.Parent.Parent.Parent, \"include\", \"node_modules\", \"@flamework\", \"core\", \"out\")\nlocal Flamework = _core.Flamework\nlocal Service = _core.Service\nlocal Controller = _core.Controller\nlocal MainService\ndo\n\9MainService = setmetatable({}, {\n\9\9__tostring = function()\n\9\9\9return \"MainService\"\n\9\9end,\n\9})\n\9MainService.__index = MainService\n\9function MainService.new(...)\n\9\9local self = setmetatable({}, MainService)\n\9\9return self:constructor(...) or self\n\9end\n\9function MainService:constructor()\n\9end\n\9function MainService:onInit()\n\9\9print(\"init mainservice\")\n\9end\n\9function MainService:myMethod()\n\9\9return \"mainservice myMethod\"\n\9end\nend\n-- (Flamework) MainService metadata\nReflect.defineMetadata(MainService, \"identifier\", \"game/src/main.client@MainService\")\nReflect.defineMetadata(MainService, \"flamework:implements\", { \"$:flamework@OnInit\" })\nReflect.decorate(MainService, \"$:flamework@Service\", Service, {})\nlocal MainController\ndo\n\9MainController = setmetatable({}, {\n\9\9__tostring = function()\n\9\9\9return \"MainController\"\n\9\9end,\n\9})\n\9MainController.__index = MainController\n\9function MainController.new(...)\n\9\9local self = setmetatable({}, MainController)\n\9\9return self:constructor(...) or self\n\9end\n\9function MainController:constructor(mainService)\n\9\9self.mainService = mainService\n\9end\n\9function MainController:onInit()\n\9\9print(\"init maincontroller\")\n\9\9print(self.mainService:myMethod())\n\9end\nend\n-- (Flamework) MainController metadata\nReflect.defineMetadata(MainController, \"identifier\", \"game/src/main.client@MainController\")\nReflect.defineMetadata(MainController, \"flamework:parameters\", { \"game/src/main.client@MainService\" })\nReflect.defineMetadata(MainController, \"flamework:implements\", { \"$:flamework@OnInit\" })\nReflect.decorate(MainController, \"$:flamework@Controller\", Controller, {})\nFlamework.ignite()\nprint(makeHello(\"client\"))\nreturn {\n\9MainService = MainService,\n\9MainController = MainController,\n}\n", "bundle-ex.game.src.main"))(__env)
end)
__rbx("shared", "Folder", "bundle-ex.shared", "bundle-ex")
__rbx("src", "Folder", "bundle-ex.shared.src", "bundle-ex.shared")
__lua("module", "ModuleScript", "bundle-ex.shared.src.module", "bundle-ex.shared.src", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.shared.src.module\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.1.0\nlocal function makeHello(name)\n\9return \"Hello \" .. (name .. \"!\")\nend\nreturn {\n\9makeHello = makeHello,\n}\n", "bundle-ex.shared.src.module"))(__env)
end)
__rbx("include", "Folder", "bundle-ex.include", "bundle-ex")
__lua("Promise", "ModuleScript", "bundle-ex.include.Promise", "bundle-ex.include", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.Promise\")local script,require=_.script,_.require --[[\n\9An implementation of Promises similar to Promise/A+.\n]]\n\nlocal ERROR_NON_PROMISE_IN_LIST = \"Non-promise value passed into %s at index %s\"\nlocal ERROR_NON_LIST = \"Please pass a list of promises to %s\"\nlocal ERROR_NON_FUNCTION = \"Please pass a handler function to %s!\"\nlocal MODE_KEY_METATABLE = { __mode = \"k\" }\n\nlocal function isCallable(value)\n\9if type(value) == \"function\" then\n\9\9return true\n\9end\n\n\9if type(value) == \"table\" then\n\9\9local metatable = getmetatable(value)\n\9\9if metatable and type(rawget(metatable, \"__call\")) == \"function\" then\n\9\9\9return true\n\9\9end\n\9end\n\n\9return false\nend\n\n--[[\n\9Creates an enum dictionary with some metamethods to prevent common mistakes.\n]]\nlocal function makeEnum(enumName, members)\n\9local enum = {}\n\n\9for _, memberName in ipairs(members) do\n\9\9enum[memberName] = memberName\n\9end\n\n\9return setmetatable(enum, {\n\9\9__index = function(_, k)\n\9\9\9error(string.format(\"%s is not in %s!\", k, enumName), 2)\n\9\9end,\n\9\9__newindex = function()\n\9\9\9error(string.format(\"Creating new members in %s is not allowed!\", enumName), 2)\n\9\9end,\n\9})\nend\n\n--[=[\n\9An object to represent runtime errors that occur during execution.\n\9Promises that experience an error like this will be rejected with\n\9an instance of this object.\n\n\9@class Error\n]=]\nlocal Error\ndo\n\9Error = {\n\9\9Kind = makeEnum(\"Promise.Error.Kind\", {\n\9\9\9\"ExecutionError\",\n\9\9\9\"AlreadyCancelled\",\n\9\9\9\"NotResolvedInTime\",\n\9\9\9\"TimedOut\",\n\9\9}),\n\9}\n\9Error.__index = Error\n\n\9function Error.new(options, parent)\n\9\9options = options or {}\n\9\9return setmetatable({\n\9\9\9error = tostring(options.error) or \"[This error has no error text.]\",\n\9\9\9trace = options.trace,\n\9\9\9context = options.context,\n\9\9\9kind = options.kind,\n\9\9\9parent = parent,\n\9\9\9createdTick = os.clock(),\n\9\9\9createdTrace = debug.traceback(),\n\9\9}, Error)\n\9end\n\n\9function Error.is(anything)\n\9\9if type(anything) == \"table\" then\n\9\9\9local metatable = getmetatable(anything)\n\n\9\9\9if type(metatable) == \"table\" then\n\9\9\9\9return rawget(anything, \"error\") ~= nil and type(rawget(metatable, \"extend\")) == \"function\"\n\9\9\9end\n\9\9end\n\n\9\9return false\n\9end\n\n\9function Error.isKind(anything, kind)\n\9\9assert(kind ~= nil, \"Argument #2 to Promise.Error.isKind must not be nil\")\n\n\9\9return Error.is(anything) and anything.kind == kind\n\9end\n\n\9function Error:extend(options)\n\9\9options = options or {}\n\n\9\9options.kind = options.kind or self.kind\n\n\9\9return Error.new(options, self)\n\9end\n\n\9function Error:getErrorChain()\n\9\9local runtimeErrors = { self }\n\n\9\9while runtimeErrors[#runtimeErrors].parent do\n\9\9\9table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)\n\9\9end\n\n\9\9return runtimeErrors\n\9end\n\n\9function Error:__tostring()\n\9\9local errorStrings = {\n\9\9\9string.format(\"-- Promise.Error(%s) --\", self.kind or \"?\"),\n\9\9}\n\n\9\9for _, runtimeError in ipairs(self:getErrorChain()) do\n\9\9\9table.insert(\n\9\9\9\9errorStrings,\n\9\9\9\9table.concat({\n\9\9\9\9\9runtimeError.trace or runtimeError.error,\n\9\9\9\9\9runtimeError.context,\n\9\9\9\9}, \"\\n\")\n\9\9\9)\n\9\9end\n\n\9\9return table.concat(errorStrings, \"\\n\")\n\9end\nend\n\n--[[\n\9Packs a number of arguments into a table and returns its length.\n\n\9Used to cajole varargs without dropping sparse values.\n]]\nlocal function pack(...)\n\9return select(\"#\", ...), { ... }\nend\n\n--[[\n\9Returns first value (success), and packs all following values.\n]]\nlocal function packResult(success, ...)\n\9return success, select(\"#\", ...), { ... }\nend\n\nlocal function makeErrorHandler(traceback)\n\9assert(traceback ~= nil, \"traceback is nil\")\n\n\9return function(err)\n\9\9-- If the error object is already a table, forward it directly.\n\9\9-- Should we extend the error here and add our own trace?\n\n\9\9if type(err) == \"table\" then\n\9\9\9return err\n\9\9end\n\n\9\9return Error.new({\n\9\9\9error = err,\n\9\9\9kind = Error.Kind.ExecutionError,\n\9\9\9trace = debug.traceback(tostring(err), 2),\n\9\9\9context = \"Promise created at:\\n\\n\" .. traceback,\n\9\9})\n\9end\nend\n\n--[[\n\9Calls a Promise executor with error handling.\n]]\nlocal function runExecutor(traceback, callback, ...)\n\9return packResult(xpcall(callback, makeErrorHandler(traceback), ...))\nend\n\n--[[\n\9Creates a function that invokes a callback with correct error handling and\n\9resolution mechanisms.\n]]\nlocal function createAdvancer(traceback, callback, resolve, reject)\n\9return function(...)\n\9\9local ok, resultLength, result = runExecutor(traceback, callback, ...)\n\n\9\9if ok then\n\9\9\9resolve(unpack(result, 1, resultLength))\n\9\9else\n\9\9\9reject(result[1])\n\9\9end\n\9end\nend\n\nlocal function isEmpty(t)\n\9return next(t) == nil\nend\n\n--[=[\n\9An enum value used to represent the Promise's status.\n\9@interface Status\n\9@tag enum\n\9@within Promise\n\9.Started \"Started\" -- The Promise is executing, and not settled yet.\n\9.Resolved \"Resolved\" -- The Promise finished successfully.\n\9.Rejected \"Rejected\" -- The Promise was rejected.\n\9.Cancelled \"Cancelled\" -- The Promise was cancelled before it finished.\n]=]\n--[=[\n\9@prop Status Status\n\9@within Promise\n\9@readonly\n\9@tag enums\n\9A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.\n]=]\n--[=[\n\9A Promise is an object that represents a value that will exist in the future, but doesn't right now.\n\9Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),\n\9or if an error has occurred (known as *rejecting*).\n\n\9@class Promise\n\9@__index prototype\n]=]\nlocal Promise = {\n\9Error = Error,\n\9Status = makeEnum(\"Promise.Status\", { \"Started\", \"Resolved\", \"Rejected\", \"Cancelled\" }),\n\9_getTime = os.clock,\n\9_timeEvent = game:GetService(\"RunService\").Heartbeat,\n\9_unhandledRejectionCallbacks = {},\n}\nPromise.prototype = {}\nPromise.__index = Promise.prototype\n\nfunction Promise._new(traceback, callback, parent)\n\9if parent ~= nil and not Promise.is(parent) then\n\9\9error(\"Argument #2 to Promise.new must be a promise or nil\", 2)\n\9end\n\n\9local self = {\n\9\9-- Used to locate where a promise was created\n\9\9_source = traceback,\n\n\9\9_status = Promise.Status.Started,\n\n\9\9-- A table containing a list of all results, whether success or failure.\n\9\9-- Only valid if _status is set to something besides Started\n\9\9_values = nil,\n\n\9\9-- Lua doesn't like sparse arrays very much, so we explicitly store the\n\9\9-- length of _values to handle middle nils.\n\9\9_valuesLength = -1,\n\n\9\9-- Tracks if this Promise has no error observers..\n\9\9_unhandledRejection = true,\n\n\9\9-- Queues representing functions we should invoke when we update!\n\9\9_queuedResolve = {},\n\9\9_queuedReject = {},\n\9\9_queuedFinally = {},\n\n\9\9-- The function to run when/if this promise is cancelled.\n\9\9_cancellationHook = nil,\n\n\9\9-- The \"parent\" of this promise in a promise chain. Required for\n\9\9-- cancellation propagation upstream.\n\9\9_parent = parent,\n\n\9\9-- Consumers are Promises that have chained onto this one.\n\9\9-- We track them for cancellation propagation downstream.\n\9\9_consumers = setmetatable({}, MODE_KEY_METATABLE),\n\9}\n\n\9if parent and parent._status == Promise.Status.Started then\n\9\9parent._consumers[self] = true\n\9end\n\n\9setmetatable(self, Promise)\n\n\9local function resolve(...)\n\9\9self:_resolve(...)\n\9end\n\n\9local function reject(...)\n\9\9self:_reject(...)\n\9end\n\n\9local function onCancel(cancellationHook)\n\9\9if cancellationHook then\n\9\9\9if self._status == Promise.Status.Cancelled then\n\9\9\9\9cancellationHook()\n\9\9\9else\n\9\9\9\9self._cancellationHook = cancellationHook\n\9\9\9end\n\9\9end\n\n\9\9return self._status == Promise.Status.Cancelled\n\9end\n\n\9coroutine.wrap(function()\n\9\9local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)\n\n\9\9if not ok then\n\9\9\9reject(result[1])\n\9\9end\n\9end)()\n\n\9return self\nend\n\n--[=[\n\9Construct a new Promise that will be resolved or rejected with the given callbacks.\n\n\9If you `resolve` with a Promise, it will be chained onto.\n\n\9You can safely yield within the executor function and it will not block the creating thread.\n\n\9```lua\n\9local myFunction()\n\9\9return Promise.new(function(resolve, reject, onCancel)\n\9\9\9wait(1)\n\9\9\9resolve(\"Hello world!\")\n\9\9end)\n\9end\n\n\9myFunction():andThen(print)\n\9```\n\n\9You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.\n\n\9You may register an optional cancellation hook by using the `onCancel` argument:\n\n\9* This should be used to abort any ongoing operations leading up to the promise being settled.\n\9* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.\n\9* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.\n\9* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.\n\9* You can set the cancellation hook at any time before resolving.\n\9* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.\n\n\9@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\9@return Promise\n]=]\nfunction Promise.new(executor)\n\9return Promise._new(debug.traceback(nil, 2), executor)\nend\n\nfunction Promise:__tostring()\n\9return string.format(\"Promise(%s)\", self._status)\nend\n\n--[=[\n\9The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.\n\n\9This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.\n\n\9```lua\n\9local function waitForChild(instance, childName, timeout)\n\9  return Promise.defer(function(resolve, reject)\n\9\9local child = instance:WaitForChild(childName, timeout)\n\n\9\9;(child and resolve or reject)(child)\n\9  end)\n\9end\n\9```\n\n\9@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\9@return Promise\n]=]\nfunction Promise.defer(executor)\n\9local traceback = debug.traceback(nil, 2)\n\9local promise\n\9promise = Promise._new(traceback, function(resolve, reject, onCancel)\n\9\9local connection\n\9\9connection = Promise._timeEvent:Connect(function()\n\9\9\9connection:Disconnect()\n\9\9\9local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)\n\n\9\9\9if not ok then\n\9\9\9\9reject(result[1])\n\9\9\9end\n\9\9end)\n\9end)\n\n\9return promise\nend\n\n-- Backwards compatibility\nPromise.async = Promise.defer\n\n--[=[\n\9Creates an immediately resolved Promise with the given value.\n\n\9```lua\n\9-- Example using Promise.resolve to deliver cached values:\n\9function getSomething(name)\n\9\9if cache[name] then\n\9\9\9return Promise.resolve(cache[name])\n\9\9else\n\9\9\9return Promise.new(function(resolve, reject)\n\9\9\9\9local thing = getTheThing()\n\9\9\9\9cache[name] = thing\n\n\9\9\9\9resolve(thing)\n\9\9\9end)\n\9\9end\n\9end\n\9```\n\n\9@param ... any\n\9@return Promise<...any>\n]=]\nfunction Promise.resolve(...)\n\9local length, values = pack(...)\n\9return Promise._new(debug.traceback(nil, 2), function(resolve)\n\9\9resolve(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Creates an immediately rejected Promise with the given value.\n\n\9:::caution\n\9Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.\n\9:::\n\n\9@param ... any\n\9@return Promise<...any>\n]=]\nfunction Promise.reject(...)\n\9local length, values = pack(...)\n\9return Promise._new(debug.traceback(nil, 2), function(_, reject)\n\9\9reject(unpack(values, 1, length))\n\9end)\nend\n\n--[[\n\9Runs a non-promise-returning function as a Promise with the\n  given arguments.\n]]\nfunction Promise._try(traceback, callback, ...)\n\9local valuesLength, values = pack(...)\n\n\9return Promise._new(traceback, function(resolve)\n\9\9resolve(callback(unpack(values, 1, valuesLength)))\n\9end)\nend\n\n--[=[\n\9Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.\n\n\9:::info\n\9`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.\n\9:::\n\n\9```lua\n\9Promise.try(function()\n\9\9return math.random(1, 2) == 1 and \"ok\" or error(\"Oh an error!\")\n\9end)\n\9\9:andThen(function(text)\n\9\9\9print(text)\n\9\9end)\n\9\9:catch(function(err)\n\9\9\9warn(\"Something went wrong\")\n\9\9end)\n\9```\n\n\9@param callback (...: T...) -> ...any\n\9@param ... T... -- Additional arguments passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.try(callback, ...)\n\9return Promise._try(debug.traceback(nil, 2), callback, ...)\nend\n\n--[[\n\9Returns a new promise that:\n\9\9* is resolved when all input promises resolve\n\9\9* is rejected if ANY input promises reject\n]]\nfunction Promise._all(traceback, promises, amount)\n\9if type(promises) ~= \"table\" then\n\9\9error(string.format(ERROR_NON_LIST, \"Promise.all\"), 3)\n\9end\n\n\9-- We need to check that each value is a promise here so that we can produce\n\9-- a proper error rather than a rejected promise with our error.\n\9for i, promise in pairs(promises) do\n\9\9if not Promise.is(promise) then\n\9\9\9error(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.all\", tostring(i)), 3)\n\9\9end\n\9end\n\n\9-- If there are no values then return an already resolved promise.\n\9if #promises == 0 or amount == 0 then\n\9\9return Promise.resolve({})\n\9end\n\n\9return Promise._new(traceback, function(resolve, reject, onCancel)\n\9\9-- An array to contain our resolved values from the given promises.\n\9\9local resolvedValues = {}\n\9\9local newPromises = {}\n\n\9\9-- Keep a count of resolved promises because just checking the resolved\n\9\9-- values length wouldn't account for promises that resolve with nil.\n\9\9local resolvedCount = 0\n\9\9local rejectedCount = 0\n\9\9local done = false\n\n\9\9local function cancel()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end\n\n\9\9-- Called when a single value is resolved and resolves if all are done.\n\9\9local function resolveOne(i, ...)\n\9\9\9if done then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9resolvedCount = resolvedCount + 1\n\n\9\9\9if amount == nil then\n\9\9\9\9resolvedValues[i] = ...\n\9\9\9else\n\9\9\9\9resolvedValues[resolvedCount] = ...\n\9\9\9end\n\n\9\9\9if resolvedCount >= (amount or #promises) then\n\9\9\9\9done = true\n\9\9\9\9resolve(resolvedValues)\n\9\9\9\9cancel()\n\9\9\9end\n\9\9end\n\n\9\9onCancel(cancel)\n\n\9\9-- We can assume the values inside `promises` are all promises since we\n\9\9-- checked above.\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:andThen(function(...)\n\9\9\9\9resolveOne(i, ...)\n\9\9\9end, function(...)\n\9\9\9\9rejectedCount = rejectedCount + 1\n\n\9\9\9\9if amount == nil or #promises - rejectedCount < amount then\n\9\9\9\9\9cancel()\n\9\9\9\9\9done = true\n\n\9\9\9\9\9reject(...)\n\9\9\9\9end\n\9\9\9end)\n\9\9end\n\n\9\9if done then\n\9\9\9cancel()\n\9\9end\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new promise that:\n\9* is resolved after all input promises resolve.\n\9* is rejected if *any* input promises reject.\n\n\9:::info\n\9Only the first return value from each promise will be present in the resulting array.\n\9:::\n\n\9After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.all(promises)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<{T}>\n]=]\nfunction Promise.all(promises)\n\9return Promise._all(debug.traceback(nil, 2), promises)\nend\n\n--[=[\n\9Folds an array of values or promises into a single value. The array is traversed sequentially.\n\n\9The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.\n\n\9The folding will stop at the first rejection encountered.\n\9```lua\n\9local basket = {\"blueberry\", \"melon\", \"pear\", \"melon\"}\n\9Promise.fold(basket, function(cost, fruit)\n\9\9if fruit == \"blueberry\" then\n\9\9\9return cost -- blueberries are free!\n\9\9else\n\9\9\9-- call a function that returns a promise with the fruit price\n\9\9\9return fetchPrice(fruit):andThen(function(fruitCost)\n\9\9\9\9return cost + fruitCost\n\9\9\9end)\n\9\9end\n\9end, 0)\n\9```\n\n\9@since v3.1.0\n\9@param list {T | Promise<T>}\n\9@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>\n\9@param initialValue U\n]=]\nfunction Promise.fold(list, reducer, initialValue)\n\9assert(type(list) == \"table\", \"Bad argument #1 to Promise.fold: must be a table\")\n\9assert(isCallable(reducer), \"Bad argument #2 to Promise.fold: must be a function\")\n\n\9local accumulator = Promise.resolve(initialValue)\n\9return Promise.each(list, function(resolvedElement, i)\n\9\9accumulator = accumulator:andThen(function(previousValueResolved)\n\9\9\9return reducer(previousValueResolved, resolvedElement, i)\n\9\9end)\n\9end):andThen(function()\n\9\9return accumulator\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\9`count` 0 results in an empty array. The resultant array will never have more than `count` elements.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve\n\9```\n\n\9@param promises {Promise<T>}\n\9@param count number\n\9@return Promise<{T}>\n]=]\nfunction Promise.some(promises, count)\n\9assert(type(count) == \"number\", \"Bad argument #2 to Promise.some: must be a number\")\n\n\9return Promise._all(debug.traceback(nil, 2), promises, count)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\9Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<T>\n]=]\nfunction Promise.any(promises)\n\9return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)\n\9\9return values[1]\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.allSettled(promises)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<{Status}>\n]=]\nfunction Promise.allSettled(promises)\n\9if type(promises) ~= \"table\" then\n\9\9error(string.format(ERROR_NON_LIST, \"Promise.allSettled\"), 2)\n\9end\n\n\9-- We need to check that each value is a promise here so that we can produce\n\9-- a proper error rather than a rejected promise with our error.\n\9for i, promise in pairs(promises) do\n\9\9if not Promise.is(promise) then\n\9\9\9error(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.allSettled\", tostring(i)), 2)\n\9\9end\n\9end\n\n\9-- If there are no values then return an already resolved promise.\n\9if #promises == 0 then\n\9\9return Promise.resolve({})\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9-- An array to contain our resolved values from the given promises.\n\9\9local fates = {}\n\9\9local newPromises = {}\n\n\9\9-- Keep a count of resolved promises because just checking the resolved\n\9\9-- values length wouldn't account for promises that resolve with nil.\n\9\9local finishedCount = 0\n\n\9\9-- Called when a single value is resolved and resolves if all are done.\n\9\9local function resolveOne(i, ...)\n\9\9\9finishedCount = finishedCount + 1\n\n\9\9\9fates[i] = ...\n\n\9\9\9if finishedCount >= #promises then\n\9\9\9\9resolve(fates)\n\9\9\9end\n\9\9end\n\n\9\9onCancel(function()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end)\n\n\9\9-- We can assume the values inside `promises` are all promises since we\n\9\9-- checked above.\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:finally(function(...)\n\9\9\9\9resolveOne(i, ...)\n\9\9\9end)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.\n\n\9:::warning\n\9If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.\n\n\9If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.\n\9:::\n\n\9All other Promises that don't win the race will be cancelled if they have no other consumers.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.race(promises) -- Only returns 1st value to resolve or reject\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<T>\n]=]\nfunction Promise.race(promises)\n\9assert(type(promises) == \"table\", string.format(ERROR_NON_LIST, \"Promise.race\"))\n\n\9for i, promise in pairs(promises) do\n\9\9assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.race\", tostring(i)))\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\9\9local newPromises = {}\n\9\9local finished = false\n\n\9\9local function cancel()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end\n\n\9\9local function finalize(callback)\n\9\9\9return function(...)\n\9\9\9\9cancel()\n\9\9\9\9finished = true\n\9\9\9\9return callback(...)\n\9\9\9end\n\9\9end\n\n\9\9if onCancel(finalize(reject)) then\n\9\9\9return\n\9\9end\n\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))\n\9\9end\n\n\9\9if finished then\n\9\9\9cancel()\n\9\9end\n\9end)\nend\n\n--[=[\n\9Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.\n\n\9If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item\n\9in the array.\n\n\9:::info\n\9`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.\n\n\9But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.\n\n\9The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.\n\9:::\n\n\9```lua\n\9Promise.each({\n\9\9\"foo\",\n\9\9\"bar\",\n\9\9\"baz\",\n\9\9\"qux\"\n\9}, function(value, index)\n\9\9return Promise.delay(1):andThen(function()\n\9\9print((\"%d) Got %s!\"):format(index, value))\n\9\9end)\n\9end)\n\n\9--[[\n\9\9(1 second passes)\n\9\9> 1) Got foo!\n\9\9(1 second passes)\n\9\9> 2) Got bar!\n\9\9(1 second passes)\n\9\9> 3) Got baz!\n\9\9(1 second passes)\n\9\9> 4) Got qux!\n\9]]\n\9```\n\n\9If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.\n\n\9If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.\n\n\9If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.\n\n\9Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.\n\n\9If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:\n\9- Iteration will not continue.\n\9- Any Promises within the array of values will now be cancelled if they have no other consumers.\n\9- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.\n\n\9@since 3.0.0\n\9@param list {T | Promise<T>}\n\9@param predicate (value: T, index: number) -> U | Promise<U>\n\9@return Promise<{U}>\n]=]\nfunction Promise.each(list, predicate)\n\9assert(type(list) == \"table\", string.format(ERROR_NON_LIST, \"Promise.each\"))\n\9assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, \"Promise.each\"))\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\9\9local results = {}\n\9\9local promisesToCancel = {}\n\n\9\9local cancelled = false\n\n\9\9local function cancel()\n\9\9\9for _, promiseToCancel in ipairs(promisesToCancel) do\n\9\9\9\9promiseToCancel:cancel()\n\9\9\9end\n\9\9end\n\n\9\9onCancel(function()\n\9\9\9cancelled = true\n\n\9\9\9cancel()\n\9\9end)\n\n\9\9-- We need to preprocess the list of values and look for Promises.\n\9\9-- If we find some, we must register our andThen calls now, so that those Promises have a consumer\n\9\9-- from us registered. If we don't do this, those Promises might get cancelled by something else\n\9\9-- before we get to them in the series because it's not possible to tell that we plan to use it\n\9\9-- unless we indicate it here.\n\n\9\9local preprocessedList = {}\n\n\9\9for index, value in ipairs(list) do\n\9\9\9if Promise.is(value) then\n\9\9\9\9if value:getStatus() == Promise.Status.Cancelled then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(Error.new({\n\9\9\9\9\9\9error = \"Promise is cancelled\",\n\9\9\9\9\9\9kind = Error.Kind.AlreadyCancelled,\n\9\9\9\9\9\9context = string.format(\n\9\9\9\9\9\9\9\"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\\n\\nThat Promise was created at:\\n\\n%s\",\n\9\9\9\9\9\9\9index,\n\9\9\9\9\9\9\9value._source\n\9\9\9\9\9\9),\n\9\9\9\9\9}))\n\9\9\9\9elseif value:getStatus() == Promise.Status.Rejected then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(select(2, value:await()))\n\9\9\9\9end\n\n\9\9\9\9-- Chain a new Promise from this one so we only cancel ours\n\9\9\9\9local ourPromise = value:andThen(function(...)\n\9\9\9\9\9return ...\n\9\9\9\9end)\n\n\9\9\9\9table.insert(promisesToCancel, ourPromise)\n\9\9\9\9preprocessedList[index] = ourPromise\n\9\9\9else\n\9\9\9\9preprocessedList[index] = value\n\9\9\9end\n\9\9end\n\n\9\9for index, value in ipairs(preprocessedList) do\n\9\9\9if Promise.is(value) then\n\9\9\9\9local success\n\9\9\9\9success, value = value:await()\n\n\9\9\9\9if not success then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(value)\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9if cancelled then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9local predicatePromise = Promise.resolve(predicate(value, index))\n\n\9\9\9table.insert(promisesToCancel, predicatePromise)\n\n\9\9\9local success, result = predicatePromise:await()\n\n\9\9\9if not success then\n\9\9\9\9cancel()\n\9\9\9\9return reject(result)\n\9\9\9end\n\n\9\9\9results[index] = result\n\9\9end\n\n\9\9resolve(results)\n\9end)\nend\n\n--[=[\n\9Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.\n\n\9@param object any\n\9@return boolean -- `true` if the given `object` is a Promise.\n]=]\nfunction Promise.is(object)\n\9if type(object) ~= \"table\" then\n\9\9return false\n\9end\n\n\9local objectMetatable = getmetatable(object)\n\n\9if objectMetatable == Promise then\n\9\9-- The Promise came from this library.\n\9\9return true\n\9elseif objectMetatable == nil then\n\9\9-- No metatable, but we should still chain onto tables with andThen methods\n\9\9return isCallable(object.andThen)\n\9elseif\n\9\9type(objectMetatable) == \"table\"\n\9\9and type(rawget(objectMetatable, \"__index\")) == \"table\"\n\9\9and isCallable(rawget(rawget(objectMetatable, \"__index\"), \"andThen\"))\n\9then\n\9\9-- Maybe this came from a different or older Promise library.\n\9\9return true\n\9end\n\n\9return false\nend\n\n--[=[\n\9Wraps a function that yields into one that returns a Promise.\n\n\9Any errors that occur while executing the function will be turned into rejections.\n\n\9:::info\n\9`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.\n\9:::\n\n\9```lua\n\9local sleep = Promise.promisify(wait)\n\n\9sleep(1):andThen(print)\n\9```\n\n\9```lua\n\9local isPlayerInGroup = Promise.promisify(function(player, groupId)\n\9\9return player:IsInGroup(groupId)\n\9end)\n\9```\n\n\9@param callback (...: any) -> ...any\n\9@return (...: any) -> Promise\n]=]\nfunction Promise.promisify(callback)\n\9return function(...)\n\9\9return Promise._try(debug.traceback(nil, 2), callback, ...)\n\9end\nend\n\n--[=[\n\9Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.\n\n\9This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.\n\n\9:::warning\n\9Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.\n\9:::\n\n\9```lua\n\9\9Promise.delay(5):andThenCall(print, \"This prints after 5 seconds\")\n\9```\n\n\9@function delay\n\9@within Promise\n\9@param seconds number\n\9@return Promise<number>\n]=]\ndo\n\9-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert\n\n\9-- the initial node in the linked list\n\9local first\n\9local connection\n\n\9function Promise.delay(seconds)\n\9\9assert(type(seconds) == \"number\", \"Bad argument #1 to Promise.delay, must be a number.\")\n\9\9-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.\n\9\9-- This mirrors the behavior of wait()\n\9\9if not (seconds >= 1 / 60) or seconds == math.huge then\n\9\9\9seconds = 1 / 60\n\9\9end\n\n\9\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9\9local startTime = Promise._getTime()\n\9\9\9local endTime = startTime + seconds\n\n\9\9\9local node = {\n\9\9\9\9resolve = resolve,\n\9\9\9\9startTime = startTime,\n\9\9\9\9endTime = endTime,\n\9\9\9}\n\n\9\9\9if connection == nil then -- first is nil when connection is nil\n\9\9\9\9first = node\n\9\9\9\9connection = Promise._timeEvent:Connect(function()\n\9\9\9\9\9local threadStart = Promise._getTime()\n\n\9\9\9\9\9while first ~= nil and first.endTime < threadStart do\n\9\9\9\9\9\9local current = first\n\9\9\9\9\9\9first = current.next\n\n\9\9\9\9\9\9if first == nil then\n\9\9\9\9\9\9\9connection:Disconnect()\n\9\9\9\9\9\9\9connection = nil\n\9\9\9\9\9\9else\n\9\9\9\9\9\9\9first.previous = nil\n\9\9\9\9\9\9end\n\n\9\9\9\9\9\9current.resolve(Promise._getTime() - current.startTime)\n\9\9\9\9\9end\n\9\9\9\9end)\n\9\9\9else -- first is non-nil\n\9\9\9\9if first.endTime < endTime then -- if `node` should be placed after `first`\n\9\9\9\9\9-- we will insert `node` between `current` and `next`\n\9\9\9\9\9-- (i.e. after `current` if `next` is nil)\n\9\9\9\9\9local current = first\n\9\9\9\9\9local next = current.next\n\n\9\9\9\9\9while next ~= nil and next.endTime < endTime do\n\9\9\9\9\9\9current = next\n\9\9\9\9\9\9next = current.next\n\9\9\9\9\9end\n\n\9\9\9\9\9-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)\n\9\9\9\9\9current.next = node\n\9\9\9\9\9node.previous = current\n\n\9\9\9\9\9if next ~= nil then\n\9\9\9\9\9\9node.next = next\n\9\9\9\9\9\9next.previous = node\n\9\9\9\9\9end\n\9\9\9\9else\n\9\9\9\9\9-- set `node` to `first`\n\9\9\9\9\9node.next = first\n\9\9\9\9\9first.previous = node\n\9\9\9\9\9first = node\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9onCancel(function()\n\9\9\9\9-- remove node from queue\n\9\9\9\9local next = node.next\n\n\9\9\9\9if first == node then\n\9\9\9\9\9if next == nil then -- if `node` is the first and last\n\9\9\9\9\9\9connection:Disconnect()\n\9\9\9\9\9\9connection = nil\n\9\9\9\9\9else -- if `node` is `first` and not the last\n\9\9\9\9\9\9next.previous = nil\n\9\9\9\9\9end\n\9\9\9\9\9first = next\n\9\9\9\9else\n\9\9\9\9\9local previous = node.previous\n\9\9\9\9\9-- since `node` is not `first`, then we know `previous` is non-nil\n\9\9\9\9\9previous.next = next\n\n\9\9\9\9\9if next ~= nil then\n\9\9\9\9\9\9next.previous = previous\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end)\n\9\9end)\n\9end\nend\n\n--[=[\n\9Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.\n\n\9Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].\n\n\9```lua\n\9getSomething():timeout(5):andThen(function(something)\n\9\9-- got something and it only took at max 5 seconds\n\9end):catch(function(e)\n\9\9-- Either getting something failed or the time was exceeded.\n\n\9\9if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then\n\9\9\9warn(\"Operation timed out!\")\n\9\9else\n\9\9\9warn(\"Operation encountered an error!\")\n\9\9end\n\9end)\n\9```\n\n\9Sugar for:\n\n\9```lua\n\9Promise.race({\n\9\9Promise.delay(seconds):andThen(function()\n\9\9\9return Promise.reject(\n\9\9\9\9rejectionValue == nil\n\9\9\9\9and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })\n\9\9\9\9or rejectionValue\n\9\9\9)\n\9\9end),\n\9\9promise\n\9})\n\9```\n\n\9@param seconds number\n\9@param rejectionValue? any -- The value to reject with if the timeout is reached\n\9@return Promise\n]=]\nfunction Promise.prototype:timeout(seconds, rejectionValue)\n\9local traceback = debug.traceback(nil, 2)\n\n\9return Promise.race({\n\9\9Promise.delay(seconds):andThen(function()\n\9\9\9return Promise.reject(rejectionValue == nil and Error.new({\n\9\9\9\9kind = Error.Kind.TimedOut,\n\9\9\9\9error = \"Timed out\",\n\9\9\9\9context = string.format(\n\9\9\9\9\9\"Timeout of %d seconds exceeded.\\n:timeout() called at:\\n\\n%s\",\n\9\9\9\9\9seconds,\n\9\9\9\9\9traceback\n\9\9\9\9),\n\9\9\9}) or rejectionValue)\n\9\9end),\n\9\9self,\n\9})\nend\n\n--[=[\n\9Returns the current Promise status.\n\n\9@return Status\n]=]\nfunction Promise.prototype:getStatus()\n\9return self._status\nend\n\n--[[\n\9Creates a new promise that receives the result of this promise.\n\n\9The given callbacks are invoked depending on that result.\n]]\nfunction Promise.prototype:_andThen(traceback, successHandler, failureHandler)\n\9self._unhandledRejection = false\n\n\9-- Create a new promise to follow this part of the chain\n\9return Promise._new(traceback, function(resolve, reject)\n\9\9-- Our default callbacks just pass values onto the next promise.\n\9\9-- This lets success and failure cascade correctly!\n\n\9\9local successCallback = resolve\n\9\9if successHandler then\n\9\9\9successCallback = createAdvancer(traceback, successHandler, resolve, reject)\n\9\9end\n\n\9\9local failureCallback = reject\n\9\9if failureHandler then\n\9\9\9failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)\n\9\9end\n\n\9\9if self._status == Promise.Status.Started then\n\9\9\9-- If we haven't resolved yet, put ourselves into the queue\n\9\9\9table.insert(self._queuedResolve, successCallback)\n\9\9\9table.insert(self._queuedReject, failureCallback)\n\9\9elseif self._status == Promise.Status.Resolved then\n\9\9\9-- This promise has already resolved! Trigger success immediately.\n\9\9\9successCallback(unpack(self._values, 1, self._valuesLength))\n\9\9elseif self._status == Promise.Status.Rejected then\n\9\9\9-- This promise died a terrible death! Trigger failure immediately.\n\9\9\9failureCallback(unpack(self._values, 1, self._valuesLength))\n\9\9elseif self._status == Promise.Status.Cancelled then\n\9\9\9-- We don't want to call the success handler or the failure handler,\n\9\9\9-- we just reject this promise outright.\n\9\9\9reject(Error.new({\n\9\9\9\9error = \"Promise is cancelled\",\n\9\9\9\9kind = Error.Kind.AlreadyCancelled,\n\9\9\9\9context = \"Promise created at\\n\\n\" .. traceback,\n\9\9\9}))\n\9\9end\n\9end, self)\nend\n\n--[=[\n\9Chains onto an existing Promise and returns a new Promise.\n\n\9:::warning\n\9Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\9:::\n\n\9Return a Promise from the success or failure handler and it will be chained onto.\n\n\9@param successHandler (...: any) -> ...any\n\9@param failureHandler? (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:andThen(successHandler, failureHandler)\n\9assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\9assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\n\9return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)\nend\n\n--[=[\n\9Shorthand for `Promise:andThen(nil, failureHandler)`.\n\n\9Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.\n\n\9:::warning\n\9Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\9:::\n\n\n\9@param failureHandler (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:catch(failureHandler)\n\9assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:catch\"))\n\9return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)\nend\n\n--[=[\n\9Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.\n\n\9```lua\n\9\9getTheValue()\n\9\9:tap(print)\n\9\9:andThen(function(theValue)\n\9\9\9print(\"Got\", theValue, \"even though print returns nil!\")\n\9\9end)\n\9```\n\n\9If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.\n\n\9@param tapHandler (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:tap(tapHandler)\n\9assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, \"Promise:tap\"))\n\9return self:_andThen(debug.traceback(nil, 2), function(...)\n\9\9local callbackReturn = tapHandler(...)\n\n\9\9if Promise.is(callbackReturn) then\n\9\9\9local length, values = pack(...)\n\9\9\9return callbackReturn:andThen(function()\n\9\9\9\9return unpack(values, 1, length)\n\9\9\9end)\n\9\9end\n\n\9\9return ...\n\9end)\nend\n\n--[=[\n\9Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.\n\n\9```lua\n\9\9promise:andThenCall(someFunction, \"some\", \"arguments\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:andThen(function()\n\9\9return someFunction(\"some\", \"arguments\")\n\9\9end)\n\9```\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:andThenCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:andThenCall\"))\n\9local length, values = pack(...)\n\9return self:_andThen(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:andThenReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:andThen(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9:::caution\n\9Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].\n\9:::\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:andThenReturn(...)\n\9local length, values = pack(...)\n\9return self:_andThen(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end)\nend\n\n--[=[\n\9Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.\n\n\9Cancellations will propagate upwards and downwards through chained promises.\n\n\9Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.\n\n\9```lua\n\9\9promise:cancel()\n\9```\n]=]\nfunction Promise.prototype:cancel()\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Cancelled\n\n\9if self._cancellationHook then\n\9\9self._cancellationHook()\n\9end\n\n\9if self._parent then\n\9\9self._parent:_consumerCancelled(self)\n\9end\n\n\9for child in pairs(self._consumers) do\n\9\9child:cancel()\n\9end\n\n\9self:_finalize()\nend\n\n--[[\n\9Used to decrease the number of consumers by 1, and if there are no more,\n\9cancel this promise.\n]]\nfunction Promise.prototype:_consumerCancelled(consumer)\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._consumers[consumer] = nil\n\n\9if next(self._consumers) == nil then\n\9\9self:cancel()\n\9end\nend\n\n--[[\n\9Used to set a handler for when the promise resolves, rejects, or is\n\9cancelled. Returns a new promise chained from this promise.\n]]\nfunction Promise.prototype:_finally(traceback, finallyHandler, onlyOk)\n\9if not onlyOk then\n\9\9self._unhandledRejection = false\n\9end\n\n\9-- Return a promise chained off of this promise\n\9return Promise._new(traceback, function(resolve, reject)\n\9\9local finallyCallback = resolve\n\9\9if finallyHandler then\n\9\9\9finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)\n\9\9end\n\n\9\9if onlyOk then\n\9\9\9local callback = finallyCallback\n\9\9\9finallyCallback = function(...)\n\9\9\9\9if self._status == Promise.Status.Rejected then\n\9\9\9\9\9return resolve(self)\n\9\9\9\9end\n\n\9\9\9\9return callback(...)\n\9\9\9end\n\9\9end\n\n\9\9if self._status == Promise.Status.Started then\n\9\9\9-- The promise is not settled, so queue this.\n\9\9\9table.insert(self._queuedFinally, finallyCallback)\n\9\9else\n\9\9\9-- The promise already settled or was cancelled, run the callback now.\n\9\9\9finallyCallback(self._status)\n\9\9end\n\9end, self)\nend\n\n--[=[\n\9Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.\n\n\9Returns a new promise chained from this promise.\n\n\9:::caution\n\9If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.\n\9:::\n\n\9```lua\n\9local thing = createSomething()\n\n\9doSomethingWith(thing)\n\9\9:andThen(function()\n\9\9\9print(\"It worked!\")\n\9\9\9-- do something..\n\9\9end)\n\9\9:catch(function()\n\9\9\9warn(\"Oh no it failed!\")\n\9\9end)\n\9\9:finally(function()\n\9\9\9-- either way, destroy thing\n\n\9\9\9thing:Destroy()\n\9\9end)\n\n\9```\n\n\9@param finallyHandler (status: Status) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:finally(finallyHandler)\n\9assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, \"Promise:finally\"))\n\9return self:_finally(debug.traceback(nil, 2), finallyHandler)\nend\n\n--[=[\n\9Same as `andThenCall`, except for `finally`.\n\n\9Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:finallyCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:finallyCall\"))\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:finallyReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:finally(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:finallyReturn(...)\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end)\nend\n\n--[=[\n\9Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.\n\n\9:::caution\n\9`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href=\"/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence\">this example</a>). You should use `andThen` instead if you only care about the Resolved case.\n\9:::\n\n\9:::warning\n\9Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.\n\9:::\n\n\9Returns a new promise chained from this promise.\n\n\9@param doneHandler (status: Status) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:done(doneHandler)\n\9assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, \"Promise:done\"))\n\9return self:_finally(debug.traceback(nil, 2), doneHandler, true)\nend\n\n--[=[\n\9Same as `andThenCall`, except for `done`.\n\n\9Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:doneCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:doneCall\"))\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end, true)\nend\n\n--[=[\n\9Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:doneReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:done(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:doneReturn(...)\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end, true)\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.\n\n\9@yields\n\9@return Status -- The Status representing the fate of the Promise\n\9@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:awaitStatus()\n\9self._unhandledRejection = false\n\n\9if self._status == Promise.Status.Started then\n\9\9local bindable = Instance.new(\"BindableEvent\")\n\n\9\9self:finally(function()\n\9\9\9bindable:Fire()\n\9\9end)\n\n\9\9bindable.Event:Wait()\n\9\9bindable:Destroy()\n\9end\n\n\9if self._status == Promise.Status.Resolved then\n\9\9return self._status, unpack(self._values, 1, self._valuesLength)\n\9elseif self._status == Promise.Status.Rejected then\n\9\9return self._status, unpack(self._values, 1, self._valuesLength)\n\9end\n\n\9return self._status\nend\n\nlocal function awaitHelper(status, ...)\n\9return status == Promise.Status.Resolved, ...\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.\n\n\9:::caution\n\9If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.\n\9:::\n\n\9```lua\n\9\9local worked, value = getTheValue():await()\n\n\9if worked then\n\9\9print(\"got\", value)\n\9else\n\9\9warn(\"it failed\")\n\9end\n\9```\n\n\9@yields\n\9@return boolean -- `true` if the Promise successfully resolved\n\9@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:await()\n\9return awaitHelper(self:awaitStatus())\nend\n\nlocal function expectHelper(status, ...)\n\9if status ~= Promise.Status.Resolved then\n\9\9error((...) == nil and \"Expected Promise rejected with no value.\" or (...), 3)\n\9end\n\n\9return ...\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.\n\n\9```lua\n\9local worked = pcall(function()\n\9\9print(\"got\", getTheValue():expect())\n\9end)\n\n\9if not worked then\n\9\9warn(\"it failed\")\n\9end\n\9```\n\n\9This is essentially sugar for:\n\n\9```lua\n\9select(2, assert(promise:await()))\n\9```\n\n\9**Errors** if the Promise rejects or gets cancelled.\n\n\9@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.\n\9@yields\n\9@return ...any -- The values the Promise resolved with.\n]=]\nfunction Promise.prototype:expect()\n\9return expectHelper(self:awaitStatus())\nend\n\n-- Backwards compatibility\nPromise.prototype.awaitValue = Promise.prototype.expect\n\n--[[\n\9Intended for use in tests.\n\n\9Similar to await(), but instead of yielding if the promise is unresolved,\n\9_unwrap will throw. This indicates an assumption that a promise has\n\9resolved.\n]]\nfunction Promise.prototype:_unwrap()\n\9if self._status == Promise.Status.Started then\n\9\9error(\"Promise has not resolved or rejected.\", 2)\n\9end\n\n\9local success = self._status == Promise.Status.Resolved\n\n\9return success, unpack(self._values, 1, self._valuesLength)\nend\n\nfunction Promise.prototype:_resolve(...)\n\9if self._status ~= Promise.Status.Started then\n\9\9if Promise.is((...)) then\n\9\9\9(...):_consumerCancelled(self)\n\9\9end\n\9\9return\n\9end\n\n\9-- If the resolved value was a Promise, we chain onto it!\n\9if Promise.is((...)) then\n\9\9-- Without this warning, arguments sometimes mysteriously disappear\n\9\9if select(\"#\", ...) > 1 then\n\9\9\9local message = string.format(\n\9\9\9\9\"When returning a Promise from andThen, extra arguments are \" .. \"discarded! See:\\n\\n%s\",\n\9\9\9\9self._source\n\9\9\9)\n\9\9\9warn(message)\n\9\9end\n\n\9\9local chainedPromise = ...\n\n\9\9local promise = chainedPromise:andThen(function(...)\n\9\9\9self:_resolve(...)\n\9\9end, function(...)\n\9\9\9local maybeRuntimeError = chainedPromise._values[1]\n\n\9\9\9-- Backwards compatibility < v2\n\9\9\9if chainedPromise._error then\n\9\9\9\9maybeRuntimeError = Error.new({\n\9\9\9\9\9error = chainedPromise._error,\n\9\9\9\9\9kind = Error.Kind.ExecutionError,\n\9\9\9\9\9context = \"[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]\",\n\9\9\9\9})\n\9\9\9end\n\n\9\9\9if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then\n\9\9\9\9return self:_reject(maybeRuntimeError:extend({\n\9\9\9\9\9error = \"This Promise was chained to a Promise that errored.\",\n\9\9\9\9\9trace = \"\",\n\9\9\9\9\9context = string.format(\n\9\9\9\9\9\9\"The Promise at:\\n\\n%s\\n...Rejected because it was chained to the following Promise, which encountered an error:\\n\",\n\9\9\9\9\9\9self._source\n\9\9\9\9\9),\n\9\9\9\9}))\n\9\9\9end\n\n\9\9\9self:_reject(...)\n\9\9end)\n\n\9\9if promise._status == Promise.Status.Cancelled then\n\9\9\9self:cancel()\n\9\9elseif promise._status == Promise.Status.Started then\n\9\9\9-- Adopt ourselves into promise for cancellation propagation.\n\9\9\9self._parent = promise\n\9\9\9promise._consumers[self] = true\n\9\9end\n\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Resolved\n\9self._valuesLength, self._values = pack(...)\n\n\9-- We assume that these callbacks will not throw errors.\n\9for _, callback in ipairs(self._queuedResolve) do\n\9\9coroutine.wrap(callback)(...)\n\9end\n\n\9self:_finalize()\nend\n\nfunction Promise.prototype:_reject(...)\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Rejected\n\9self._valuesLength, self._values = pack(...)\n\n\9-- If there are any rejection handlers, call those!\n\9if not isEmpty(self._queuedReject) then\n\9\9-- We assume that these callbacks will not throw errors.\n\9\9for _, callback in ipairs(self._queuedReject) do\n\9\9\9coroutine.wrap(callback)(...)\n\9\9end\n\9else\n\9\9-- At this point, no one was able to observe the error.\n\9\9-- An error handler might still be attached if the error occurred\n\9\9-- synchronously. We'll wait one tick, and if there are still no\n\9\9-- observers, then we should put a message in the console.\n\n\9\9local err = tostring((...))\n\n\9\9coroutine.wrap(function()\n\9\9\9Promise._timeEvent:Wait()\n\n\9\9\9-- Someone observed the error, hooray!\n\9\9\9if not self._unhandledRejection then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9-- Build a reasonable message\n\9\9\9local message = string.format(\"Unhandled Promise rejection:\\n\\n%s\\n\\n%s\", err, self._source)\n\n\9\9\9for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do\n\9\9\9\9task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))\n\9\9\9end\n\n\9\9\9if Promise.TEST then\n\9\9\9\9-- Don't spam output when we're running tests.\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9warn(message)\n\9\9end)()\n\9end\n\n\9self:_finalize()\nend\n\n--[[\n\9Calls any :finally handlers. We need this to be a separate method and\n\9queue because we must call all of the finally callbacks upon a success,\n\9failure, *and* cancellation.\n]]\nfunction Promise.prototype:_finalize()\n\9for _, callback in ipairs(self._queuedFinally) do\n\9\9-- Purposefully not passing values to callbacks here, as it could be the\n\9\9-- resolved values, or rejected errors. If the developer needs the values,\n\9\9-- they should use :andThen or :catch explicitly.\n\9\9coroutine.wrap(callback)(self._status)\n\9end\n\n\9self._queuedFinally = nil\n\9self._queuedReject = nil\n\9self._queuedResolve = nil\n\n\9-- Clear references to other Promises to allow gc\n\9if not Promise.TEST then\n\9\9self._parent = nil\n\9\9self._consumers = nil\n\9end\nend\n\n--[=[\n\9Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.\n\n\9```lua\n\9doSomething()\n\9\9:now()\n\9\9:andThen(function(value)\n\9\9\9print(\"Got\", value, \"synchronously.\")\n\9\9end)\n\9```\n\n\9If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].\n\n\9@param rejectionValue? any -- The value to reject with if the Promise isn't resolved\n\9@return Promise\n]=]\nfunction Promise.prototype:now(rejectionValue)\n\9local traceback = debug.traceback(nil, 2)\n\9if self._status == Promise.Status.Resolved then\n\9\9return self:_andThen(traceback, function(...)\n\9\9\9return ...\n\9\9end)\n\9else\n\9\9return Promise.reject(rejectionValue == nil and Error.new({\n\9\9\9kind = Error.Kind.NotResolvedInTime,\n\9\9\9error = \"This Promise was not resolved in time for :now()\",\n\9\9\9context = \":now() was called at:\\n\\n\" .. traceback,\n\9\9}) or rejectionValue)\n\9end\nend\n\n--[=[\n\9Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.\n\n\9If the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\9```lua\n\9local function canFail(a, b, c)\n\9\9return Promise.new(function(resolve, reject)\n\9\9\9-- do something that can fail\n\n\9\9\9local failed, thing = doSomethingThatCanFail(a, b, c)\n\n\9\9\9if failed then\n\9\9\9\9reject(\"it failed\")\n\9\9\9else\n\9\9\9\9resolve(thing)\n\9\9\9end\n\9\9end)\n\9end\n\n\9local MAX_RETRIES = 10\n\9local value = Promise.retry(canFail, MAX_RETRIES, \"foo\", \"bar\", \"baz\") -- args to send to canFail\n\9```\n\n\9@since 3.0.0\n\9@param callback (...: P) -> Promise<T>\n\9@param times number\n\9@param ...? P\n]=]\nfunction Promise.retry(callback, times, ...)\n\9assert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\9assert(type(times) == \"number\", \"Parameter #2 to Promise.retry must be a number\")\n\n\9local args, length = { ... }, select(\"#\", ...)\n\n\9return Promise.resolve(callback(...)):catch(function(...)\n\9\9if times > 0 then\n\9\9\9return Promise.retry(callback, times - 1, unpack(args, 1, length))\n\9\9else\n\9\9\9return Promise.reject(...)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each\n\9retry, until the returned Promise resolves.\n\n\9If the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\9@since v3.2.0\n\9@param callback (...: P) -> Promise<T>\n\9@param times number\n\9@param seconds number\n\9@param ...? P\n]=]\nfunction Promise.retryWithDelay(callback, times, seconds, ...)\n\9assert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\9assert(type(times) == \"number\", \"Parameter #2 (times) to Promise.retry must be a number\")\n\9assert(type(seconds) == \"number\", \"Parameter #3 (seconds) to Promise.retry must be a number\")\n\n\9local args, length = { ... }, select(\"#\", ...)\n\n\9return Promise.resolve(callback(...)):catch(function(...)\n\9\9if times > 0 then\n\9\9\9Promise.delay(seconds):await()\n\n\9\9\9return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))\n\9\9else\n\9\9\9return Promise.reject(...)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Converts an event into a Promise which resolves the next time the event fires.\n\n\9The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.\n\n\9The Promise will resolve with the event arguments.\n\n\9:::tip\n\9This function will work given any object with a `Connect` method. This includes all Roblox events.\n\9:::\n\n\9```lua\n\9-- Creates a Promise which only resolves when `somePart` is touched\n\9-- by a part named `\"Something specific\"`.\n\9return Promise.fromEvent(somePart.Touched, function(part)\n\9\9return part.Name == \"Something specific\"\n\9end)\n\9```\n\n\9@since 3.0.0\n\9@param event Event -- Any object with a `Connect` method. This includes all Roblox events.\n\9@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.\n\9@return Promise<P>\n]=]\nfunction Promise.fromEvent(event, predicate)\n\9predicate = predicate or function()\n\9\9return true\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9local connection\n\9\9local shouldDisconnect = false\n\n\9\9local function disconnect()\n\9\9\9connection:Disconnect()\n\9\9\9connection = nil\n\9\9end\n\n\9\9-- We use shouldDisconnect because if the callback given to Connect is called before\n\9\9-- Connect returns, connection will still be nil. This happens with events that queue up\n\9\9-- events when there's nothing connected, such as RemoteEvents\n\n\9\9connection = event:Connect(function(...)\n\9\9\9local callbackValue = predicate(...)\n\n\9\9\9if callbackValue == true then\n\9\9\9\9resolve(...)\n\n\9\9\9\9if connection then\n\9\9\9\9\9disconnect()\n\9\9\9\9else\n\9\9\9\9\9shouldDisconnect = true\n\9\9\9\9end\n\9\9\9elseif type(callbackValue) ~= \"boolean\" then\n\9\9\9\9error(\"Promise.fromEvent predicate should always return a boolean\")\n\9\9\9end\n\9\9end)\n\n\9\9if shouldDisconnect and connection then\n\9\9\9return disconnect()\n\9\9end\n\n\9\9onCancel(disconnect)\n\9end)\nend\n\n--[=[\n\9Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise\n\9is rejected, and the rejection is not observed with `:catch`.\n\n\9The callback is called with the actual promise that rejected, followed by the rejection values.\n\n\9@since v3.2.0\n\9@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.\n\9@return () -> () -- Function that unregisters the `callback` when called\n]=]\nfunction Promise.onUnhandledRejection(callback)\n\9table.insert(Promise._unhandledRejectionCallbacks, callback)\n\n\9return function()\n\9\9local index = table.find(Promise._unhandledRejectionCallbacks, callback)\n\n\9\9if index then\n\9\9\9table.remove(Promise._unhandledRejectionCallbacks, index)\n\9\9end\n\9end\nend\n\nreturn Promise\n", "bundle-ex.include.Promise"))(__env)
end)
__lua("RuntimeLib", "ModuleScript", "bundle-ex.include.RuntimeLib", "bundle-ex.include", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.RuntimeLib\")local script,require=_.script,_.require local Promise = require(script.Parent.Promise)\n\nlocal RunService = game:GetService(\"RunService\")\n\nlocal OUTPUT_PREFIX = \"roblox-ts: \"\nlocal NODE_MODULES = \"node_modules\"\nlocal DEFAULT_SCOPE = \"@rbxts\"\n\nlocal TS = {}\n\nTS.Promise = Promise\n\nlocal function isPlugin(context)\n\9return RunService:IsStudio() and context:FindFirstAncestorWhichIsA(\"Plugin\") ~= nil\nend\n\nfunction TS.getModule(context, scope, moduleName)\n\9-- legacy call signature\n\9if moduleName == nil then\n\9\9moduleName = scope\n\9\9scope = DEFAULT_SCOPE\n\9end\n\n\9-- ensure modules have fully replicated\n\9if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then\n\9\9game.Loaded:Wait()\n\9end\n\n\9local object = context\n\9repeat\n\9\9local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)\n\9\9if nodeModulesFolder then\n\9\9\9local scopeFolder = nodeModulesFolder:FindFirstChild(scope)\n\9\9\9if scopeFolder then\n\9\9\9\9local module = scopeFolder:FindFirstChild(moduleName)\n\9\9\9\9if module then\n\9\9\9\9\9return module\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9object = object.Parent\n\9until object == nil\n\n\9error(OUTPUT_PREFIX .. \"Could not find module: \" .. moduleName, 2)\nend\n\n-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library\nlocal currentlyLoading = {}\nlocal registeredLibraries = {}\n\nfunction TS.import(context, module, ...)\n\9for i = 1, select(\"#\", ...) do\n\9\9module = module:WaitForChild((select(i, ...)))\n\9end\n\n\9if module.ClassName ~= \"ModuleScript\" then\n\9\9error(OUTPUT_PREFIX .. \"Failed to import! Expected ModuleScript, got \" .. module.ClassName, 2)\n\9end\n\n\9currentlyLoading[context] = module\n\n\9-- Check to see if a case like this occurs:\n\9-- module -> Module1 -> Module2 -> module\n\n\9-- WHERE currentlyLoading[module] is Module1\n\9-- and currentlyLoading[Module1] is Module2\n\9-- and currentlyLoading[Module2] is module\n\n\9local currentModule = module\n\9local depth = 0\n\n\9while currentModule do\n\9\9depth = depth + 1\n\9\9currentModule = currentlyLoading[currentModule]\n\n\9\9if currentModule == module then\n\9\9\9local str = currentModule.Name -- Get the string traceback\n\n\9\9\9for _ = 1, depth do\n\9\9\9\9currentModule = currentlyLoading[currentModule]\n\9\9\9\9str = str .. \"  â‡’ \" .. currentModule.Name\n\9\9\9end\n\n\9\9\9error(OUTPUT_PREFIX .. \"Failed to import! Detected a circular dependency chain: \" .. str, 2)\n\9\9end\n\9end\n\n\9if not registeredLibraries[module] then\n\9\9if _G[module] then\n\9\9\9error(\n\9\9\9\9OUTPUT_PREFIX\n\9\9\9\9.. \"Invalid module access! Do you have multiple TS runtimes trying to import this? \"\n\9\9\9\9.. module:GetFullName(),\n\9\9\9\0092\n\9\9\9)\n\9\9end\n\n\9\9_G[module] = TS\n\9\9registeredLibraries[module] = true -- register as already loaded for subsequent calls\n\9end\n\n\9local data = require(module)\n\n\9if currentlyLoading[context] == module then -- Thread-safe cleanup!\n\9\9currentlyLoading[context] = nil\n\9end\n\n\9return data\nend\n\nfunction TS.instanceof(obj, class)\n\9-- custom Class.instanceof() check\n\9if type(class) == \"table\" and type(class.instanceof) == \"function\" then\n\9\9return class.instanceof(obj)\n\9end\n\n\9-- metatable check\n\9if type(obj) == \"table\" then\n\9\9obj = getmetatable(obj)\n\9\9while obj ~= nil do\n\9\9\9if obj == class then\n\9\9\9\9return true\n\9\9\9end\n\9\9\9local mt = getmetatable(obj)\n\9\9\9if mt then\n\9\9\9\9obj = mt.__index\n\9\9\9else\n\9\9\9\9obj = nil\n\9\9\9end\n\9\9end\n\9end\n\n\9return false\nend\n\nfunction TS.async(callback)\n\9return function(...)\n\9\9local n = select(\"#\", ...)\n\9\9local args = { ... }\n\9\9return Promise.new(function(resolve, reject)\n\9\9\9coroutine.wrap(function()\n\9\9\9\9local ok, result = pcall(callback, unpack(args, 1, n))\n\9\9\9\9if ok then\n\9\9\9\9\9resolve(result)\n\9\9\9\9else\n\9\9\9\9\9reject(result)\n\9\9\9\9end\n\9\9\9end)()\n\9\9end)\n\9end\nend\n\nfunction TS.await(promise)\n\9if not Promise.is(promise) then\n\9\9return promise\n\9end\n\n\9local status, value = promise:awaitStatus()\n\9if status == Promise.Status.Resolved then\n\9\9return value\n\9elseif status == Promise.Status.Rejected then\n\9\9error(value, 2)\n\9else\n\9\9error(\"The awaited Promise was cancelled\", 2)\n\9end\nend\n\nlocal SIGN = 2 ^ 31\nlocal COMPLEMENT = 2 ^ 32\nlocal function bit_sign(num)\n\9-- Restores the sign after an unsigned conversion according to 2s complement.\n\9if bit32.btest(num, SIGN) then\n\9\9return num - COMPLEMENT\n\9else\n\9\9return num\n\9end\nend\n\nfunction TS.bit_lrsh(a, b)\n\9return bit_sign(bit32.arshift(a, b))\nend\n\nTS.TRY_RETURN = 1\nTS.TRY_BREAK = 2\nTS.TRY_CONTINUE = 3\n\nfunction TS.try(func, catch, finally)\n\9local err, traceback\n\9local success, exitType, returns = xpcall(\n\9\9func,\n\9\9function(errInner)\n\9\9\9err = errInner\n\9\9\9traceback = debug.traceback()\n\9\9end\n\9)\n\9if not success and catch then\n\9\9local newExitType, newReturns = catch(err, traceback)\n\9\9if newExitType then\n\9\9\9exitType, returns = newExitType, newReturns\n\9\9end\n\9end\n\9if finally then\n\9\9local newExitType, newReturns = finally()\n\9\9if newExitType then\n\9\9\9exitType, returns = newExitType, newReturns\n\9\9end\n\9end\n\9return exitType, returns\nend\n\nfunction TS.generator(callback)\n\9local co = coroutine.create(callback)\n\9return {\n\9\9next = function(...)\n\9\9\9if coroutine.status(co) == \"dead\" then\n\9\9\9\9return { done = true }\n\9\9\9else\n\9\9\9\9local success, value = coroutine.resume(co, ...)\n\9\9\9\9if success == false then\n\9\9\9\9\9error(value, 2)\n\9\9\9\9end\n\9\9\9\9return {\n\9\9\9\9\9value = value,\n\9\9\9\9\9done = coroutine.status(co) == \"dead\",\n\9\9\9\9}\n\9\9\9end\n\9\9end,\n\9}\nend\n\nreturn TS\n", "bundle-ex.include.RuntimeLib"))(__env)
end)
__rbx("node_modules", "Folder", "bundle-ex.include.node_modules", "bundle-ex.include")
__rbx("@flamework", "Folder", "bundle-ex.include.node_modules.@flamework", "bundle-ex.include.node_modules")
__rbx("core", "Folder", "bundle-ex.include.node_modules.@flamework.core", "bundle-ex.include.node_modules.@flamework")
__lua("out", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out", "bundle-ex.include.node_modules.@flamework.core", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\nlocal TS = _G[script]\nlocal exports = {}\nexports.Reflect = TS.import(script, script, \"reflect\").Reflect\nexports.Modding = TS.import(script, script, \"modding\").Modding\nlocal _flamework = TS.import(script, script, \"flamework\")\nexports.Controller = _flamework.Controller\nexports.Dependency = _flamework.Dependency\nexports.External = _flamework.External\nexports.Service = _flamework.Service\nexports.Flamework = _flamework.Flamework\nreturn exports\n", "bundle-ex.include.node_modules.@flamework.core.out"))(__env)
end)
__lua("flamework", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.flamework", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.flamework\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\nlocal TS = _G[script]\nlocal _services = TS.import(script, TS.getModule(script, \"@rbxts\", \"services\"))\nlocal Players = _services.Players\nlocal RunService = _services.RunService\nlocal Metadata = TS.import(script, script.Parent, \"metadata\").Metadata\nlocal Modding = TS.import(script, script.Parent, \"modding\").Modding\nlocal Reflect = TS.import(script, script.Parent, \"reflect\").Reflect\nlocal ArtificialDependency, Flamework\nlocal Flamework = {}\ndo\n\9local _container = Flamework\n\9local flameworkConfig = {\n\9\9isDefault = true,\n\9}\n\9_container.flameworkConfig = flameworkConfig\n\9_container.isInitialized = false\n\9local isPreloading = false\n\9-- * @hidden\n\9local hasFlameworkIgnited\n\9local function resolveDependency(id)\n\9\9if isPreloading then\n\9\9\9local source, line = debug.info(2, \"sl\")\n\9\9\9warn(\"[Flamework] Attempting to load dependency '\" .. (id .. \"' during preloading.\"))\n\9\9\9warn(\"This is prone to race conditions and is not guaranteed to succeed.\")\n\9\9\9warn(\"Script '\" .. (source .. (\"', Line \" .. tostring(line))))\n\9\9elseif not hasFlameworkIgnited and Metadata.gameConfig.disableDependencyWarnings ~= true then\n\9\9\9local source, line = debug.info(2, \"sl\")\n\9\9\9warn(\"[Flamework] Dependency '\" .. (id .. \"' was loaded before ignition.\"))\n\9\9\9warn(\"This is considered bad practice and should be avoided.\")\n\9\9\9warn(\"You can disable this warning in flamework.json\")\n\9\9\9warn(\"Script '\" .. (source .. (\"', Line \" .. tostring(line))))\n\9\9end\n\9\9return Modding.resolveDependency(ArtificialDependency, id, 0, {})\n\9end\n\9_container.resolveDependency = resolveDependency\n\9-- * @hidden\n\9local logIfVerbose\n\9local function _addPaths(...)\n\9\9local args = { ... }\n\9\9local preloadPaths = {}\n\9\9for _, arg in args do\n\9\9\9local service = table.remove(arg, 1)\n\9\9\9local currentPath = game:GetService(service)\n\9\9\9if service == \"StarterPlayer\" then\n\9\9\9\9if arg[1] ~= \"StarterPlayerScripts\" then\n\9\9\9\9\9error(\"StarterPlayer only supports StarterPlayerScripts\")\n\9\9\9\9end\n\9\9\9\9if not RunService:IsClient() then\n\9\9\9\9\9error(\"The server cannot load StarterPlayer content\")\n\9\9\9\9end\n\9\9\9\9currentPath = Players.LocalPlayer:WaitForChild(\"PlayerScripts\")\n\9\9\9\9table.remove(arg, 1)\n\9\9\9end\n\9\9\9do\n\9\9\9\9local i = 0\n\9\9\9\9local _shouldIncrement = false\n\9\9\9\9while true do\n\9\9\9\9\9if _shouldIncrement then\n\9\9\9\9\9\9i += 1\n\9\9\9\9\9else\n\9\9\9\9\9\9_shouldIncrement = true\n\9\9\9\9\9end\n\9\9\9\9\9if not (i < #arg) then\n\9\9\9\9\9\9break\n\9\9\9\9\9end\n\9\9\9\9\9currentPath = currentPath:WaitForChild(arg[i + 1])\n\9\9\9\9end\n\9\9\9end\n\9\9\9local _currentPath = currentPath\n\9\9\9table.insert(preloadPaths, _currentPath)\n\9\9end\n\9\9local preload = function(moduleScript)\n\9\9\9isPreloading = true\n\9\9\9local start = os.clock()\n\9\9\9local success, value = pcall(require, moduleScript)\n\9\9\9local endTime = math.floor((os.clock() - start) * 1000)\n\9\9\9isPreloading = false\n\9\9\9if not success then\n\9\9\9\9error(moduleScript:GetFullName() .. (\" failed to preload (\" .. (tostring(endTime) .. (\"ms): \" .. value))))\n\9\9\9end\n\9\9end\n\9\9for _, path in preloadPaths do\n\9\9\9logIfVerbose(\"Preloading directory \" .. path:GetFullName())\n\9\9\9if path:IsA(\"ModuleScript\") then\n\9\9\9\9preload(path)\n\9\9\9end\n\9\9\9for _1, instance in path:GetDescendants() do\n\9\9\9\9if instance:IsA(\"ModuleScript\") then\n\9\9\9\9\9preload(instance)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\n\9_container._addPaths = _addPaths\n\9-- * @hidden\n\9local function _implements(object, id)\n\9\9local _exp = Reflect.getMetadatas(object, \"flamework:implements\")\n\9\9local _arg0 = function(impl)\n\9\9\9local _impl = impl\n\9\9\9local _id = id\n\9\9\9return table.find(_impl, _id) ~= nil\n\9\9end\n\9\9-- â–¼ ReadonlyArray.some â–¼\n\9\9local _result = false\n\9\9for _k, _v in _exp do\n\9\9\9if _arg0(_v, _k - 1, _exp) then\n\9\9\9\9_result = true\n\9\9\9\9break\n\9\9\9end\n\9\9end\n\9\9-- â–² ReadonlyArray.some â–²\n\9\9return _result\n\9end\n\9_container._implements = _implements\n\9function logIfVerbose(...)\n\9\9local args = { ... }\n\9\9if Metadata.getLogLevel() == \"verbose\" then\n\9\9\9print(\"[Flamework (verbose)]\", unpack(args))\n\9\9end\n\9end\n\9local function isConstructor(obj)\n\9\9return obj.new ~= nil and obj.constructor ~= nil\n\9end\n\9local function getIdentifier(obj, suffix)\n\9\9if suffix == nil then\n\9\9\9suffix = \"\"\n\9\9end\n\9\9local _condition = Reflect.getMetadata(obj, \"identifier\")\n\9\9if _condition == nil then\n\9\9\9_condition = \"UnidentifiedFlameworkListener\" .. suffix\n\9\9end\n\9\9return _condition\n\9end\n\9-- This returns a Map rather than an Array because table.sort is unstable and will not preserve element order.\n\9local function topologicalSort(objects)\n\9\9-- This implementation ignores circular dependency trees.\n\9\9local currentSize = 0\n\9\9local sorted = {}\n\9\9local visited = {}\n\9\9local visitor\n\9\9visitor = function(node)\n\9\9\9local _node = node\n\9\9\9if visited[_node] ~= nil then\n\9\9\9\9return nil\n\9\9\9end\n\9\9\9local _node_1 = node\n\9\9\9visited[_node_1] = true\n\9\9\9local _idToObj = Reflect.idToObj\n\9\9\9local _node_2 = node\n\9\9\9local object = _idToObj[_node_2]\n\9\9\9if not object then\n\9\9\9\9return nil\n\9\9\9end\n\9\9\9local dependencies = Reflect.getMetadata(object, \"flamework:parameters\")\n\9\9\9for _, dependency in dependencies or {} do\n\9\9\9\9visitor(dependency)\n\9\9\9end\n\9\9\9local _exp = node\n\9\9\9local _original = currentSize\n\9\9\9currentSize += 1\n\9\9\9sorted[_exp] = _original\n\9\9end\n\9\9for _, node in objects do\n\9\9\9visitor(node)\n\9\9end\n\9\9return sorted\n\9end\n\9local externalClasses = {}\n\9--[[\n\9\9*\n\9\9* Allow an external module to be bootstrapped by Flamework.ignite()\n\9]]\n\9local function registerExternalClass(ctor)\n\9\9local _ctor = ctor\n\9\9externalClasses[_ctor] = true\n\9end\n\9_container.registerExternalClass = registerExternalClass\n\9hasFlameworkIgnited = false\n\9--[[\n\9\9*\n\9\9* Initialize Flamework.\n\9\9*\n\9\9* This will start up the lifecycle events on all currently registered\n\9\9* classes.\n\9\9*\n\9\9* You should preload all necessary directories before calling this\n\9\9* as newly registered classes will not run their lifecycle events.\n\9\9*\n\9\9* @returns All the dependencies that have been loaded.\n\9]]\n\9local function ignite(patchedConfig)\n\9\9if hasFlameworkIgnited then\n\9\9\9error(\"Flamework.ignite() should only be called once\")\n\9\9end\n\9\9hasFlameworkIgnited = true\n\9\9if patchedConfig then\n\9\9\9for key, value in pairs(patchedConfig) do\n\9\9\9\9flameworkConfig[key] = value\n\9\9\9end\n\9\9end\n\9\9for ctor in Reflect.objToId do\n\9\9\9if not isConstructor(ctor) then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9if not Reflect.getMetadata(ctor, \"flamework:singleton\") then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9local isPatched = Reflect.getOwnMetadata(ctor, \"flamework:isPatched\")\n\9\9\9if flameworkConfig.loadOverride and (not (table.find(flameworkConfig.loadOverride, ctor) ~= nil) and not isPatched) then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9local isExternal = Reflect.getOwnMetadata(ctor, \"flamework:isExternal\")\n\9\9\9if isExternal and not (externalClasses[ctor] ~= nil) then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9Modding.resolveSingleton(ctor)\n\9\9\9logIfVerbose(\"Resolving singleton \" .. tostring(ctor))\n\9\9end\n\9\9local dependencies = {}\n\9\9for ctor, dependency in Modding.getSingletons() do\n\9\9\9local _condition = Reflect.getMetadata(ctor, \"flamework:loadOrder\")\n\9\9\9if _condition == nil then\n\9\9\9\9_condition = 1\n\9\9\9end\n\9\9\9local loadOrder = _condition\n\9\9\9local _arg0 = { dependency, loadOrder }\n\9\9\9table.insert(dependencies, _arg0)\n\9\9end\n\9\9local _arg0 = function(_param)\n\9\9\9local obj = _param[1]\n\9\9\9return getIdentifier(obj)\n\9\9end\n\9\9-- â–¼ ReadonlyArray.map â–¼\n\9\9local _newValue = table.create(#dependencies)\n\9\9for _k, _v in dependencies do\n\9\9\9_newValue[_k] = _arg0(_v, _k - 1, dependencies)\n\9\9end\n\9\9-- â–² ReadonlyArray.map â–²\n\9\9local sortedDependencies = topologicalSort(_newValue)\n\9\9local start = {}\n\9\9local init = {}\n\9\9local tick = {}\n\9\9local render = {}\n\9\9local physics = {}\n\9\9local _arg0_1 = function(_param, _param_1)\n\9\9\9local depA = _param[1]\n\9\9\9local aOrder = _param[2]\n\9\9\9local depB = _param_1[1]\n\9\9\9local bOrder = _param_1[2]\n\9\9\9if aOrder ~= bOrder then\n\9\9\9\9return aOrder < bOrder\n\9\9\9end\n\9\9\9local _arg0_2 = getIdentifier(depA)\n\9\9\9local aIndex = sortedDependencies[_arg0_2]\n\9\9\9local _arg0_3 = getIdentifier(depB)\n\9\9\9local bIndex = sortedDependencies[_arg0_3]\n\9\9\9return aIndex < bIndex\n\9\9end\n\9\9table.sort(dependencies, _arg0_1)\n\9\9Modding.onListenerAdded(function(object)\n\9\9\9local _object = object\n\9\9\9local _arg1 = getIdentifier(object, \"/OnTick\")\n\9\9\9tick[_object] = _arg1\n\9\9\9return tick\n\9\9end, \"$:flamework@OnTick\")\n\9\9Modding.onListenerAdded(function(object)\n\9\9\9local _object = object\n\9\9\9local _arg1 = getIdentifier(object, \"/OnPhysics\")\n\9\9\9physics[_object] = _arg1\n\9\9\9return physics\n\9\9end, \"$:flamework@OnPhysics\")\n\9\9Modding.onListenerAdded(function(object)\n\9\9\9local _object = object\n\9\9\9local _arg1 = getIdentifier(object, \"/OnRender\")\n\9\9\9render[_object] = _arg1\n\9\9\9return render\n\9\9end, \"$:flamework@OnRender\")\n\9\9Modding.onListenerRemoved(function(object)\n\9\9\9local _object = object\n\9\9\9-- â–¼ Map.delete â–¼\n\9\9\9local _valueExisted = tick[_object] ~= nil\n\9\9\9tick[_object] = nil\n\9\9\9-- â–² Map.delete â–²\n\9\9\9return _valueExisted\n\9\9end, \"$:flamework@OnTick\")\n\9\9Modding.onListenerRemoved(function(object)\n\9\9\9local _object = object\n\9\9\9-- â–¼ Map.delete â–¼\n\9\9\9local _valueExisted = physics[_object] ~= nil\n\9\9\9physics[_object] = nil\n\9\9\9-- â–² Map.delete â–²\n\9\9\9return _valueExisted\n\9\9end, \"$:flamework@OnPhysics\")\n\9\9Modding.onListenerRemoved(function(object)\n\9\9\9local _object = object\n\9\9\9-- â–¼ Map.delete â–¼\n\9\9\9local _valueExisted = render[_object] ~= nil\n\9\9\9render[_object] = nil\n\9\9\9-- â–² Map.delete â–²\n\9\9\9return _valueExisted\n\9\9end, \"$:flamework@OnRender\")\n\9\9for _, _binding in dependencies do\n\9\9\9local dependency = _binding[1]\n\9\9\9if Flamework._implements(dependency, \"$:flamework@OnInit\") then\n\9\9\9\9local _arg0_2 = { dependency, getIdentifier(dependency) }\n\9\9\9\9table.insert(init, _arg0_2)\n\9\9\9end\n\9\9\9if Flamework._implements(dependency, \"$:flamework@OnStart\") then\n\9\9\9\9local _arg0_2 = { dependency, getIdentifier(dependency) }\n\9\9\9\9table.insert(start, _arg0_2)\n\9\9\9end\n\9\9end\n\9\9for _, _binding in init do\n\9\9\9local dependency = _binding[1]\n\9\9\9local identifier = _binding[2]\n\9\9\9debug.setmemorycategory(identifier)\n\9\9\9logIfVerbose(\"OnInit \" .. identifier)\n\9\9\9local initResult = dependency:onInit()\n\9\9\9if TS.Promise.is(initResult) then\n\9\9\9\9local status, value = initResult:awaitStatus()\n\9\9\9\9if status == TS.Promise.Status.Rejected then\n\9\9\9\9\9error(\"OnInit failed for dependency '\" .. (identifier .. (\"'. \" .. tostring(value))))\n\9\9\9\9end\n\9\9\9end\n\9\9\9debug.resetmemorycategory()\n\9\9end\n\9\9_container.isInitialized = true\n\9\9RunService.Heartbeat:Connect(function(dt)\n\9\9\9for dependency, identifier in tick do\n\9\9\9\9task.spawn(function()\n\9\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9\9dependency:onTick(dt)\n\9\9\9\9end)\n\9\9\9end\n\9\9end)\n\9\9RunService.Stepped:Connect(function(time, dt)\n\9\9\9for dependency, identifier in physics do\n\9\9\9\9task.spawn(function()\n\9\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9\9dependency:onPhysics(dt, time)\n\9\9\9\9end)\n\9\9\9end\n\9\9end)\n\9\9if RunService:IsClient() then\n\9\9\9RunService.RenderStepped:Connect(function(dt)\n\9\9\9\9for dependency, identifier in render do\n\9\9\9\9\9task.spawn(function()\n\9\9\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9\9\9dependency:onRender(dt)\n\9\9\9\9\9end)\n\9\9\9\9end\n\9\9\9end)\n\9\9end\n\9\9for _, _binding in start do\n\9\9\9local dependency = _binding[1]\n\9\9\9local identifier = _binding[2]\n\9\9\9task.spawn(function()\n\9\9\9\9debug.setmemorycategory(identifier)\n\9\9\9\9logIfVerbose(\"OnStart \" .. identifier)\n\9\9\9\9dependency:onStart()\n\9\9\9end)\n\9\9end\n\9end\n\9_container.ignite = ignite\n\9--[[\n\9\9*\n\9\9* Preload the specified paths by requiring all ModuleScript descendants.\n\9]]\n\9--[[\n\9\9*\n\9\9* Preload the specified paths by requiring all ModuleScript descendants.\n\9]]\n\9--[[\n\9\9*\n\9\9* Retrieve the identifier for the specified type.\n\9]]\n\9--[[\n\9\9*\n\9\9* Check if the constructor implements the specified interface.\n\9]]\n\9--[[\n\9\9*\n\9\9* Check if object implements the specified interface.\n\9]]\n\9--[[\n\9\9*\n\9\9* Creates a type guard from any arbitrary type.\n\9]]\n\9--[[\n\9\9*\n\9\9* Hash a function using the method used internally by Flamework.\n\9\9* If a context is provided, then Flamework will create a new hash\n\9\9* if the specified string does not have one in that context.\n\9\9* @param str The string to hash\n\9\9* @param context A scope for the hash\n\9]]\n\9--[[\n\9\9*\n\9\9* Utility for use in test suites, not recommended for anything else.\n\9]]\n\9local Testing = {}\n\9do\n\9\9local _container_1 = Testing\n\9\9local function patchDependency(patchedClass, id)\n\9\9\9if id == nil then\n\9\9\9\9error(\"Patching failed, no ID\")\n\9\9\9end\n\9\9\9local _idToObj = Reflect.idToObj\n\9\9\9local _id = id\n\9\9\9local idCtor = _idToObj[_id]\n\9\9\9if idCtor == nil then\n\9\9\9\9error(\"Dependency \" .. (id .. \" was not found and cannot be patched.\"))\n\9\9\9end\n\9\9\9if Modding.getSingletons()[idCtor] ~= nil then\n\9\9\9\9error(id .. \" has already been resolved, continuing is unsafe\")\n\9\9\9end\n\9\9\9local objMetadata = Reflect.metadata[idCtor]\n\9\9\9if not objMetadata then\n\9\9\9\9error(\"Dependency \" .. (id .. \" has no existing metadata.\"))\n\9\9\9end\n\9\9\9Reflect.defineMetadata(idCtor, \"flamework:isPatched\", true)\n\9\9\9Reflect.metadata[idCtor] = nil\n\9\9\9local _metadata = Reflect.metadata\n\9\9\9local _patchedClass = patchedClass\n\9\9\9_metadata[_patchedClass] = objMetadata\n\9\9\9local _objToId = Reflect.objToId\n\9\9\9local _patchedClass_1 = patchedClass\n\9\9\9local _id_1 = id\n\9\9\9_objToId[_patchedClass_1] = _id_1\n\9\9\9local _idToObj_1 = Reflect.idToObj\n\9\9\9local _id_2 = id\n\9\9\9local _patchedClass_2 = patchedClass\n\9\9\9_idToObj_1[_id_2] = _patchedClass_2\n\9\9end\n\9\9_container_1.patchDependency = patchDependency\n\9end\n\9_container.Testing = Testing\nend\n--[[\n\9*\n\9* An internal class used for resolving the Dependency<T> macro.\n]]\ndo\n\9ArtificialDependency = setmetatable({}, {\n\9\9__tostring = function()\n\9\9\9return \"ArtificialDependency\"\n\9\9end,\n\9})\n\9ArtificialDependency.__index = ArtificialDependency\n\9function ArtificialDependency.new(...)\n\9\9local self = setmetatable({}, ArtificialDependency)\n\9\9return self:constructor(...) or self\n\9end\n\9function ArtificialDependency:constructor()\n\9end\nend\nReflect.defineMetadata(ArtificialDependency, \"identifier\", \"$:flamework@ArtificialDependency\")\nReflect.defineMetadata(ArtificialDependency, \"flamework:isArtificial\", true)\n--[[\n\9*\n\9* Register a class as a Service.\n\9*\n\9* @server\n\9* @metadata flamework:implements flamework:parameters\n]]\nlocal Service = Modding.createDecorator(\"Class\", function(descriptor, _param)\n\9local cfg = _param[1]\n\9if RunService:IsServer() then\n\9\9Reflect.defineMetadata(descriptor.object, \"flamework:singleton\", true)\n\9\9local _fn = Reflect\n\9\9local _exp = descriptor.object\n\9\9local _result = cfg\n\9\9if _result ~= nil then\n\9\9\9_result = _result.loadOrder\n\9\9end\n\9\9_fn.defineMetadata(_exp, \"flamework:loadOrder\", _result)\n\9end\nend)\n--[[\n\9*\n\9* Register a class as a Controller.\n\9*\n\9* @client\n\9* @metadata flamework:implements flamework:parameters\n]]\nlocal Controller = Modding.createDecorator(\"Class\", function(descriptor, _param)\n\9local cfg = _param[1]\n\9if RunService:IsClient() then\n\9\9Reflect.defineMetadata(descriptor.object, \"flamework:singleton\", true)\n\9\9local _fn = Reflect\n\9\9local _exp = descriptor.object\n\9\9local _result = cfg\n\9\9if _result ~= nil then\n\9\9\9_result = _result.loadOrder\n\9\9end\n\9\9_fn.defineMetadata(_exp, \"flamework:loadOrder\", _result)\n\9end\nend)\n--[[\n\9*\n\9* Marks this class as an external class.\n\9*\n\9* External classes are designed for packages and won't be\n\9* bootstrapped unless explicitly specified. Excluding this\n\9* inside of a package will make the class load as long as\n\9* it has been loaded.\n]]\nlocal External = Modding.createDecorator(\"Class\", function(descriptor)\n\9Reflect.defineMetadata(descriptor.object, \"flamework:isExternal\", true)\nend)\n--[[\n\9*\n\9* Hook into the OnInit lifecycle event.\n]]\n--[[\n\9*\n\9* Hook into the OnStart lifecycle event.\n]]\n--[[\n\9*\n\9* Hook into the OnTick lifecycle event.\n\9* Equivalent to: RunService.Heartbeat\n]]\n--[[\n\9*\n\9* Hook into the OnPhysics lifecycle event.\n\9* Equivalent to: RunService.Stepped\n]]\n--[[\n\9*\n\9* Hook into the OnRender lifecycle event.\n\9* Equivalent to: RunService.RenderStepped\n\9*\n\9* @client\n]]\nreturn {\n\9Flamework = Flamework,\n\9Service = Service,\n\9Controller = Controller,\n\9External = External,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.flamework"))(__env)
end)
__lua("metadata", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.metadata", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.metadata\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\n--[[\n\9*\n\9* Metadata exposed by the Flamework transformer.\n]]\nlocal Metadata = {}\ndo\n\9local _container = Metadata\n\9--[[\n\9\9*\n\9\9* Runtime metadata generated by the transformer\n\9]]\n\9--[[\n\9\9*\n\9\9* Runtime metadata generated by the transformer\n\9]]\n\9local function getConfigContainer()\n\9\9local current = script\n\9\9while current do\n\9\9\9local flamework = current:FindFirstChild(\"flamework\")\n\9\9\9if flamework then\n\9\9\9\9local metadata = flamework:FindFirstChild(\"config\")\n\9\9\9\9if metadata then\n\9\9\9\9\9return require(metadata)\n\9\9\9\9end\n\9\9\9end\n\9\9\9current = current.Parent\n\9\9end\n\9end\n\9local configContainer\n\9local function getConfig(packageId)\n\9\9local _result\n\9\9if packageId == nil then\n\9\9\9local _result_1 = configContainer\n\9\9\9if _result_1 ~= nil then\n\9\9\9\9_result_1 = _result_1.game\n\9\9\9end\n\9\9\9_result = _result_1\n\9\9else\n\9\9\9local _result_1 = configContainer\n\9\9\9if _result_1 ~= nil then\n\9\9\9\9local _packages = _result_1.packages\n\9\9\9\9local _packageId = packageId\n\9\9\9\9_result_1 = _packages[_packageId]\n\9\9\9end\n\9\9\9_result = _result_1\n\9\9end\n\9\9return _result\n\9end\n\9configContainer = getConfigContainer()\n\9_container.configContainer = configContainer\n\9local _result = configContainer\n\9if _result ~= nil then\n\9\9_result = _result.game\n\9end\n\9local _condition = _result\n\9if _condition == nil then\n\9\9_condition = {}\n\9end\n\9local gameConfig = _condition\n\9_container.gameConfig = gameConfig\n\9local function getLogLevel(packageId)\n\9\9local config = getConfig(packageId)\n\9\9if not config or config.logLevel == nil then\n\9\9\9return \"none\"\n\9\9end\n\9\9return config.logLevel\n\9end\n\9_container.getLogLevel = getLogLevel\nend\nreturn {\n\9Metadata = Metadata,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.metadata"))(__env)
end)
__lua("modding", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.modding", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.modding\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\nlocal TS = _G[script]\nlocal Signal = TS.import(script, TS.getModule(script, \"@rbxts\", \"signal\"))\nlocal Reflect = TS.import(script, script.Parent, \"reflect\").Reflect\nlocal getDeferredConstructor, isConstructor\nlocal Modding = {}\ndo\n\9local _container = Modding\n\9local listeners = {}\n\9local lifecycleListeners = {}\n\9local decoratorListeners = {}\n\9local listenerAdded = Signal.new()\n\9local listenerRemoved = Signal.new()\n\9local listenerAddedEvents = {}\n\9local listenerRemovedEvents = {}\n\9local dependencyResolution = {}\n\9local resolvedSingletons = {}\n\9local loadingList = {}\n\9--[[\n\9\9*\n\9\9* Registers a listener for lifecycle events.\n\9]]\n\9local function addListener(object)\n\9\9local listener = {\n\9\9\9eventIds = {},\n\9\9\9involvement = {},\n\9\9}\n\9\9for _, lifecycleEvents in Reflect.getMetadatas(object, \"flamework:implements\") do\n\9\9\9for _1, lifecycleEvent in lifecycleEvents do\n\9\9\9\9if listener.eventIds[lifecycleEvent] ~= nil then\n\9\9\9\9\9continue\n\9\9\9\9end\n\9\9\9\9local lifecycleListener = lifecycleListeners[lifecycleEvent]\n\9\9\9\9if not lifecycleListener then\n\9\9\9\9\9lifecycleListener = {}\n\9\9\9\9\9local _lifecycleListener = lifecycleListener\n\9\9\9\9\9lifecycleListeners[lifecycleEvent] = _lifecycleListener\n\9\9\9\9end\n\9\9\9\9local _lifecycleListener = lifecycleListener\n\9\9\9\9local _object = object\n\9\9\9\9_lifecycleListener[_object] = true\n\9\9\9\9listener.eventIds[lifecycleEvent] = true\n\9\9\9\9local _involvement = listener.involvement\n\9\9\9\9local _lifecycleListener_1 = lifecycleListener\n\9\9\9\9table.insert(_involvement, _lifecycleListener_1)\n\9\9\9\9local _result = listenerAddedEvents[lifecycleEvent]\n\9\9\9\9if _result ~= nil then\n\9\9\9\9\9_result:Fire(object)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9local decorators = Reflect.getMetadata(object, \"flamework:decorators\")\n\9\9if decorators then\n\9\9\9for _, decorator in decorators do\n\9\9\9\9if listener.eventIds[decorator] ~= nil then\n\9\9\9\9\9continue\n\9\9\9\9end\n\9\9\9\9local decoratorListener = decoratorListeners[decorator]\n\9\9\9\9if not decoratorListener then\n\9\9\9\9\9decoratorListener = {}\n\9\9\9\9\9local _decoratorListener = decoratorListener\n\9\9\9\9\9decoratorListeners[decorator] = _decoratorListener\n\9\9\9\9end\n\9\9\9\9local _decoratorListener = decoratorListener\n\9\9\9\9local _object = object\n\9\9\9\9_decoratorListener[_object] = true\n\9\9\9\9listener.eventIds[decorator] = true\n\9\9\9\9local _involvement = listener.involvement\n\9\9\9\9local _decoratorListener_1 = decoratorListener\n\9\9\9\9table.insert(_involvement, _decoratorListener_1)\n\9\9\9\9local _result = listenerAddedEvents[decorator]\n\9\9\9\9if _result ~= nil then\n\9\9\9\9\9_result:Fire(object)\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9local _object = object\n\9\9listeners[_object] = listener\n\9\9listenerAdded:Fire(object)\n\9end\n\9_container.addListener = addListener\n\9--[[\n\9\9*\n\9\9* Removes a listener for lifecycle events and decorators.\n\9]]\n\9local function removeListener(object)\n\9\9local _object = object\n\9\9local listener = listeners[_object]\n\9\9if not listener then\n\9\9\9return nil\n\9\9end\n\9\9for _, set in listener.involvement do\n\9\9\9local _object_1 = object\n\9\9\9set[_object_1] = nil\n\9\9end\n\9\9for id in listener.eventIds do\n\9\9\9local _result = listenerRemovedEvents[id]\n\9\9\9if _result ~= nil then\n\9\9\9\9_result:Fire(object)\n\9\9\9end\n\9\9end\n\9\9local _object_1 = object\n\9\9listeners[_object_1] = nil\n\9\9listenerRemoved:Fire(object)\n\9end\n\9_container.removeListener = removeListener\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9\9* Fires whenever any listener is added.\n\9\9*\n\9\9* Fires for all existing listeners.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9\9* Fires whenever a listener has a decorator with the specified ID.\n\9\9*\n\9\9* Fires for all existing listeners.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9\9* Fires whenever a listener has a lifecycle event with the specified ID.\n\9\9*\n\9\9* Fires for all existing listeners.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener added event.\n\9]]\n\9local function onListenerAdded(func, id)\n\9\9if id ~= nil then\n\9\9\9local _id = id\n\9\9\9local listenerAddedEvent = listenerAddedEvents[_id]\n\9\9\9if not listenerAddedEvent then\n\9\9\9\9local _exp = id\n\9\9\9\9listenerAddedEvent = Signal.new()\n\9\9\9\9local _listenerAddedEvent = listenerAddedEvent\n\9\9\9\9listenerAddedEvents[_exp] = _listenerAddedEvent\n\9\9\9end\n\9\9\9local _id_1 = id\n\9\9\9local _condition = lifecycleListeners[_id_1]\n\9\9\9if not _condition then\n\9\9\9\9local _id_2 = id\n\9\9\9\9_condition = decoratorListeners[_id_2]\n\9\9\9end\n\9\9\9local existingListeners = _condition\n\9\9\9if existingListeners then\n\9\9\9\9for listener in existingListeners do\n\9\9\9\9\9task.spawn(func, listener)\n\9\9\9\9end\n\9\9\9end\n\9\9\9return listenerAddedEvent:Connect(func)\n\9\9else\n\9\9\9for listener in listeners do\n\9\9\9\9task.spawn(func, listener)\n\9\9\9end\n\9\9\9return listenerAdded:Connect(func)\n\9\9end\n\9end\n\9_container.onListenerAdded = onListenerAdded\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9\9*\n\9\9* Fires whenever any listener is removed.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9\9*\n\9\9* Fires whenever a listener has a decorator with the specified ID.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9\9*\n\9\9* Fires whenever a listener has a lifecycle event with the specified ID.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a listener removed event.\n\9]]\n\9local function onListenerRemoved(func, id)\n\9\9if id ~= nil then\n\9\9\9local _id = id\n\9\9\9local listenerRemovedEvent = listenerRemovedEvents[_id]\n\9\9\9if not listenerRemovedEvent then\n\9\9\9\9local _exp = id\n\9\9\9\9listenerRemovedEvent = Signal.new()\n\9\9\9\9local _listenerRemovedEvent = listenerRemovedEvent\n\9\9\9\9listenerRemovedEvents[_exp] = _listenerRemovedEvent\n\9\9\9end\n\9\9\9return listenerRemovedEvent:Connect(func)\n\9\9else\n\9\9\9return listenerRemoved:Connect(func)\n\9\9end\n\9end\n\9_container.onListenerRemoved = onListenerRemoved\n\9--[[\n\9\9*\n\9\9* Registers a class decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a method decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a property decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a decorator.\n\9]]\n\9local defineDecoratorMetadata\n\9local function createDecorator(_kind, func)\n\9\9return {\n\9\9\9func = function(descriptor, config)\n\9\9\9\9defineDecoratorMetadata(descriptor, config)\n\9\9\9\9func(descriptor, config)\n\9\9\9end,\n\9\9}\n\9end\n\9_container.createDecorator = createDecorator\n\9--[[\n\9\9*\n\9\9* Registers a metadata class decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a metadata method decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a metadata property decorator.\n\9]]\n\9--[[\n\9\9*\n\9\9* Registers a metadata decorator.\n\9]]\n\9local function createMetaDecorator(_kind)\n\9\9return {\n\9\9\9func = function(descriptor, config)\n\9\9\9\9defineDecoratorMetadata(descriptor, config)\n\9\9\9end,\n\9\9}\n\9end\n\9_container.createMetaDecorator = createMetaDecorator\n\9--[[\n\9\9*\n\9\9* Retrieves registered decorators.\n\9]]\n\9local function getDecorators(id)\n\9\9local _arg0 = id ~= nil\n\9\9assert(_arg0)\n\9\9local _decorators = Reflect.decorators\n\9\9local _id = id\n\9\9local decorators = _decorators[_id]\n\9\9if not decorators then\n\9\9\9return {}\n\9\9end\n\9\9local _arg0_1 = function(object)\n\9\9\9local decoratorConfig = Reflect.getOwnMetadata(object, \"flamework:decorators.\" .. id)\n\9\9\9assert(decoratorConfig)\n\9\9\9return {\n\9\9\9\9object = object,\n\9\9\9\9arguments = decoratorConfig.arguments,\n\9\9\9}\n\9\9end\n\9\9-- â–¼ ReadonlyArray.map â–¼\n\9\9local _newValue = table.create(#decorators)\n\9\9for _k, _v in decorators do\n\9\9\9_newValue[_k] = _arg0_1(_v, _k - 1, decorators)\n\9\9end\n\9\9-- â–² ReadonlyArray.map â–²\n\9\9return _newValue\n\9end\n\9_container.getDecorators = getDecorators\n\9--[[\n\9\9*\n\9\9* Creates a map of every property using the specified decorator.\n\9]]\n\9local getDecorator\n\9local function getPropertyDecorators(obj, id)\n\9\9local decorators = {}\n\9\9local _arg0 = id ~= nil\n\9\9assert(_arg0)\n\9\9for _, prop in Reflect.getProperties(obj) do\n\9\9\9local decorator = getDecorator(obj, prop, id)\n\9\9\9if decorator then\n\9\9\9\9decorators[prop] = decorator\n\9\9\9end\n\9\9end\n\9\9return decorators\n\9end\n\9_container.getPropertyDecorators = getPropertyDecorators\n\9--[[\n\9\9*\n\9\9* Retrieves a decorator from an object or its properties.\n\9]]\n\9function getDecorator(object, property, id)\n\9\9local decorator = Reflect.getMetadata(object, \"flamework:decorators.\" .. tostring(id), property)\n\9\9if not decorator then\n\9\9\9return nil\n\9\9end\n\9\9return decorator\n\9end\n\9_container.getDecorator = getDecorator\n\9--[[\n\9\9*\n\9\9* Retrieves a singleton or instantiates one if it does not exist.\n\9]]\n\9local createDependency\n\9local function resolveSingleton(ctor)\n\9\9local _ctor = ctor\n\9\9local resolvedDependency = resolvedSingletons[_ctor]\n\9\9if resolvedDependency ~= nil then\n\9\9\9return resolvedDependency\n\9\9end\n\9\9local _ctor_1 = ctor\n\9\9if table.find(loadingList, _ctor_1) ~= nil then\n\9\9\9-- â–¼ ReadonlyArray.join â–¼\n\9\9\9local _result = table.create(#loadingList)\n\9\9\9for _k, _v in loadingList do\n\9\9\9\9_result[_k] = tostring(_v)\n\9\9\9end\n\9\9\9-- â–² ReadonlyArray.join â–²\n\9\9\9error(\"Circular dependency detected \" .. (table.concat(_result, \" <=> \") .. (\" <=> \" .. tostring(ctor))))\n\9\9end\n\9\9local _ctor_2 = ctor\n\9\9table.insert(loadingList, _ctor_2)\n\9\9-- Flamework can resolve singletons at any arbitrary point,\n\9\9-- so we should fetch custom dependency resolution (added via decorator) through the Reflect api.\n\9\9local opts = Reflect.getOwnMetadata(ctor, \"flamework:dependency_resolution\")\n\9\9local dependency = createDependency(ctor, opts)\n\9\9local _ctor_3 = ctor\n\9\9resolvedSingletons[_ctor_3] = dependency\n\9\9loadingList[#loadingList] = nil\n\9\9addListener(dependency)\n\9\9return dependency\n\9end\n\9_container.resolveSingleton = resolveSingleton\n\9-- * @internal Used for bootstrapping\n\9local function getSingletons()\n\9\9return resolvedSingletons\n\9end\n\9_container.getSingletons = getSingletons\n\9--[[\n\9\9*\n\9\9* Modifies dependency resolution for a specific ID.\n\9\9*\n\9\9* If a function is passed, it will be called, passing the target constructor, every time that ID needs to be resolved.\n\9\9* Otherwise, the passed object is returned directly.\n\9]]\n\9local function registerDependency(dependency, id)\n\9\9local _arg0 = id ~= nil\n\9\9assert(_arg0)\n\9\9local _dependency = dependency\n\9\9if type(_dependency) == \"function\" then\n\9\9\9local _id = id\n\9\9\9local _dependency_1 = dependency\n\9\9\9dependencyResolution[_id] = _dependency_1\n\9\9else\n\9\9\9local _id = id\n\9\9\9local _arg1 = function()\n\9\9\9\9return dependency\n\9\9\9end\n\9\9\9dependencyResolution[_id] = _arg1\n\9\9end\n\9end\n\9_container.registerDependency = registerDependency\n\9--[[\n\9\9*\n\9\9* Instantiates this class using dependency injection.\n\9]]\n\9local createDeferredDependency\n\9function createDependency(ctor, options)\n\9\9if options == nil then\n\9\9\9options = {}\n\9\9end\n\9\9local _binding = createDeferredDependency(ctor, options)\n\9\9local obj = _binding[1]\n\9\9local construct = _binding[2]\n\9\9construct()\n\9\9return obj\n\9end\n\9_container.createDependency = createDependency\n\9--[[\n\9\9*\n\9\9* Creates an object for this class and returns a deferred constructor.\n\9]]\n\9local resolveDependency\n\9function createDeferredDependency(ctor, options)\n\9\9if options == nil then\n\9\9\9options = {}\n\9\9end\n\9\9local _binding = getDeferredConstructor(ctor)\n\9\9local obj = _binding[1]\n\9\9local construct = _binding[2]\n\9\9return { obj, function()\n\9\9\9local dependencies = Reflect.getMetadata(ctor, \"flamework:parameters\")\n\9\9\9local constructorDependencies = {}\n\9\9\9if dependencies then\n\9\9\9\9for index, dependencyId in pairs(dependencies) do\n\9\9\9\9\9constructorDependencies[index - 1 + 1] = resolveDependency(ctor, dependencyId, index - 1, options)\n\9\9\9\9end\n\9\9\9end\n\9\9\9construct(unpack(constructorDependencies))\n\9\9end }\n\9end\n\9_container.createDeferredDependency = createDeferredDependency\n\9--[[\n\9\9*\n\9\9* Dependency resolution logic.\n\9\9* @internal\n\9]]\n\9function resolveDependency(ctor, dependencyId, index, options)\n\9\9if options.handle ~= nil then\n\9\9\9local dependency = options.handle(dependencyId, index)\n\9\9\9if dependency ~= nil then\n\9\9\9\9return dependency\n\9\9\9end\n\9\9end\n\9\9local _dependencyId = dependencyId\n\9\9local resolution = dependencyResolution[_dependencyId]\n\9\9if resolution ~= nil then\n\9\9\9return resolution(ctor)\n\9\9end\n\9\9local _idToObj = Reflect.idToObj\n\9\9local _dependencyId_1 = dependencyId\n\9\9local dependencyCtor = _idToObj[_dependencyId_1]\n\9\9if dependencyCtor and isConstructor(dependencyCtor) then\n\9\9\9return resolveSingleton(dependencyCtor)\n\9\9end\n\9\9if string.sub(dependencyId, 1, 2) == \"$p\" then\n\9\9\9if string.sub(dependencyId, 1, 3) == \"$ps\" then\n\9\9\9\9return string.sub(dependencyId, 5)\n\9\9\9end\n\9\9\9if string.sub(dependencyId, 1, 3) == \"$pn\" then\n\9\9\9\9local _condition = tonumber(string.sub(dependencyId, 5))\n\9\9\9\9if _condition == nil then\n\9\9\9\9\9_condition = 0\n\9\9\9\9end\n\9\9\9\9return _condition\n\9\9\9end\n\9\9\9if options.handlePrimitive ~= nil then\n\9\9\9\9return options.handlePrimitive(dependencyId, index)\n\9\9\9end\n\9\9\9error(\"Unexpected primitive dependency '\" .. (dependencyId .. (\"' while constructing \" .. tostring(ctor))))\n\9\9end\n\9\9error(\"Could not find constructor for \" .. (dependencyId .. (\" while constructing \" .. tostring(ctor))))\n\9end\n\9_container.resolveDependency = resolveDependency\n\9--[[\n\9\9*\n\9\9* @hidden\n\9\9* @deprecated\n\9]]\n\9local function macro(values, directValue)\n\9\9local _values = values\n\9\9if type(_values) == \"string\" then\n\9\9\9return {\n\9\9\9\9[values] = directValue,\n\9\9\9}\n\9\9end\n\9\9local result = {}\n\9\9for _, _binding in values do\n\9\9\9local name = _binding[1]\n\9\9\9local value = _binding[2]\n\9\9\9result[name] = value\n\9\9end\n\9\9return result\n\9end\n\9_container.macro = macro\n\9function defineDecoratorMetadata(descriptor, config)\n\9\9local propertyKey = if descriptor.isStatic then \"static:\" .. descriptor.property else descriptor.property\n\9\9Reflect.defineMetadata(descriptor.object, \"flamework:decorators.\" .. descriptor.id, {\n\9\9\9arguments = config,\n\9\9}, propertyKey)\n\9\9local decoratorList = Reflect.getMetadata(descriptor.object, \"flamework:decorators\", propertyKey)\n\9\9if not decoratorList then\n\9\9\9local _fn = Reflect\n\9\9\9local _exp = descriptor.object\n\9\9\9decoratorList = {}\n\9\9\9_fn.defineMetadata(_exp, \"flamework:decorators\", decoratorList, propertyKey)\n\9\9end\n\9\9local _decoratorList = decoratorList\n\9\9local _id = descriptor.id\n\9\9table.insert(_decoratorList, _id)\n\9end\nend\nfunction isConstructor(obj)\n\9return obj.new ~= nil and obj.constructor ~= nil\nend\nfunction getDeferredConstructor(ctor)\n\9local obj = setmetatable({}, ctor)\n\9return { obj, function(...)\n\9\9local args = { ... }\n\9\9local result = obj:constructor(unpack(args))\n\9\9local _arg0 = result == nil or result == obj\n\9\9assert(_arg0, \"Deferred constructors are not allowed to return values.\")\n\9end }\nend\nreturn {\n\9Modding = Modding,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.modding"))(__env)
end)
__lua("reflect", "ModuleScript", "bundle-ex.include.node_modules.@flamework.core.out.reflect", "bundle-ex.include.node_modules.@flamework.core.out", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@flamework.core.out.reflect\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.0.2\n--[[\n\9*\n\9* Reflection/metadata API\n]]\nlocal Reflect = {}\ndo\n\9local _container = Reflect\n\9-- object -> property -> key -> value\n\9local metadata = setmetatable({}, {\n\9\9__mode = \"k\",\n\9})\n\9_container.metadata = metadata\n\9local decorators = {}\n\9_container.decorators = decorators\n\9local idToObj = {}\n\9_container.idToObj = idToObj\n\9local objToId = {}\n\9_container.objToId = objToId\n\9local NO_PROP_MARKER = {}\n\9local function getObjMetadata(obj, prop, create)\n\9\9local _condition = prop\n\9\9if _condition == nil then\n\9\9\9_condition = NO_PROP_MARKER\n\9\9end\n\9\9local realProp = _condition\n\9\9if create then\n\9\9\9local _obj = obj\n\9\9\9local objMetadata = metadata[_obj]\n\9\9\9if not objMetadata then\n\9\9\9\9local _exp = obj\n\9\9\9\9objMetadata = {}\n\9\9\9\9local _objMetadata = objMetadata\n\9\9\9\9metadata[_exp] = _objMetadata\n\9\9\9end\n\9\9\9local propMetadata = objMetadata[realProp]\n\9\9\9if not propMetadata then\n\9\9\9\9local _objMetadata = objMetadata\n\9\9\9\9propMetadata = {}\n\9\9\9\9local _propMetadata = propMetadata\n\9\9\9\9_objMetadata[realProp] = _propMetadata\n\9\9\9end\n\9\9\9return propMetadata\n\9\9else\n\9\9\9local _obj = obj\n\9\9\9local _result = metadata[_obj]\n\9\9\9if _result ~= nil then\n\9\9\9\9_result = _result[realProp]\n\9\9\9end\n\9\9\9return _result\n\9\9end\n\9end\n\9local function getParentConstructor(obj)\n\9\9local metatable = getmetatable(obj)\n\9\9if metatable and type(metatable) == \"table\" then\n\9\9\9return rawget(metatable, \"__index\")\n\9\9end\n\9end\n\9--[[\n\9\9*\n\9\9* Apply metadata onto this object.\n\9]]\n\9local function defineMetadata(obj, key, value, property)\n\9\9-- 'identifier' is a special, unique ID across all metadata classes.\n\9\9if key == \"identifier\" then\n\9\9\9local _value = value\n\9\9\9local _arg0 = type(_value) == \"string\"\n\9\9\9assert(_arg0, \"identifier must be a string.\")\n\9\9\9local _obj = obj\n\9\9\9local _arg0_1 = not (objToId[_obj] ~= nil)\n\9\9\9assert(_arg0_1, \"obj is already registered.\")\n\9\9\9local _value_1 = value\n\9\9\9local _arg0_2 = not (idToObj[_value_1] ~= nil)\n\9\9\9assert(_arg0_2, \"id is already registered.\")\n\9\9\9local _obj_1 = obj\n\9\9\9local _value_2 = value\n\9\9\9objToId[_obj_1] = _value_2\n\9\9\9local _value_3 = value\n\9\9\9local _obj_2 = obj\n\9\9\9idToObj[_value_3] = _obj_2\n\9\9end\n\9\9local metadata = getObjMetadata(obj, property, true)\n\9\9local _key = key\n\9\9local _value = value\n\9\9metadata[_key] = _value\n\9end\n\9_container.defineMetadata = defineMetadata\n\9--[[\n\9\9*\n\9\9* Apply metadata in batch onto this object.\n\9]]\n\9local function defineMetadataBatch(obj, list, property)\n\9\9local metadata = getObjMetadata(obj, property, true)\n\9\9for key, value in pairs(list) do\n\9\9\9metadata[key] = value\n\9\9end\n\9end\n\9_container.defineMetadataBatch = defineMetadataBatch\n\9--[[\n\9\9*\n\9\9* Delete metadata from this object.\n\9]]\n\9local function deleteMetadata(obj, key, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _key = key\n\9\9\9_result[_key] = nil\n\9\9end\n\9end\n\9_container.deleteMetadata = deleteMetadata\n\9--[[\n\9\9*\n\9\9* Get metadata from this object.\n\9\9* Type parameter is an assertion.\n\9]]\n\9local function getOwnMetadata(obj, key, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _key = key\n\9\9\9_result = _result[_key]\n\9\9end\n\9\9return _result\n\9end\n\9_container.getOwnMetadata = getOwnMetadata\n\9--[[\n\9\9*\n\9\9* Check if this object has the specified metadata key.\n\9]]\n\9local function hasOwnMetadata(obj, key, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _key = key\n\9\9\9_result = _result[_key] ~= nil\n\9\9end\n\9\9local _condition = _result\n\9\9if _condition == nil then\n\9\9\9_condition = false\n\9\9end\n\9\9return _condition\n\9end\n\9_container.hasOwnMetadata = hasOwnMetadata\n\9--[[\n\9\9*\n\9\9* Retrieve all metadata keys for this object.\n\9]]\n\9local function getOwnMetadataKeys(obj, property)\n\9\9local metadata = getObjMetadata(obj, property)\n\9\9local keys = {}\n\9\9local _result = metadata\n\9\9if _result ~= nil then\n\9\9\9local _arg0 = function(_, key)\n\9\9\9\9local _key = key\n\9\9\9\9table.insert(keys, _key)\n\9\9\9\9return #keys\n\9\9\9end\n\9\9\9for _k, _v in _result do\n\9\9\9\9_arg0(_v, _k, _result)\n\9\9\9end\n\9\9end\n\9\9return keys\n\9end\n\9_container.getOwnMetadataKeys = getOwnMetadataKeys\n\9--[[\n\9\9*\n\9\9* Retrieves all properties (that contain metadata) on this object.\n\9]]\n\9local function getOwnProperties(obj)\n\9\9local _obj = obj\n\9\9local properties = metadata[_obj]\n\9\9if not properties then\n\9\9\9return {}\n\9\9end\n\9\9local keys = {}\n\9\9for key in properties do\n\9\9\9if key ~= NO_PROP_MARKER then\n\9\9\9\9table.insert(keys, key)\n\9\9\9end\n\9\9end\n\9\9return keys\n\9end\n\9_container.getOwnProperties = getOwnProperties\n\9--[[\n\9\9*\n\9\9* Retrieve all values for the specified key from the object and its parents.\n\9\9* Type parameter is an assertion.\n\9]]\n\9local function getMetadatas(obj, key, property)\n\9\9local values = {}\n\9\9local value = getOwnMetadata(obj, key, property)\n\9\9if value ~= nil then\n\9\9\9table.insert(values, value)\n\9\9end\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9local _exp = getMetadatas(parent, key, property)\n\9\9\9local _arg0 = function(value)\n\9\9\9\9local _value = value\n\9\9\9\9table.insert(values, _value)\n\9\9\9\9return #values\n\9\9\9end\n\9\9\9for _k, _v in _exp do\n\9\9\9\9_arg0(_v, _k - 1, _exp)\n\9\9\9end\n\9\9end\n\9\9return values\n\9end\n\9_container.getMetadatas = getMetadatas\n\9--[[\n\9\9*\n\9\9* Get metadata from this object or its parents.\n\9\9* Type parameter is an assertion.\n\9]]\n\9local function getMetadata(obj, key, property)\n\9\9local value = getOwnMetadata(obj, key, property)\n\9\9if value ~= nil then\n\9\9\9return value\n\9\9end\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9return getMetadata(parent, key, property)\n\9\9end\n\9end\n\9_container.getMetadata = getMetadata\n\9--[[\n\9\9*\n\9\9* Check if this object or any of its parents has the specified metadata key.\n\9]]\n\9local function hasMetadata(obj, key, property)\n\9\9local value = hasOwnMetadata(obj, key, property)\n\9\9if value then\n\9\9\9return value\n\9\9end\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9return hasMetadata(parent, key, property)\n\9\9end\n\9\9return false\n\9end\n\9_container.hasMetadata = hasMetadata\n\9--[[\n\9\9*\n\9\9* Retrieve all metadata keys for this object and its parents.\n\9]]\n\9local function getMetadataKeys(obj, property)\n\9\9local _set = {}\n\9\9for _, _v in getOwnMetadataKeys(obj, property) do\n\9\9\9_set[_v] = true\n\9\9end\n\9\9local keys = _set\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9local _exp = getMetadataKeys(parent, property)\n\9\9\9local _arg0 = function(key)\n\9\9\9\9local _key = key\n\9\9\9\9keys[_key] = true\n\9\9\9\9return keys\n\9\9\9end\n\9\9\9for _k, _v in _exp do\n\9\9\9\9_arg0(_v, _k - 1, _exp)\n\9\9\9end\n\9\9end\n\9\9local _array = {}\n\9\9local _length = #_array\n\9\9for _v in keys do\n\9\9\9_length += 1\n\9\9\9_array[_length] = _v\n\9\9end\n\9\9return _array\n\9end\n\9_container.getMetadataKeys = getMetadataKeys\n\9--[[\n\9\9*\n\9\9* Retrieves all properties (that contain metadata) on this object and its parents.\n\9]]\n\9local function getProperties(obj)\n\9\9local _set = {}\n\9\9for _, _v in getOwnProperties(obj) do\n\9\9\9_set[_v] = true\n\9\9end\n\9\9local keys = _set\n\9\9local parent = getParentConstructor(obj)\n\9\9if parent then\n\9\9\9local _exp = getProperties(parent)\n\9\9\9local _arg0 = function(key)\n\9\9\9\9local _key = key\n\9\9\9\9keys[_key] = true\n\9\9\9\9return keys\n\9\9\9end\n\9\9\9for _k, _v in _exp do\n\9\9\9\9_arg0(_v, _k - 1, _exp)\n\9\9\9end\n\9\9end\n\9\9local _array = {}\n\9\9local _length = #_array\n\9\9for _v in keys do\n\9\9\9_length += 1\n\9\9\9_array[_length] = _v\n\9\9end\n\9\9return _array\n\9end\n\9_container.getProperties = getProperties\n\9-- * @hidden\n\9local function decorate(object, id, rawDecoration, args, property, isStatic)\n\9\9if isStatic == nil then\n\9\9\9isStatic = false\n\9\9end\n\9\9local decoration = rawDecoration\n\9\9local descriptor = {\n\9\9\9id = id,\n\9\9\9isStatic = isStatic,\n\9\9\9object = object,\n\9\9\9property = property,\n\9\9}\n\9\9if property == nil then\n\9\9\9local _id = id\n\9\9\9local decoratedObjects = decorators[_id]\n\9\9\9if not decoratedObjects then\n\9\9\9\9local _exp = id\n\9\9\9\9decoratedObjects = {}\n\9\9\9\9local _decoratedObjects = decoratedObjects\n\9\9\9\9decorators[_exp] = _decoratedObjects\n\9\9\9end\n\9\9\9local _decoratedObjects = decoratedObjects\n\9\9\9local _object = object\n\9\9\9table.insert(_decoratedObjects, _object)\n\9\9end\n\9\9decoration.func(descriptor, args)\n\9end\n\9_container.decorate = decorate\nend\nreturn {\n\9Reflect = Reflect,\n}\n", "bundle-ex.include.node_modules.@flamework.core.out.reflect"))(__env)
end)
__rbx("@rbxts", "Folder", "bundle-ex.include.node_modules.@rbxts", "bundle-ex.include.node_modules")
__rbx("compiler-types", "Folder", "bundle-ex.include.node_modules.@rbxts.compiler-types", "bundle-ex.include.node_modules.@rbxts")
__rbx("types", "Folder", "bundle-ex.include.node_modules.@rbxts.compiler-types.types", "bundle-ex.include.node_modules.@rbxts.compiler-types")
__rbx("maid", "Folder", "bundle-ex.include.node_modules.@rbxts.maid", "bundle-ex.include.node_modules.@rbxts")
__lua("Maid", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.maid.Maid", "bundle-ex.include.node_modules.@rbxts.maid", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.maid.Maid\")local script,require=_.script,_.require ---\9Manages the cleaning of events and other things.\n-- Useful for encapsulating state and make deconstructors easy\n-- @classmod Maid\n-- @see Signal\n\nlocal Maid = {}\nMaid.ClassName = \"Maid\"\n\n--- Returns a new Maid object\n-- @constructor Maid.new()\n-- @treturn Maid\nfunction Maid.new()\n\9local self = {}\n\n\9self._tasks = {}\n\n\9return setmetatable(self, Maid)\nend\n\n--- Returns Maid[key] if not part of Maid metatable\n-- @return Maid[key] value\nfunction Maid:__index(index)\n\9if Maid[index] then\n\9\9return Maid[index]\n\9else\n\9\9return self._tasks[index]\n\9end\nend\n\n--- Add a task to clean up\n-- @usage\n-- Maid[key] = (function)         Adds a task to perform\n-- Maid[key] = (event connection) Manages an event connection\n-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.\n-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method\n-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,\n--                                it is destroyed.\nfunction Maid:__newindex(index, newTask)\n\9if Maid[index] ~= nil then\n\9\9error((\"'%s' is reserved\"):format(tostring(index)), 2)\n\9end\n\n\9local tasks = self._tasks\n\9local oldTask = tasks[index]\n\9tasks[index] = newTask\n\n\9if oldTask then\n\9\9if type(oldTask) == \"function\" then\n\9\9\9oldTask()\n\9\9elseif typeof(oldTask) == \"RBXScriptConnection\" then\n\9\9\9oldTask:Disconnect()\n\9\9elseif oldTask.Destroy then\n\9\9\9oldTask:Destroy()\n\9\9end\n\9end\nend\n\n--- Same as indexing, but uses an incremented number as a key.\n-- @param task An item to clean\n-- @treturn number taskId\nfunction Maid:GiveTask(task)\n\9assert(task, \"Task cannot be false or nil\")\n\n\9local taskId = #self._tasks+1\n\9self[taskId] = task\n\n\9if type(task) == \"table\" and (not task.Destroy) then\n\9\9warn(\"[Maid.GiveTask] - Gave table task without .Destroy\\n\\n\" .. debug.traceback())\n\9end\n\n\9return taskId\nend\n\nfunction Maid:GivePromise(promise)\n\9if not promise:IsPending() then\n\9\9return promise\n\9end\n\n\9local newPromise = promise.resolved(promise)\n\9local id = self:GiveTask(newPromise)\n\n\9-- Ensure GC\n\9newPromise:Finally(function()\n\9\9self[id] = nil\n\9end)\n\n\9return newPromise\nend\n\n--- Cleans up all tasks.\n-- @alias Destroy\nfunction Maid:DoCleaning()\n\9local tasks = self._tasks\n\n\9-- Disconnect all events first as we know this is safe\n\9for index, task in pairs(tasks) do\n\9\9if typeof(task) == \"RBXScriptConnection\" then\n\9\9\9tasks[index] = nil\n\9\9\9task:Disconnect()\n\9\9end\n\9end\n\n\9-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid\n\9local index, task = next(tasks)\n\9while task ~= nil do\n\9\9tasks[index] = nil\n\9\9if type(task) == \"function\" then\n\9\9\9task()\n\9\9elseif typeof(task) == \"RBXScriptConnection\" then\n\9\9\9task:Disconnect()\n\9\9elseif task.Destroy then\n\9\9\9task:Destroy()\n\9\9end\n\9\9index, task = next(tasks)\n\9end\nend\n\n--- Alias for DoCleaning()\n-- @function Destroy\nMaid.Destroy = Maid.DoCleaning\n\nreturn Maid", "bundle-ex.include.node_modules.@rbxts.maid.Maid"))(__env)
end)
__lua("object-utils", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.object-utils", "bundle-ex.include.node_modules.@rbxts", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.object-utils\")local script,require=_.script,_.require local HttpService = game:GetService(\"HttpService\")\n\nlocal Object = {}\n\nfunction Object.keys(object)\n\9local result = table.create(#object)\n\9for key in pairs(object) do\n\9\9result[#result + 1] = key\n\9end\n\9return result\nend\n\nfunction Object.values(object)\n\9local result = table.create(#object)\n\9for _, value in pairs(object) do\n\9\9result[#result + 1] = value\n\9end\n\9return result\nend\n\nfunction Object.entries(object)\n\9local result = table.create(#object)\n\9for key, value in pairs(object) do\n\9\9result[#result + 1] = { key, value }\n\9end\n\9return result\nend\n\nfunction Object.assign(toObj, ...)\n\9for i = 1, select(\"#\", ...) do\n\9\9local arg = select(i, ...)\n\9\9if type(arg) == \"table\" then\n\9\9\9for key, value in pairs(arg) do\n\9\9\9\9toObj[key] = value\n\9\9\9end\n\9\9end\n\9end\n\9return toObj\nend\n\nfunction Object.copy(object)\n\9local result = table.create(#object)\n\9for k, v in pairs(object) do\n\9\9result[k] = v\n\9end\n\9return result\nend\n\nlocal function deepCopyHelper(object, encountered)\n\9local result = table.create(#object)\n\9encountered[object] = result\n\n\9for k, v in pairs(object) do\n\9\9if type(k) == \"table\" then\n\9\9\9k = encountered[k] or deepCopyHelper(k, encountered)\n\9\9end\n\n\9\9if type(v) == \"table\" then\n\9\9\9v = encountered[v] or deepCopyHelper(v, encountered)\n\9\9end\n\n\9\9result[k] = v\n\9end\n\n\9return result\nend\n\nfunction Object.deepCopy(object)\n\9return deepCopyHelper(object, {})\nend\n\nfunction Object.deepEquals(a, b)\n\9-- a[k] == b[k]\n\9for k in pairs(a) do\n\9\9local av = a[k]\n\9\9local bv = b[k]\n\9\9if type(av) == \"table\" and type(bv) == \"table\" then\n\9\9\9local result = Object.deepEquals(av, bv)\n\9\9\9if not result then\n\9\9\9\9return false\n\9\9\9end\n\9\9elseif av ~= bv then\n\9\9\9return false\n\9\9end\n\9end\n\n\9-- extra keys in b\n\9for k in pairs(b) do\n\9\9if a[k] == nil then\n\9\9\9return false\n\9\9end\n\9end\n\n\9return true\nend\n\nfunction Object.toString(data)\n\9return HttpService:JSONEncode(data)\nend\n\nfunction Object.isEmpty(object)\n\9return next(object) == nil\nend\n\nfunction Object.fromEntries(entries)\n\9local entriesLen = #entries\n\n\9local result = table.create(entriesLen)\n\9if entries then\n\9\9for i = 1, entriesLen do\n\9\9\9local pair = entries[i]\n\9\9\9result[pair[1]] = pair[2]\n\9\9end\n\9end\n\9return result\nend\n\nreturn Object\n", "bundle-ex.include.node_modules.@rbxts.object-utils"))(__env)
end)
__lua("services", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.services", "bundle-ex.include.node_modules.@rbxts", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.services\")local script,require=_.script,_.require return setmetatable({}, {\n\9__index = function(self, serviceName)\n\9\9local service = game:GetService(serviceName)\n\9\9self[serviceName] = service\n\9\9return service\n\9end,\n})\n", "bundle-ex.include.node_modules.@rbxts.services"))(__env)
end)
__lua("signal", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.signal", "bundle-ex.include.node_modules.@rbxts", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.signal\")local script,require=_.script,_.require local Signal = {}\nSignal.__index = Signal\n\nfunction Signal.new()\n\9return setmetatable({ Bindable = Instance.new(\"BindableEvent\") }, Signal)\nend\n\nfunction Signal:Connect(Callback)\n\9return self.Bindable.Event:Connect(function(GetArguments)\n\9\9Callback(GetArguments())\n\9end)\nend\n\nfunction Signal:Once(Callback)\n\9return self.Bindable.Event:Once(function(GetArguments)\n\9\9Callback(GetArguments())\n\9end)\nend\n\nfunction Signal:ConnectParallel(Callback)\n\9return self.Bindable.Event:ConnectParallel(function(GetArguments)\n\9\9Callback(GetArguments())\n\9end)\nend\n\nfunction Signal:Fire(...)\n\9local Arguments = { ... }\n\9local n = select(\"#\", ...)\n\n\9self.Bindable:Fire(function()\n\9\9return table.unpack(Arguments, 1, n)\n\9end)\nend\n\nfunction Signal:Wait()\n\9return self.Bindable.Event:Wait()()\nend\n\nfunction Signal:Destroy()\n\9self.Bindable:Destroy()\nend\n\nreturn Signal\n", "bundle-ex.include.node_modules.@rbxts.signal"))(__env)
end)
__rbx("t", "Folder", "bundle-ex.include.node_modules.@rbxts.t", "bundle-ex.include.node_modules.@rbxts")
__rbx("lib", "Folder", "bundle-ex.include.node_modules.@rbxts.t.lib", "bundle-ex.include.node_modules.@rbxts.t")
__lua("ts", "ModuleScript", "bundle-ex.include.node_modules.@rbxts.t.lib.ts", "bundle-ex.include.node_modules.@rbxts.t.lib", function()
	return assert(loadstring("local _=(...)(\"bundle-ex.include.node_modules.@rbxts.t.lib.ts\")local script,require=_.script,_.require -- t: a runtime typechecker for Roblox\n\nlocal t = {}\n\nfunction t.type(typeName)\n\9return function(value)\n\9\9local valueType = type(value)\n\9\9if valueType == typeName then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\nfunction t.typeof(typeName)\n\9return function(value)\n\9\9local valueType = typeof(value)\n\9\9if valueType == typeName then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9matches any type except nil\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.any(value)\n\9if value ~= nil then\n\9\9return true\n\9else\n\9\9return false\n\9end\nend\n\n--Lua primitives\n\n--[[**\n\9ensures Lua primitive boolean type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.boolean = t.typeof(\"boolean\")\n\n--[[**\n\9ensures Lua primitive thread type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.thread = t.typeof(\"thread\")\n\n--[[**\n\9ensures Lua primitive callback type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.callback = t.typeof(\"function\")\nt[\"function\"] = t.callback\n\n--[[**\n\9ensures Lua primitive none type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.none = t.typeof(\"nil\")\nt[\"nil\"] = t.none\n\n--[[**\n\9ensures Lua primitive string type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.string = t.typeof(\"string\")\n\n--[[**\n\9ensures Lua primitive table type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.table = t.typeof(\"table\")\n\n--[[**\n\9ensures Lua primitive userdata type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.userdata = t.type(\"userdata\")\n\n--[[**\n\9ensures value is a number and non-NaN\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.number(value)\n\9local valueType = typeof(value)\n\9if valueType == \"number\" then\n\9\9if value == value then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9else\n\9\9return false\n\9end\nend\n\n--[[**\n\9ensures value is NaN\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.nan(value)\n\9local valueType = typeof(value)\n\9if valueType == \"number\" then\n\9\9if value ~= value then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9else\n\9\9return false\n\9end\nend\n\n-- roblox types\n\n--[[**\n\9ensures Roblox Axes type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Axes = t.typeof(\"Axes\")\n\n--[[**\n\9ensures Roblox BrickColor type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.BrickColor = t.typeof(\"BrickColor\")\n\n--[[**\n\9ensures Roblox CatalogSearchParams type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.CatalogSearchParams = t.typeof(\"CatalogSearchParams\")\n\n--[[**\n\9ensures Roblox CFrame type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.CFrame = t.typeof(\"CFrame\")\n\n--[[**\n\9ensures Roblox Color3 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Color3 = t.typeof(\"Color3\")\n\n--[[**\n\9ensures Roblox ColorSequence type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.ColorSequence = t.typeof(\"ColorSequence\")\n\n--[[**\n\9ensures Roblox ColorSequenceKeypoint type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.ColorSequenceKeypoint = t.typeof(\"ColorSequenceKeypoint\")\n\n--[[**\n\9ensures Roblox DateTime type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.DateTime = t.typeof(\"DateTime\")\n\n--[[**\n\9ensures Roblox DockWidgetPluginGuiInfo type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.DockWidgetPluginGuiInfo = t.typeof(\"DockWidgetPluginGuiInfo\")\n\n--[[**\n\9ensures Roblox Enum type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Enum = t.typeof(\"Enum\")\n\n--[[**\n\9ensures Roblox EnumItem type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.EnumItem = t.typeof(\"EnumItem\")\n\n--[[**\n\9ensures Roblox Enums type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Enums = t.typeof(\"Enums\")\n\n--[[**\n\9ensures Roblox Faces type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Faces = t.typeof(\"Faces\")\n\n--[[**\n\9ensures Roblox Instance type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Instance = t.typeof(\"Instance\")\n\n--[[**\n\9ensures Roblox NumberRange type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.NumberRange = t.typeof(\"NumberRange\")\n\n--[[**\n\9ensures Roblox NumberSequence type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.NumberSequence = t.typeof(\"NumberSequence\")\n\n--[[**\n\9ensures Roblox NumberSequenceKeypoint type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.NumberSequenceKeypoint = t.typeof(\"NumberSequenceKeypoint\")\n\n--[[**\n\9ensures Roblox PathWaypoint type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.PathWaypoint = t.typeof(\"PathWaypoint\")\n\n--[[**\n\9ensures Roblox PhysicalProperties type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.PhysicalProperties = t.typeof(\"PhysicalProperties\")\n\n--[[**\n\9ensures Roblox Random type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Random = t.typeof(\"Random\")\n\n--[[**\n\9ensures Roblox Ray type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Ray = t.typeof(\"Ray\")\n\n--[[**\n\9ensures Roblox RaycastParams type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RaycastParams = t.typeof(\"RaycastParams\")\n\n--[[**\n\9ensures Roblox RaycastResult type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RaycastResult = t.typeof(\"RaycastResult\")\n\n--[[**\n\9ensures Roblox RBXScriptConnection type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RBXScriptConnection = t.typeof(\"RBXScriptConnection\")\n\n--[[**\n\9ensures Roblox RBXScriptSignal type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.RBXScriptSignal = t.typeof(\"RBXScriptSignal\")\n\n--[[**\n\9ensures Roblox Rect type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Rect = t.typeof(\"Rect\")\n\n--[[**\n\9ensures Roblox Region3 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Region3 = t.typeof(\"Region3\")\n\n--[[**\n\9ensures Roblox Region3int16 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Region3int16 = t.typeof(\"Region3int16\")\n\n--[[**\n\9ensures Roblox TweenInfo type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.TweenInfo = t.typeof(\"TweenInfo\")\n\n--[[**\n\9ensures Roblox UDim type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.UDim = t.typeof(\"UDim\")\n\n--[[**\n\9ensures Roblox UDim2 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.UDim2 = t.typeof(\"UDim2\")\n\n--[[**\n\9ensures Roblox Vector2 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector2 = t.typeof(\"Vector2\")\n\n--[[**\n\9ensures Roblox Vector2int16 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector2int16 = t.typeof(\"Vector2int16\")\n\n--[[**\n\9ensures Roblox Vector3 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector3 = t.typeof(\"Vector3\")\n\n--[[**\n\9ensures Roblox Vector3int16 type\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nt.Vector3int16 = t.typeof(\"Vector3int16\")\n\n--[[**\n\9ensures value is a given literal value\n\n\9@param literal The literal to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.literal(...)\n\9local size = select(\"#\", ...)\n\9if size == 1 then\n\9\9local literal = ...\n\9\9return function(value)\n\9\9\9if value ~= literal then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9else\n\9\9local literals = {}\n\9\9for i = 1, size do\n\9\9\9local value = select(i, ...)\n\9\9\9literals[i] = t.literal(value)\n\9\9end\n\n\9\9return t.union(table.unpack(literals, 1, size))\n\9end\nend\n\n--[[**\n\9DEPRECATED\n\9Please use t.literal\n**--]]\nt.exactly = t.literal\n\n--[[**\n\9Returns a t.union of each key in the table as a t.literal\n\n\9@param keyTable The table to get keys from\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.keyOf(keyTable)\n\9local keys = {}\n\9local length = 0\n\9for key in pairs(keyTable) do\n\9\9length = length + 1\n\9\9keys[length] = key\n\9end\n\n\9return t.literal(table.unpack(keys, 1, length))\nend\n\n--[[**\n\9Returns a t.union of each value in the table as a t.literal\n\n\9@param valueTable The table to get values from\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.valueOf(valueTable)\n\9local values = {}\n\9local length = 0\n\9for _, value in pairs(valueTable) do\n\9\9length = length + 1\n\9\9values[length] = value\n\9end\n\n\9return t.literal(table.unpack(values, 1, length))\nend\n\n--[[**\n\9ensures value is an integer\n\n\9@param value The value to check against\n\n\9@returns True iff the condition is satisfied, false otherwise\n**--]]\nfunction t.integer(value)\n\9local success = t.number(value)\n\9if not success then\n\9\9return false\n\9end\n\n\9if value % 1 == 0 then\n\9\9return true\n\9else\n\9\9return false\n\9end\nend\n\n--[[**\n\9ensures value is a number where min <= value\n\n\9@param min The minimum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMin(min)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if value >= min then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where value <= max\n\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMax(max)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if value <= max then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where min < value\n\n\9@param min The minimum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMinExclusive(min)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if min < value then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where value < max\n\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberMaxExclusive(max)\n\9return function(value)\n\9\9local success = t.number(value)\n\9\9if not success then\n\9\9\9return false\n\9\9end\n\n\9\9if value < max then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9ensures value is a number where value > 0\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nt.numberPositive = t.numberMinExclusive(0)\n\n--[[**\n\9ensures value is a number where value < 0\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nt.numberNegative = t.numberMaxExclusive(0)\n\n--[[**\n\9ensures value is a number where min <= value <= max\n\n\9@param min The minimum to use\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberConstrained(min, max)\n\9assert(t.number(min))\n\9assert(t.number(max))\n\9local minCheck = t.numberMin(min)\n\9local maxCheck = t.numberMax(max)\n\n\9return function(value)\n\9\9local minSuccess = minCheck(value)\n\9\9if not minSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9local maxSuccess = maxCheck(value)\n\9\9if not maxSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is a number where min < value < max\n\n\9@param min The minimum to use\n\9@param max The maximum to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.numberConstrainedExclusive(min, max)\n\9assert(t.number(min))\n\9assert(t.number(max))\n\9local minCheck = t.numberMinExclusive(min)\n\9local maxCheck = t.numberMaxExclusive(max)\n\n\9return function(value)\n\9\9local minSuccess = minCheck(value)\n\9\9if not minSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9local maxSuccess = maxCheck(value)\n\9\9if not maxSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value matches string pattern\n\n\9@param string pattern to check against\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.match(pattern)\n\9assert(t.string(pattern))\n\9return function(value)\n\9\9local stringSuccess = t.string(value)\n\9\9if not stringSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if string.match(value, pattern) == nil then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is either nil or passes check\n\n\9@param check The check to use\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.optional(check)\n\9assert(t.callback(check))\n\9return function(value)\n\9\9if value == nil then\n\9\9\9return true\n\9\9end\n\n\9\9local success = check(value)\n\9\9if success then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\n--[[**\n\9matches given tuple against tuple type definition\n\n\9@param ... The type definition for the tuples\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.tuple(...)\n\9local checks = { ... }\n\9return function(...)\n\9\9local args = { ... }\n\9\9for i, check in ipairs(checks) do\n\9\9\9local success = check(args[i])\n\9\9\9if success == false then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures all keys in given table pass check\n\n\9@param check The function to use to check the keys\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.keys(check)\n\9assert(t.callback(check))\n\9return function(value)\n\9\9local tableSuccess = t.table(value)\n\9\9if tableSuccess == false then\n\9\9\9return false\n\9\9end\n\n\9\9for key in pairs(value) do\n\9\9\9local success = check(key)\n\9\9\9if success == false then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures all values in given table pass check\n\n\9@param check The function to use to check the values\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.values(check)\n\9assert(t.callback(check))\n\9return function(value)\n\9\9local tableSuccess = t.table(value)\n\9\9if tableSuccess == false then\n\9\9\9return false\n\9\9end\n\n\9\9for _, val in pairs(value) do\n\9\9\9local success = check(val)\n\9\9\9if success == false then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is a table and all keys pass keyCheck and all values pass valueCheck\n\n\9@param keyCheck The function to use to check the keys\n\9@param valueCheck The function to use to check the values\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.map(keyCheck, valueCheck)\n\9assert(t.callback(keyCheck))\n\9assert(t.callback(valueCheck))\n\9local keyChecker = t.keys(keyCheck)\n\9local valueChecker = t.values(valueCheck)\n\n\9return function(value)\n\9\9local keySuccess = keyChecker(value)\n\9\9if not keySuccess then\n\9\9\9return false\n\9\9end\n\n\9\9local valueSuccess = valueChecker(value)\n\9\9if not valueSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is a table and all keys pass valueCheck and all values are true\n\n\9@param valueCheck The function to use to check the values\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.set(valueCheck)\n\9return t.map(valueCheck, t.literal(true))\nend\n\ndo\n\9local arrayKeysCheck = t.keys(t.integer)\n--[[**\n\9\9ensures value is an array and all values of the array match check\n\n\9\9@param check The check to compare all values with\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.array(check)\n\9\9assert(t.callback(check))\n\9\9local valuesCheck = t.values(check)\n\n\9\9return function(value)\n\9\9\9local keySuccess = arrayKeysCheck(value)\n\9\9\9if keySuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9-- # is unreliable for sparse arrays\n\9\9\9-- Count upwards using ipairs to avoid false positives from the behavior of #\n\9\9\9local arraySize = 0\n\n\9\9\9for _ in ipairs(value) do\n\9\9\9\9arraySize = arraySize + 1\n\9\9\9end\n\n\9\9\9for key in pairs(value) do\n\9\9\9\9if key < 1 or key > arraySize then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9local valueSuccess = valuesCheck(value)\n\9\9\9if not valueSuccess then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\n\n--[[**\n\9\9ensures value is an array of a strict makeup and size\n\n\9\9@param check The check to compare all values with\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.strictArray(...)\n\9\9local valueTypes = { ... }\n\9\9assert(t.array(t.callback)(valueTypes))\n\n\9\9return function(value)\n\9\9\9local keySuccess = arrayKeysCheck(value)\n\9\9\9if keySuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9-- If there's more than the set array size, disallow\n\9\9\9if #valueTypes < #value then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9for idx, typeFn in pairs(valueTypes) do\n\9\9\9\9local typeSuccess = typeFn(value[idx])\n\9\9\9\9if not typeSuccess then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\nend\n\ndo\n\9local callbackArray = t.array(t.callback)\n--[[**\n\9\9creates a union type\n\n\9\9@param ... The checks to union\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.union(...)\n\9\9local checks = { ... }\n\9\9assert(callbackArray(checks))\n\n\9\9return function(value)\n\9\9\9for _, check in ipairs(checks) do\n\9\9\9\9if check(value) then\n\9\9\9\9\9return true\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return false\n\9\9end\n\9end\n\n--[[**\n\9\9Alias for t.union\n\9**--]]\n\9t.some = t.union\n\n--[[**\n\9\9creates an intersection type\n\n\9\9@param ... The checks to intersect\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.intersection(...)\n\9\9local checks = { ... }\n\9\9assert(callbackArray(checks))\n\n\9\9return function(value)\n\9\9\9for _, check in ipairs(checks) do\n\9\9\9\9local success = check(value)\n\9\9\9\9if not success then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\n\n--[[**\n\9\9Alias for t.intersection\n\9**--]]\n\9t.every = t.intersection\nend\n\ndo\n\9local checkInterface = t.map(t.any, t.callback)\n--[[**\n\9\9ensures value matches given interface definition\n\n\9\9@param checkTable The interface definition\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.interface(checkTable)\n\9\9assert(checkInterface(checkTable))\n\9\9return function(value)\n\9\9\9local tableSuccess = t.table(value)\n\9\9\9if tableSuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9for key, check in pairs(checkTable) do\n\9\9\9\9local success = check(value[key])\n\9\9\9\9if success == false then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\n\n--[[**\n\9\9ensures value matches given interface definition strictly\n\n\9\9@param checkTable The interface definition\n\n\9\9@returns A function that will return true iff the condition is passed\n\9**--]]\n\9function t.strictInterface(checkTable)\n\9\9assert(checkInterface(checkTable))\n\9\9return function(value)\n\9\9\9local tableSuccess = t.table(value)\n\9\9\9if tableSuccess == false then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9for key, check in pairs(checkTable) do\n\9\9\9\9local success = check(value[key])\n\9\9\9\9if success == false then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9for key in pairs(value) do\n\9\9\9\9if not checkTable[key] then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\nend\n\n--[[**\n\9ensure value is an Instance and it's ClassName matches the given ClassName\n\n\9@param className The class name to check for\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.instanceOf(className, childTable)\n\9assert(t.string(className))\n\n\9local childrenCheck\n\9if childTable ~= nil then\n\9\9childrenCheck = t.children(childTable)\n\9end\n\n\9return function(value)\n\9\9local instanceSuccess = t.Instance(value)\n\9\9if not instanceSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if value.ClassName ~= className then\n\9\9\9return false\n\9\9end\n\n\9\9if childrenCheck then\n\9\9\9local childrenSuccess = childrenCheck(value)\n\9\9\9if not childrenSuccess then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\nt.instance = t.instanceOf\n\n--[[**\n\9ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison\n\n\9@param className The class name to check for\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.instanceIsA(className, childTable)\n\9assert(t.string(className))\n\n\9local childrenCheck\n\9if childTable ~= nil then\n\9\9childrenCheck = t.children(childTable)\n\9end\n\n\9return function(value)\n\9\9local instanceSuccess = t.Instance(value)\n\9\9if not instanceSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if not value:IsA(className) then\n\9\9\9return false\n\9\9end\n\n\9\9if childrenCheck then\n\9\9\9local childrenSuccess = childrenCheck(value)\n\9\9\9if not childrenSuccess then\n\9\9\9\9return false\n\9\9\9end\n\9\9end\n\n\9\9return true\n\9end\nend\n\n--[[**\n\9ensures value is an enum of the correct type\n\n\9@param enum The enum to check\n\n\9@returns A function that will return true iff the condition is passed\n**--]]\nfunction t.enum(enum)\n\9assert(t.Enum(enum))\n\9return function(value)\n\9\9local enumItemSuccess = t.EnumItem(value)\n\9\9if not enumItemSuccess then\n\9\9\9return false\n\9\9end\n\n\9\9if value.EnumType == enum then\n\9\9\9return true\n\9\9else\n\9\9\9return false\n\9\9end\n\9end\nend\n\ndo\n\9local checkWrap = t.tuple(t.callback, t.callback)\n\n--[[**\n\9\9wraps a callback in an assert with checkArgs\n\n\9\9@param callback The function to wrap\n\9\9@param checkArgs The function to use to check arguments in the assert\n\n\9\9@returns A function that first asserts using checkArgs and then calls callback\n\9**--]]\n\9function t.wrap(callback, checkArgs)\n\9\9assert(checkWrap(callback, checkArgs))\n\9\9return function(...)\n\9\9\9assert(checkArgs(...))\n\9\9\9return callback(...)\n\9\9end\n\9end\nend\n\n--[[**\n\9asserts a given check\n\n\9@param check The function to wrap with an assert\n\n\9@returns A function that simply wraps the given check in an assert\n**--]]\nfunction t.strict(check)\n\9return function(...)\n\9\9assert(check(...))\n\9end\nend\n\ndo\n\9local checkChildren = t.map(t.string, t.callback)\n\n--[[**\n\9\9Takes a table where keys are child names and values are functions to check the children against.\n\9\9Pass an instance tree into the function.\n\9\9If at least one child passes each check, the overall check passes.\n\n\9\9Warning! If you pass in a tree with more than one child of the same name, this function will always return false\n\n\9\9@param checkTable The table to check against\n\n\9\9@returns A function that checks an instance tree\n\9**--]]\n\9function t.children(checkTable)\n\9\9assert(checkChildren(checkTable))\n\n\9\9return function(value)\n\9\9\9local instanceSuccess = t.Instance(value)\n\9\9\9if not instanceSuccess then\n\9\9\9\9return false\n\9\9\9end\n\n\9\9\9local childrenByName = {}\n\9\9\9for _, child in ipairs(value:GetChildren()) do\n\9\9\9\9local name = child.Name\n\9\9\9\9if checkTable[name] then\n\9\9\9\9\9if childrenByName[name] then\n\9\9\9\9\9\9return false\n\9\9\9\9\9end\n\n\9\9\9\9\9childrenByName[name] = child\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9for name, check in pairs(checkTable) do\n\9\9\9\9local success = check(childrenByName[name])\n\9\9\9\9if not success then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9return true\n\9\9end\n\9end\nend\n\nreturn { t = t }\n", "bundle-ex.include.node_modules.@rbxts.t.lib.ts"))(__env)
end)
__rbx("types", "Folder", "bundle-ex.include.node_modules.@rbxts.types", "bundle-ex.include.node_modules.@rbxts")
__rbx("include", "Folder", "bundle-ex.include.node_modules.@rbxts.types.include", "bundle-ex.include.node_modules.@rbxts.types")
__rbx("generated", "Folder", "bundle-ex.include.node_modules.@rbxts.types.include.generated", "bundle-ex.include.node_modules.@rbxts.types.include")
__start()
